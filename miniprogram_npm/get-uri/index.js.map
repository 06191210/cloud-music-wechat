{"version":3,"sources":["index.js","data.js","notmodified.js","file.js","notfound.js","ftp.js","http.js","https.js","http-error.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AENA;ADIA,AENA,AHSA,AIZA,AFMA;ADIA,AENA,AHSA,AIZA,AFMA;ADIA,AENA,AHSA,AIZA,AFMA;ADIA,AENA,AENA,ALeA,AIZA,AFMA;ADIA,AENA,AENA,ALeA,AIZA,AFMA;ADIA,AENA,AENA,ALeA,AIZA,AFMA;ADIA,AENA,AENA,ACHA,ANkBA,AIZA,AFMA;ADIA,AENA,AENA,ACHA,ANkBA,AIZA,AFMA;ADIA,AENA,AENA,ACHA,ANkBA,AIZA,AFMA;ADIA,AENA,AENA,ACHA,ACHA,APqBA,AIZA,AFMA;ADIA,AENA,AENA,ACHA,ACHA,APqBA,AIZA,AFMA;ADIA,AENA,AENA,ACHA,ACHA,APqBA,AIZA,AFMA;ADIA,AENA,AENA,AGTA,AFMA,ACHA,APqBA,AIZA;AHUA,AENA,AENA,AGTA,AFMA,ACHA,APqBA,AIZA;AHUA,AENA,AENA,AGTA,AFMA,ACHA,APqBA,AIZA;AHUA,AENA,AENA,AGTA,AFMA,ACHA,APqBA,AIZA;AHUA,AENA,AENA,AGTA,AFMA,ACHA,APqBA,AIZA;AHUA,AENA,AENA,AGTA,AFMA,ACHA,APqBA;ACFA,AENA,AENA,AGTA,AFMA,ACHA,APqBA;ACFA,AENA,AENA,AGTA,AFMA,ACHA,APqBA;ACFA,AENA,AENA,AGTA,AFMA,ACHA,APqBA;ACFA,AENA,AENA,AGTA,AFMA,ACHA,APqBA;ACFA,AENA,AENA,AGTA,AFMA,ACHA,APqBA;ACFA,AENA,AENA,AGTA,AFMA,ACHA,APqBA;ACFA,AENA,AENA,AGTA,AFMA,ANkBA;ACFA,AENA,AENA,AGTA,AFMA,ANkBA;ACFA,AENA,AENA,AGTA,AFMA,ANkBA;ACFA,AENA,AENA,AGTA,AFMA,ANkBA;ACFA,AENA,AENA,AGTA,AFMA,ANkBA;ACFA,AENA,AENA,AGTA,AFMA,ANkBA;ACFA,AENA,AENA,ACHA,ANkBA;ACFA,AENA,AENA,ACHA,ANkBA;ACFA,AENA,AENA,ACHA,ANkBA;ACFA,AENA,AENA,ACHA,ANkBA;ACFA,AENA,AENA,ACHA,ANkBA;ACFA,AENA,AENA,ACHA,ANkBA;ACFA,AENA,AENA,ACHA,ANkBA;ACFA,AENA,AENA,ACHA,ANkBA;ACFA,AENA,AENA,ACHA,ANkBA;ACFA,AENA,AENA,ACHA,ANkBA;ACFA,AENA,AENA,ACHA,ANkBA;ACFA,AENA,AENA,ACHA,ANkBA;ACFA,AENA,AENA,ACHA,ANkBA;ACFA,AENA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;AHUA,AENA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nconst debug_1 = __importDefault(require(\"debug\"));\nconst url_1 = require(\"url\");\n// Built-in protocols\nconst data_1 = __importDefault(require(\"./data\"));\nconst file_1 = __importDefault(require(\"./file\"));\nconst ftp_1 = __importDefault(require(\"./ftp\"));\nconst http_1 = __importDefault(require(\"./http\"));\nconst https_1 = __importDefault(require(\"./https\"));\nconst debug = debug_1.default('get-uri');\nfunction getUri(uri, opts, fn) {\n    const p = new Promise((resolve, reject) => {\n        debug('getUri(%o)', uri);\n        if (typeof opts === 'function') {\n            fn = opts;\n            opts = undefined;\n        }\n        if (!uri) {\n            reject(new TypeError('Must pass in a URI to \"get\"'));\n            return;\n        }\n        const parsed = url_1.parse(uri);\n        // Strip trailing `:`\n        const protocol = (parsed.protocol || '').replace(/:$/, '');\n        if (!protocol) {\n            reject(new TypeError(`URI does not contain a protocol: ${uri}`));\n            return;\n        }\n        const getter = getUri.protocols[protocol];\n        if (typeof getter !== 'function') {\n            throw new TypeError(`Unsupported protocol \"${protocol}\" specified in URI: ${uri}`);\n        }\n        resolve(getter(parsed, opts || {}));\n    });\n    if (typeof fn === 'function') {\n        p.then(rtn => fn(null, rtn), err => fn(err));\n    }\n    else {\n        return p;\n    }\n}\n(function (getUri) {\n    getUri.protocols = {\n        data: data_1.default,\n        file: file_1.default,\n        ftp: ftp_1.default,\n        http: http_1.default,\n        https: https_1.default\n    };\n})(getUri || (getUri = {}));\nmodule.exports = getUri;\n//# sourceMappingURL=index.js.map","\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst debug_1 = __importDefault(require(\"debug\"));\nconst stream_1 = require(\"stream\");\nconst crypto_1 = require(\"crypto\");\nconst data_uri_to_buffer_1 = __importDefault(require(\"data-uri-to-buffer\"));\nconst notmodified_1 = __importDefault(require(\"./notmodified\"));\nconst debug = debug_1.default('get-uri:data');\nclass DataReadable extends stream_1.Readable {\n    constructor(hash, buf) {\n        super();\n        this.push(buf);\n        this.push(null);\n        this.hash = hash;\n    }\n}\n/**\n * Returns a Readable stream from a \"data:\" URI.\n */\nfunction get({ href: uri }, { cache }) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // need to create a SHA1 hash of the URI string, for cacheability checks\n        // in future `getUri()` calls with the same data URI passed in.\n        const shasum = crypto_1.createHash('sha1');\n        shasum.update(uri);\n        const hash = shasum.digest('hex');\n        debug('generated SHA1 hash for \"data:\" URI: %o', hash);\n        // check if the cache is the same \"data:\" URI that was previously passed in.\n        if (cache && cache.hash === hash) {\n            debug('got matching cache SHA1 hash: %o', hash);\n            throw new notmodified_1.default();\n        }\n        else {\n            debug('creating Readable stream from \"data:\" URI buffer');\n            const buf = data_uri_to_buffer_1.default(uri);\n            return new DataReadable(hash, buf);\n        }\n    });\n}\nexports.default = get;\n//# sourceMappingURL=data.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Error subclass to use when the source has not been modified.\n *\n * @param {String} message optional \"message\" property to set\n * @api protected\n */\nclass NotModifiedError extends Error {\n    constructor(message) {\n        super(message ||\n            'Source has not been modified since the provied \"cache\", re-use previous results');\n        this.code = 'ENOTMODIFIED';\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nexports.default = NotModifiedError;\n//# sourceMappingURL=notmodified.js.map","\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst debug_1 = __importDefault(require(\"debug\"));\nconst fs_1 = require(\"fs\");\nconst fs_extra_1 = require(\"fs-extra\");\nconst file_uri_to_path_1 = __importDefault(require(\"file-uri-to-path\"));\nconst notfound_1 = __importDefault(require(\"./notfound\"));\nconst notmodified_1 = __importDefault(require(\"./notmodified\"));\nconst debug = debug_1.default('get-uri:file');\n/**\n * Returns a `fs.ReadStream` instance from a \"file:\" URI.\n */\nfunction get({ href: uri }, opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { cache, flags = 'r', mode = 438 // =0666\n         } = opts;\n        try {\n            // Convert URI â†’ Path\n            const filepath = file_uri_to_path_1.default(uri);\n            debug('Normalized pathname: %o', filepath);\n            // `open()` first to get a file descriptor and ensure that the file\n            // exists.\n            const fd = yield fs_extra_1.open(filepath, flags, mode);\n            // Now `fstat()` to check the `mtime` and store the stat object for\n            // the cache.\n            const stat = yield fs_extra_1.fstat(fd);\n            // if a `cache` was provided, check if the file has not been modified\n            if (cache && cache.stat && stat && isNotModified(cache.stat, stat)) {\n                throw new notmodified_1.default();\n            }\n            // `fs.ReadStream` takes care of calling `fs.close()` on the\n            // fd after it's done reading\n            // @ts-ignore - `@types/node` doesn't allow `null` as file path :/\n            const rs = fs_1.createReadStream(null, Object.assign(Object.assign({ autoClose: true }, opts), { fd }));\n            rs.stat = stat;\n            return rs;\n        }\n        catch (err) {\n            if (err.code === 'ENOENT') {\n                throw new notfound_1.default();\n            }\n            throw err;\n        }\n    });\n}\nexports.default = get;\n// returns `true` if the `mtime` of the 2 stat objects are equal\nfunction isNotModified(prev, curr) {\n    return +prev.mtime === +curr.mtime;\n}\n//# sourceMappingURL=file.js.map","\n/**\n * Error subclass to use when the source does not exist at the specified endpoint.\n *\n * @param {String} message optional \"message\" property to set\n * @api protected\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass NotFoundError extends Error {\n    constructor(message) {\n        super(message || 'File does not exist at the specified endpoint');\n        this.code = 'ENOTFOUND';\n        Object.setPrototypeOf(this, new.target.prototype);\n    }\n}\nexports.default = NotFoundError;\n//# sourceMappingURL=notfound.js.map","\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst once_1 = __importDefault(require(\"@tootallnate/once\"));\nconst ftp_1 = __importDefault(require(\"ftp\"));\nconst path_1 = require(\"path\");\nconst debug_1 = __importDefault(require(\"debug\"));\nconst notfound_1 = __importDefault(require(\"./notfound\"));\nconst notmodified_1 = __importDefault(require(\"./notmodified\"));\nconst debug = debug_1.default('get-uri:ftp');\n/**\n * Returns a Readable stream from an \"ftp:\" URI.\n */\nfunction get(parsed, opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { cache } = opts;\n        const filepath = parsed.pathname;\n        let lastModified = null;\n        if (!filepath) {\n            throw new TypeError('No \"pathname\"!');\n        }\n        const client = new ftp_1.default();\n        client.once('greeting', (greeting) => {\n            debug('FTP greeting: %o', greeting);\n        });\n        function onend() {\n            // close the FTP client socket connection\n            client.end();\n        }\n        try {\n            opts.host = parsed.hostname || parsed.host || 'localhost';\n            opts.port = parseInt(parsed.port || '0', 10) || 21;\n            opts.debug = debug;\n            if (parsed.auth) {\n                const [user, password] = parsed.auth.split(':');\n                opts.user = user;\n                opts.password = password;\n            }\n            // await cb(_ => client.connect(opts, _));\n            const readyPromise = once_1.default(client, 'ready');\n            client.connect(opts);\n            yield readyPromise;\n            // first we have to figure out the Last Modified date.\n            // try the MDTM command first, which is an optional extension command.\n            try {\n                lastModified = yield new Promise((resolve, reject) => {\n                    client.lastMod(filepath, (err, res) => {\n                        return err ? reject(err) : resolve(res);\n                    });\n                });\n            }\n            catch (err) {\n                // handle the \"file not found\" error code\n                if (err.code === 550) {\n                    throw new notfound_1.default();\n                }\n            }\n            if (!lastModified) {\n                // Try to get the last modified date via the LIST command (uses\n                // more bandwidth, but is more compatible with older FTP servers\n                const list = yield new Promise((resolve, reject) => {\n                    client.list(path_1.dirname(filepath), (err, res) => {\n                        return err ? reject(err) : resolve(res);\n                    });\n                });\n                // attempt to find the \"entry\" with a matching \"name\"\n                const name = path_1.basename(filepath);\n                const entry = list.find(e => e.name === name);\n                if (entry) {\n                    lastModified = entry.date;\n                }\n            }\n            if (lastModified) {\n                if (isNotModified()) {\n                    throw new notmodified_1.default();\n                }\n            }\n            else {\n                throw new notfound_1.default();\n            }\n            // XXX: a small timeout seemed necessary otherwise FTP servers\n            // were returning empty sockets for the file occasionally\n            // setTimeout(client.get.bind(client, filepath, onfile), 10);\n            const rs = (yield new Promise((resolve, reject) => {\n                client.get(filepath, (err, res) => {\n                    return err ? reject(err) : resolve(res);\n                });\n            }));\n            rs.once('end', onend);\n            rs.lastModified = lastModified;\n            return rs;\n        }\n        catch (err) {\n            client.destroy();\n            throw err;\n        }\n        // called when `lastModified` is set, and a \"cache\" stream was provided\n        function isNotModified() {\n            if (cache && cache.lastModified && lastModified) {\n                return +cache.lastModified === +lastModified;\n            }\n            return false;\n        }\n    });\n}\nexports.default = get;\n//# sourceMappingURL=ftp.js.map","\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst http_1 = __importDefault(require(\"http\"));\nconst https_1 = __importDefault(require(\"https\"));\nconst once_1 = __importDefault(require(\"@tootallnate/once\"));\nconst debug_1 = __importDefault(require(\"debug\"));\nconst url_1 = require(\"url\");\nconst http_error_1 = __importDefault(require(\"./http-error\"));\nconst notfound_1 = __importDefault(require(\"./notfound\"));\nconst notmodified_1 = __importDefault(require(\"./notmodified\"));\nconst debug = debug_1.default('get-uri:http');\n/**\n * Returns a Readable stream from an \"http:\" URI.\n */\nfunction get(parsed, opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n        debug('GET %o', parsed.href);\n        const cache = getCache(parsed, opts.cache);\n        // first check the previous Expires and/or Cache-Control headers\n        // of a previous response if a `cache` was provided\n        if (cache && isFresh(cache) && typeof cache.statusCode === 'number') {\n            // check for a 3xx \"redirect\" status code on the previous cache\n            const type = (cache.statusCode / 100) | 0;\n            if (type === 3 && cache.headers.location) {\n                debug('cached redirect');\n                throw new Error('TODO: implement cached redirects!');\n            }\n            // otherwise we assume that it's the destination endpoint,\n            // since there's nowhere else to redirect to\n            throw new notmodified_1.default();\n        }\n        // 5 redirects allowed by default\n        const maxRedirects = typeof opts.maxRedirects === 'number' ? opts.maxRedirects : 5;\n        debug('allowing %o max redirects', maxRedirects);\n        let mod;\n        if (opts.http) {\n            // the `https` module passed in from the \"http.js\" file\n            mod = opts.http;\n            debug('using secure `https` core module');\n        }\n        else {\n            mod = http_1.default;\n            debug('using `http` core module');\n        }\n        const options = Object.assign(Object.assign({}, opts), parsed);\n        // add \"cache validation\" headers if a `cache` was provided\n        if (cache) {\n            if (!options.headers) {\n                options.headers = {};\n            }\n            const lastModified = cache.headers['last-modified'];\n            if (lastModified) {\n                options.headers['If-Modified-Since'] = lastModified;\n                debug('added \"If-Modified-Since\" request header: %o', lastModified);\n            }\n            const etag = cache.headers.etag;\n            if (etag) {\n                options.headers['If-None-Match'] = etag;\n                debug('added \"If-None-Match\" request header: %o', etag);\n            }\n        }\n        const req = mod.get(options);\n        const res = yield once_1.default(req, 'response');\n        const code = res.statusCode || 0;\n        // assign a Date to this response for the \"Cache-Control\" delta calculation\n        res.date = Date.now();\n        res.parsed = parsed;\n        debug('got %o response status code', code);\n        // any 2xx response is a \"success\" code\n        let type = (code / 100) | 0;\n        // check for a 3xx \"redirect\" status code\n        let location = res.headers.location;\n        if (type === 3 && location) {\n            if (!opts.redirects)\n                opts.redirects = [];\n            let redirects = opts.redirects;\n            if (redirects.length < maxRedirects) {\n                debug('got a \"redirect\" status code with Location: %o', location);\n                // flush this response - we're not going to use it\n                res.resume();\n                // hang on to this Response object for the \"redirects\" Array\n                redirects.push(res);\n                let newUri = url_1.resolve(parsed.href, location);\n                debug('resolved redirect URL: %o', newUri);\n                let left = maxRedirects - redirects.length;\n                debug('%o more redirects allowed after this one', left);\n                // check if redirecting to a different protocol\n                let parsedUrl = url_1.parse(newUri);\n                if (parsedUrl.protocol !== parsed.protocol) {\n                    opts.http = parsedUrl.protocol === 'https:' ? https_1.default : undefined;\n                }\n                return get(parsedUrl, opts);\n            }\n        }\n        // if we didn't get a 2xx \"success\" status code, then create an Error object\n        if (type !== 2) {\n            res.resume();\n            if (code === 304) {\n                throw new notmodified_1.default();\n            }\n            else if (code === 404) {\n                throw new notfound_1.default();\n            }\n            // other HTTP-level error\n            throw new http_error_1.default(code);\n        }\n        if (opts.redirects) {\n            // store a reference to the \"redirects\" Array on the Response object so that\n            // they can be inspected during a subsequent call to GET the same URI\n            res.redirects = opts.redirects;\n        }\n        return res;\n    });\n}\nexports.default = get;\n/**\n * Returns `true` if the provided cache's \"freshness\" is valid. That is, either\n * the Cache-Control header or Expires header values are still within the allowed\n * time period.\n *\n * @return {Boolean}\n * @api private\n */\nfunction isFresh(cache) {\n    let fresh = false;\n    let expires = parseInt(cache.headers.expires || '', 10);\n    const cacheControl = cache.headers['cache-control'];\n    if (cacheControl) {\n        // for Cache-Control rules, see: http://www.mnot.net/cache_docs/#CACHE-CONTROL\n        debug('Cache-Control: %o', cacheControl);\n        const parts = cacheControl.split(/,\\s*?\\b/);\n        for (let i = 0; i < parts.length; i++) {\n            const part = parts[i];\n            const subparts = part.split('=');\n            const name = subparts[0];\n            switch (name) {\n                case 'max-age':\n                    expires = (cache.date || 0) + parseInt(subparts[1], 10) * 1000;\n                    fresh = Date.now() < expires;\n                    if (fresh) {\n                        debug('cache is \"fresh\" due to previous %o Cache-Control param', part);\n                    }\n                    return fresh;\n                case 'must-revalidate':\n                    // XXX: what we supposed to do here?\n                    break;\n                case 'no-cache':\n                case 'no-store':\n                    debug('cache is \"stale\" due to explicit %o Cache-Control param', name);\n                    return false;\n                default:\n                    // ignore unknown cache value\n                    break;\n            }\n        }\n    }\n    else if (expires) {\n        // for Expires rules, see: http://www.mnot.net/cache_docs/#EXPIRES\n        debug('Expires: %o', expires);\n        fresh = Date.now() < expires;\n        if (fresh) {\n            debug('cache is \"fresh\" due to previous Expires response header');\n        }\n        return fresh;\n    }\n    return false;\n}\n/**\n * Attempts to return a previous Response object from a previous GET call to the\n * same URI.\n *\n * @api private\n */\nfunction getCache(parsed, cache) {\n    if (cache) {\n        if (cache.parsed && cache.parsed.href === parsed.href) {\n            return cache;\n        }\n        if (cache.redirects) {\n            for (let i = 0; i < cache.redirects.length; i++) {\n                const c = getCache(parsed, cache.redirects[i]);\n                if (c) {\n                    return c;\n                }\n            }\n        }\n    }\n    return null;\n}\n//# sourceMappingURL=http.js.map","\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst https_1 = __importDefault(require(\"https\"));\nconst http_1 = __importDefault(require(\"./http\"));\n/**\n * Returns a Readable stream from an \"https:\" URI.\n */\nfunction get(parsed, opts) {\n    return http_1.default(parsed, Object.assign(Object.assign({}, opts), { http: https_1.default }));\n}\nexports.default = get;\n//# sourceMappingURL=https.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst http_1 = require(\"http\");\n/**\n * Error subclass to use when an HTTP application error has occurred.\n */\nclass HTTPError extends Error {\n    constructor(statusCode, message = http_1.STATUS_CODES[statusCode]) {\n        super(message);\n        Object.setPrototypeOf(this, new.target.prototype);\n        this.statusCode = statusCode;\n        this.code = `E${String(message)\n            .toUpperCase()\n            .replace(/\\s+/g, '')}`;\n    }\n}\nexports.default = HTTPError;\n//# sourceMappingURL=http-error.js.map"]}