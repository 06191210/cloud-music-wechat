{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nmodule.exports = function decodeURIComponent(string) {\n  var k = string.indexOf('%');\n  if (k === -1) return string;\n\n  var length = string.length;\n  var decoded = '';\n  var last = 0;\n  var codepoint = 0;\n  var startOfOctets = k;\n  state = UTF8_ACCEPT;\n\n  while (k > -1 && k < length - 2) {\n    var high = hexCodeToInt(string[k + 1], 4);\n    var low = hexCodeToInt(string[k + 2], 0);\n    codepoint = decode(codepoint, high | low);\n\n    switch (state) {\n      case UTF8_ACCEPT:\n        decoded += string.substring(last, startOfOctets);\n\n        decoded += (codepoint <= 0xFFFF) ?\n          String.fromCharCode(codepoint) :\n          String.fromCharCode(\n            (0xD7C0 + (codepoint >> 10)),\n            (0xDC00 + (codepoint & 0x3FF))\n          );\n\n        codepoint = 0;\n        last = k + 3;\n        k = startOfOctets = string.indexOf('%', last);\n        break;\n      default:\n        k += 3;\n        if (k < length && string[k] === '%') break;\n\n        // Intentional fall-through\n      case UTF8_REJECT:\n        state = UTF8_ACCEPT;\n        codepoint = 0;\n        k = startOfOctets = string.indexOf('%', startOfOctets + 1);\n        break;\n    }\n  }\n\n  return decoded + string.substring(last);\n};\n\nvar HEX = Object.assign(Object.create(null), {\n  '0':  0, '1':  1,\n  '2':  2, '3':  3,\n  '4':  4, '5':  5,\n  '6':  6, '7':  7,\n  '8':  8, '9':  9,\n  'a': 10, 'A': 10,\n  'b': 11, 'B': 11,\n  'c': 12, 'C': 12,\n  'd': 13, 'D': 13,\n  'e': 14, 'E': 14,\n  'f': 15, 'F': 15,\n});\nfunction hexCodeToInt(c, shift) {\n  var i = HEX[c];\n  return i === undefined ? 255 : i << shift;\n}\n\n\n/**\n * The below algorithm is based on Bjoern Hoehrmann's DFA Unicode Decoder.\n * Copyright (c) 2008-2009 Bjoern Hoehrmann <bjoern@hoehrmann.de>\n * See http://bjoern.hoehrmann.de/utf-8/decoder/dfa/ for details.\n */\nvar UTF8_ACCEPT = 12;\nvar UTF8_REJECT = 0;\nvar UTF8_DATA = [\n  // The first part of the table maps bytes to character to a transition.\n   0, 0, 0, 0,  0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,\n   0, 0, 0, 0,  0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,\n   0, 0, 0, 0,  0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,\n   0, 0, 0, 0,  0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,\n   0, 0, 0, 0,  0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,\n   0, 0, 0, 0,  0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,\n   0, 0, 0, 0,  0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,\n   0, 0, 0, 0,  0, 0, 0, 0,   0, 0, 0, 0, 0, 0, 0, 0,\n   1, 1, 1, 1,  1, 1, 1, 1,   1, 1, 1, 1, 1, 1, 1, 1,\n   2, 2, 2, 2,  2, 2, 2, 2,   2, 2, 2, 2, 2, 2, 2, 2,\n   3, 3, 3, 3,  3, 3, 3, 3,   3, 3, 3, 3, 3, 3, 3, 3,\n   3, 3, 3, 3,  3, 3, 3, 3,   3, 3, 3, 3, 3, 3, 3, 3,\n   4, 4, 5, 5,  5, 5, 5, 5,   5, 5, 5, 5, 5, 5, 5, 5,\n   5, 5, 5, 5,  5, 5, 5, 5,   5, 5, 5, 5, 5, 5, 5, 5,\n   6, 7, 7, 7,  7, 7, 7, 7,   7, 7, 7, 7, 7, 8, 7, 7,\n  10, 9, 9, 9, 11, 4, 4, 4,   4, 4, 4, 4, 4, 4, 4, 4,\n\n  // The second part of the table maps a state to a new state when adding a\n  // transition.\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n  12,  0,  0,  0,  0, 24, 36, 48, 60, 72, 84, 96,\n   0, 12, 12, 12,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0,  0, 24,  0,  0,  0,  0,  0,  0,  0,  0,\n   0, 24, 24, 24,  0,  0,  0,  0,  0,  0,  0,  0,\n   0, 24, 24,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n   0, 48, 48, 48,  0,  0,  0,  0,  0,  0,  0,  0,\n   0,  0, 48, 48,  0,  0,  0,  0,  0,  0,  0,  0,\n   0, 48,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n\n  // The third part maps the current transition to a mask that needs to apply\n  // to the byte.\n  0x7F, 0x3F, 0x3F, 0x3F, 0x00, 0x1F, 0x0F, 0x0F, 0x0F, 0x07, 0x07, 0x07,\n];\n\nvar state = UTF8_ACCEPT;\nfunction decode(codepoint, byte) {\n  var type = UTF8_DATA[byte];\n  state = UTF8_DATA[256 + state + type];\n  return (codepoint << 6) | (byte & UTF8_DATA[364 + type]);\n}\n"]}