{"version":3,"sources":["index.js","dateRange.js","dnsDomainIs.js","dnsDomainLevels.js","dnsResolve.js","util.js","isInNet.js","isPlainHostName.js","isResolvable.js","localHostOrDomainIs.js","myIpAddress.js","shExpMatch.js","timeRange.js","weekdayRange.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,ACHA,AHSA;ACFA,ACHA,ACHA,AHSA;ACFA,ACHA,ACHA,AHSA;ACFA,ACHA,ACHA,ACHA,AJYA;ACFA,ACHA,ACHA,ACHA,AJYA;ACFA,ACHA,ACHA,ACHA,AJYA;ACFA,ACHA,ACHA,ACHA,AJYA,AKfA;AJaA,ACHA,ACHA,ACHA,AJYA,AKfA;AJaA,ACHA,ACHA,ACHA,AJYA,AKfA;AJaA,ACHA,ACHA,ACHA,AJYA,AMlBA,ADGA;AJaA,ACHA,ACHA,ACHA,AJYA,AMlBA,ADGA;AJaA,ACHA,ACHA,ACHA,AJYA,AMlBA,ADGA;AJaA,ACHA,ACHA,ACHA,AJYA,AMlBA,ACHA,AFMA;AJaA,ACHA,ACHA,ACHA,AJYA,AMlBA,ACHA,AFMA;AJaA,ACHA,ACHA,ACHA,AJYA,AMlBA,ACHA,AFMA;AJaA,ACHA,ACHA,ACHA,AJYA,AMlBA,ACHA,ACHA,AHSA;AJaA,ACHA,ACHA,ACHA,AJYA,AMlBA,ACHA,ACHA,AHSA;AJaA,ACHA,ACHA,ACHA,AJYA,AMlBA,ACHA,ACHA,AHSA;AJaA,ACHA,ACHA,ACHA,AJYA,AMlBA,ACHA,ACHA,ACHA,AJYA;AJaA,ACHA,ACHA,ACHA,AJYA,AMlBA,ACHA,ACHA,ACHA,AJYA;AJaA,ACHA,ACHA,ACHA,AJYA,AMlBA,ACHA,ACHA,ACHA,AJYA;AJaA,ACHA,ACHA,ACHA,AJYA,AMlBA,ACHA,ACHA,ACHA,ACHA,ALeA;AJaA,ACHA,ACHA,ACHA,AJYA,AMlBA,ACHA,ACHA,ACHA,ACHA,ALeA;AJaA,ACHA,ACHA,ACHA,AJYA,AMlBA,ACHA,ACHA,ACHA,ACHA,ALeA;AJaA,ACHA,ACHA,ACHA,AJYA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ANkBA;AJaA,ACHA,ACHA,ACHA,AJYA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ANkBA;AJaA,ACHA,ACHA,ACHA,AJYA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ANkBA;AJaA,AENA,ACHA,AJYA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,APqBA;AJaA,AGTA,AJYA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA;AXkCA,AGTA,AJYA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA;AXkCA,AGTA,AJYA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA;AZqCA,AGTA,AJYA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA;AZqCA,AGTA,AJYA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA;AZqCA,AGTA,AJYA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA;AZqCA,AGTA,AJYA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA;AZqCA,AGTA,AJYA,AMlBA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA;AZqCA,AGTA,AJYA,AMlBA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA;AZqCA,AGTA,AJYA,AMlBA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA;AZqCA,AGTA,AJYA,AMlBA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA;AZqCA,AGTA,AJYA,AMlBA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA;AZqCA,AGTA,AJYA,AMlBA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA;AZqCA,AGTA,AJYA,AMlBA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA;AZqCA,AGTA,AJYA,AMlBA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA;AZqCA,AGTA,AJYA,AMlBA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA;AZqCA,AGTA,AJYA,AMlBA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA;AZqCA,AGTA,AJYA,AMlBA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA;AZqCA,ADGA,AMlBA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA;AZqCA,ADGA,AMlBA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA;AZqCA,ADGA,AMlBA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA;AZqCA,ADGA,AMlBA,AGTA,ACHA,ACHA,ACHA,ACHA;AZqCA,ADGA,AMlBA,AGTA,ACHA,ACHA,ACHA,ACHA;AZqCA,ADGA,AMlBA,AGTA,ACHA,ACHA,ACHA,ACHA;AZqCA,ADGA,AMlBA,AGTA,ACHA,ACHA,ACHA,ACHA;AZqCA,ADGA,AMlBA,AGTA,ACHA,ACHA,ACHA,ACHA;AZqCA,ADGA,AMlBA,AGTA,ACHA,ACHA,ACHA,ACHA;AZqCA,ADGA,AMlBA,AGTA,ACHA,ACHA,ACHA,ACHA;AZqCA,ADGA,AMlBA,AGTA,ACHA,ACHA,ACHA,ACHA;AZqCA,ADGA,AMlBA,AGTA,ACHA,ACHA,ACHA,ACHA;AZqCA,ADGA,AMlBA,AIZA,ACHA,ACHA,ACHA;AZqCA,ADGA,AMlBA,AIZA,ACHA,ACHA,ACHA;AZqCA,ADGA,AMlBA,AIZA,ACHA,ACHA,ACHA;AZqCA,ADGA,AMlBA,AIZA,ACHA,ACHA,ACHA;AZqCA,ADGA,AMlBA,AIZA,ACHA,ACHA,ACHA;AZqCA,ADGA,AU9BA,ACHA,ACHA,ACHA;AZqCA,ADGA,AU9BA,ACHA,ACHA,ACHA;AZqCA,ADGA,AU9BA,AENA,ACHA;AZqCA,ADGA,AU9BA,AENA,ACHA;AbwCA,AU9BA,AENA,ACHA;AbwCA,AU9BA,AENA,ACHA;AbwCA,AU9BA,AENA,ACHA;AbwCA,AU9BA,AENA,ACHA;AbwCA,AU9BA,AENA,ACHA;AbwCA,AU9BA,AENA,ACHA;AbwCA,AU9BA,AENA,ACHA;AbwCA,AU9BA,AENA,ACHA;AbwCA,AU9BA,AENA,ACHA;AbwCA,AU9BA,AENA,ACHA;AbwCA,AU9BA,AENA,ACHA;AbwCA,AU9BA,AENA,ACHA;AbwCA,AU9BA,AENA,ACHA;AbwCA,AU9BA,AENA,ACHA;AbwCA,AU9BA,AENA,ACHA;AbwCA,AYpCA,ACHA;AbwCA,AYpCA,ACHA;AbwCA,AYpCA,ACHA;AbwCA,AYpCA,ACHA;AbwCA,AYpCA,ACHA;AbwCA,AYpCA,ACHA;AbwCA,AYpCA,ACHA;AbwCA,AYpCA,ACHA;AbwCA,AYpCA,ACHA;AbwCA,AYpCA,ACHA;AbwCA,AYpCA,ACHA;AbwCA,AYpCA,ACHA;AbwCA,AYpCA,ACHA;AbwCA,AYpCA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA","file":"index.js","sourcesContent":["\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nconst url_1 = require(\"url\");\nconst degenerator_1 = require(\"degenerator\");\n/**\n * Built-in PAC functions.\n */\nconst dateRange_1 = __importDefault(require(\"./dateRange\"));\nconst dnsDomainIs_1 = __importDefault(require(\"./dnsDomainIs\"));\nconst dnsDomainLevels_1 = __importDefault(require(\"./dnsDomainLevels\"));\nconst dnsResolve_1 = __importDefault(require(\"./dnsResolve\"));\nconst isInNet_1 = __importDefault(require(\"./isInNet\"));\nconst isPlainHostName_1 = __importDefault(require(\"./isPlainHostName\"));\nconst isResolvable_1 = __importDefault(require(\"./isResolvable\"));\nconst localHostOrDomainIs_1 = __importDefault(require(\"./localHostOrDomainIs\"));\nconst myIpAddress_1 = __importDefault(require(\"./myIpAddress\"));\nconst shExpMatch_1 = __importDefault(require(\"./shExpMatch\"));\nconst timeRange_1 = __importDefault(require(\"./timeRange\"));\nconst weekdayRange_1 = __importDefault(require(\"./weekdayRange\"));\n/**\n * Returns an asynchronous `FindProxyForURL()` function\n * from the given JS string (from a PAC file).\n *\n * @param {String} str JS string\n * @param {Object} opts optional \"options\" object\n * @return {Function} async resolver function\n */\nfunction createPacResolver(_str, _opts = {}) {\n    const str = Buffer.isBuffer(_str) ? _str.toString('utf8') : _str;\n    // The sandbox to use for the `vm` context.\n    const sandbox = Object.assign(Object.assign({}, createPacResolver.sandbox), _opts.sandbox);\n    const opts = Object.assign(Object.assign({ filename: 'proxy.pac' }, _opts), { sandbox });\n    // Construct the array of async function names to add `await` calls to.\n    const names = Object.keys(sandbox).filter((k) => isAsyncFunction(sandbox[k]));\n    // Compile the JS `FindProxyForURL()` function into an async function.\n    const resolver = (0, degenerator_1.compile)(str, 'FindProxyForURL', names, opts);\n    function FindProxyForURL(url, _host, _callback) {\n        let host = null;\n        let callback = null;\n        if (typeof _callback === 'function') {\n            callback = _callback;\n        }\n        if (typeof _host === 'string') {\n            host = _host;\n        }\n        else if (typeof _host === 'function') {\n            callback = _host;\n        }\n        if (!host) {\n            host = (0, url_1.parse)(url).hostname;\n        }\n        if (!host) {\n            throw new TypeError('Could not determine `host`');\n        }\n        const promise = resolver(url, host);\n        if (typeof callback === 'function') {\n            toCallback(promise, callback);\n        }\n        else {\n            return promise;\n        }\n    }\n    Object.defineProperty(FindProxyForURL, 'toString', {\n        value: () => resolver.toString(),\n        enumerable: false,\n    });\n    return FindProxyForURL;\n}\n// eslint-disable-next-line @typescript-eslint/no-namespace\n(function (createPacResolver) {\n    createPacResolver.sandbox = Object.freeze({\n        alert: (message = '') => console.log('%s', message),\n        dateRange: dateRange_1.default,\n        dnsDomainIs: dnsDomainIs_1.default,\n        dnsDomainLevels: dnsDomainLevels_1.default,\n        dnsResolve: dnsResolve_1.default,\n        isInNet: isInNet_1.default,\n        isPlainHostName: isPlainHostName_1.default,\n        isResolvable: isResolvable_1.default,\n        localHostOrDomainIs: localHostOrDomainIs_1.default,\n        myIpAddress: myIpAddress_1.default,\n        shExpMatch: shExpMatch_1.default,\n        timeRange: timeRange_1.default,\n        weekdayRange: weekdayRange_1.default,\n    });\n})(createPacResolver || (createPacResolver = {}));\nfunction toCallback(promise, callback) {\n    promise.then((rtn) => callback(null, rtn), callback);\n}\nfunction isAsyncFunction(v) {\n    if (typeof v !== 'function')\n        return false;\n    // Native `AsyncFunction`\n    if (v.constructor.name === 'AsyncFunction')\n        return true;\n    // TypeScript compiled\n    if (String(v).indexOf('__awaiter(') !== -1)\n        return true;\n    // Legacy behavior - set `async` property on the function\n    return Boolean(v.async);\n}\nmodule.exports = createPacResolver;\n//# sourceMappingURL=index.js.map","\n/**\n * If only a single value is specified (from each category: day, month, year), the\n * function returns a true value only on days that match that specification. If\n * both values are specified, the result is true between those times, including\n * bounds.\n *\n * Even though the examples don't show, the \"GMT\" parameter can be specified\n * in any of the 9 different call profiles, always as the last parameter.\n *\n * Examples:\n *\n * ``` js\n * dateRange(1)\n * true on the first day of each month, local timezone.\n *\n * dateRange(1, \"GMT\")\n * true on the first day of each month, GMT timezone.\n *\n * dateRange(1, 15)\n * true on the first half of each month.\n *\n * dateRange(24, \"DEC\")\n * true on 24th of December each year.\n *\n * dateRange(24, \"DEC\", 1995)\n * true on 24th of December, 1995.\n *\n * dateRange(\"JAN\", \"MAR\")\n * true on the first quarter of the year.\n *\n * dateRange(1, \"JUN\", 15, \"AUG\")\n * true from June 1st until August 15th, each year (including June 1st and August\n * 15th).\n *\n * dateRange(1, \"JUN\", 15, 1995, \"AUG\", 1995)\n * true from June 1st, 1995, until August 15th, same year.\n *\n * dateRange(\"OCT\", 1995, \"MAR\", 1996)\n * true from October 1995 until March 1996 (including the entire month of October\n * 1995 and March 1996).\n *\n * dateRange(1995)\n * true during the entire year 1995.\n *\n * dateRange(1995, 1997)\n * true from beginning of year 1995 until the end of year 1997.\n * ```\n *\n * dateRange(day)\n * dateRange(day1, day2)\n * dateRange(mon)\n * dateRange(month1, month2)\n * dateRange(year)\n * dateRange(year1, year2)\n * dateRange(day1, month1, day2, month2)\n * dateRange(month1, year1, month2, year2)\n * dateRange(day1, month1, year1, day2, month2, year2)\n * dateRange(day1, month1, year1, day2, month2, year2, gmt)\n *\n * @param {String} day is the day of month between 1 and 31 (as an integer).\n * @param {String} month is one of the month strings: JAN FEB MAR APR MAY JUN JUL AUG SEP OCT NOV DEC\n * @param {String} year is the full year number, for example 1995 (but not 95). Integer.\n * @param {String} gmt is either the string \"GMT\", which makes time comparison occur in GMT timezone; if left unspecified, times are taken to be in the local timezone.\n * @return {Boolean}\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction dateRange() {\n    // TODO: implement me!\n    return false;\n}\nexports.default = dateRange;\n//# sourceMappingURL=dateRange.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Returns true iff the domain of hostname matches.\n *\n * Examples:\n *\n * ``` js\n * dnsDomainIs(\"www.netscape.com\", \".netscape.com\")\n *   // is true.\n *\n * dnsDomainIs(\"www\", \".netscape.com\")\n *   // is false.\n *\n * dnsDomainIs(\"www.mcom.com\", \".netscape.com\")\n *   // is false.\n * ```\n *\n *\n * @param {String} host is the hostname from the URL.\n * @param {String} domain is the domain name to test the hostname against.\n * @return {Boolean} true iff the domain of the hostname matches.\n */\nfunction dnsDomainIs(host, domain) {\n    host = String(host);\n    domain = String(domain);\n    return host.substr(domain.length * -1) === domain;\n}\nexports.default = dnsDomainIs;\n//# sourceMappingURL=dnsDomainIs.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Returns the number (integer) of DNS domain levels (number of dots) in the\n * hostname.\n *\n * Examples:\n *\n * ``` js\n * dnsDomainLevels(\"www\")\n *   // returns 0.\n * dnsDomainLevels(\"www.netscape.com\")\n *   // returns 2.\n * ```\n *\n * @param {String} host is the hostname from the URL.\n * @return {Number} number of domain levels\n */\nfunction dnsDomainLevels(host) {\n    const match = String(host).match(/\\./g);\n    let levels = 0;\n    if (match) {\n        levels = match.length;\n    }\n    return levels;\n}\nexports.default = dnsDomainLevels;\n//# sourceMappingURL=dnsDomainLevels.js.map","\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = require(\"./util\");\n/**\n * Resolves the given DNS hostname into an IP address, and returns it in the dot\n * separated format as a string.\n *\n * Example:\n *\n * ``` js\n * dnsResolve(\"home.netscape.com\")\n *   // returns the string \"198.95.249.79\".\n * ```\n *\n * @param {String} host hostname to resolve\n * @return {String} resolved IP address\n */\nfunction dnsResolve(host) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const family = 4;\n        try {\n            const r = yield (0, util_1.dnsLookup)(host, { family });\n            if (typeof r === 'string') {\n                return r;\n            }\n        }\n        catch (err) {\n            // @ignore\n        }\n        return null;\n    });\n}\nexports.default = dnsResolve;\n//# sourceMappingURL=dnsResolve.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isGMT = exports.dnsLookup = void 0;\nconst dns_1 = require(\"dns\");\nfunction dnsLookup(host, opts) {\n    return new Promise((resolve, reject) => {\n        (0, dns_1.lookup)(host, opts, (err, res) => {\n            if (err) {\n                reject(err);\n            }\n            else {\n                resolve(res);\n            }\n        });\n    });\n}\nexports.dnsLookup = dnsLookup;\nfunction isGMT(v) {\n    return v === 'GMT';\n}\nexports.isGMT = isGMT;\n//# sourceMappingURL=util.js.map","\n/**\n * Module dependencies.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst netmask_1 = require(\"netmask\");\nconst util_1 = require(\"./util\");\n/**\n * True iff the IP address of the host matches the specified IP address pattern.\n *\n * Pattern and mask specification is done the same way as for SOCKS configuration.\n *\n * Examples:\n *\n * ``` js\n * isInNet(host, \"198.95.249.79\", \"255.255.255.255\")\n *   // is true iff the IP address of host matches exactly 198.95.249.79.\n *\n * isInNet(host, \"198.95.0.0\", \"255.255.0.0\")\n *   // is true iff the IP address of the host matches 198.95.*.*.\n * ```\n *\n * @param {String} host a DNS hostname, or IP address. If a hostname is passed,\n *   it will be resoved into an IP address by this function.\n * @param {String} pattern an IP address pattern in the dot-separated format mask.\n * @param {String} mask for the IP address pattern informing which parts of the\n *   IP address should be matched against. 0 means ignore, 255 means match.\n * @return {Boolean}\n */\nfunction isInNet(host, pattern, mask) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const family = 4;\n        try {\n            const ip = yield (0, util_1.dnsLookup)(host, { family });\n            if (typeof ip === 'string') {\n                const netmask = new netmask_1.Netmask(pattern, mask);\n                return netmask.contains(ip);\n            }\n        }\n        catch (err) { }\n        return false;\n    });\n}\nexports.default = isInNet;\n//# sourceMappingURL=isInNet.js.map","\n/**\n * True iff there is no domain name in the hostname (no dots).\n *\n * Examples:\n *\n * ``` js\n * isPlainHostName(\"www\")\n *   // is true.\n *\n * isPlainHostName(\"www.netscape.com\")\n *   // is false.\n * ```\n *\n * @param {String} host The hostname from the URL (excluding port number).\n * @return {Boolean}\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction isPlainHostName(host) {\n    return !/\\./.test(host);\n}\nexports.default = isPlainHostName;\n//# sourceMappingURL=isPlainHostName.js.map","\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = require(\"./util\");\n/**\n * Tries to resolve the hostname. Returns true if succeeds.\n *\n * @param {String} host is the hostname from the URL.\n * @return {Boolean}\n */\nfunction isResolvable(host) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const family = 4;\n        try {\n            if (yield (0, util_1.dnsLookup)(host, { family })) {\n                return true;\n            }\n        }\n        catch (err) {\n            // ignore\n        }\n        return false;\n    });\n}\nexports.default = isResolvable;\n//# sourceMappingURL=isResolvable.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Is true if the hostname matches exactly the specified hostname, or if there is\n * no domain name part in the hostname, but the unqualified hostname matches.\n *\n * Examples:\n *\n * ``` js\n * localHostOrDomainIs(\"www.netscape.com\", \"www.netscape.com\")\n *   // is true (exact match).\n *\n * localHostOrDomainIs(\"www\", \"www.netscape.com\")\n *   // is true (hostname match, domain not specified).\n *\n * localHostOrDomainIs(\"www.mcom.com\", \"www.netscape.com\")\n *   // is false (domain name mismatch).\n *\n * localHostOrDomainIs(\"home.netscape.com\", \"www.netscape.com\")\n *   // is false (hostname mismatch).\n * ```\n *\n * @param {String} host the hostname from the URL.\n * @param {String} hostdom fully qualified hostname to match against.\n * @return {Boolean}\n */\nfunction localHostOrDomainIs(host, hostdom) {\n    const parts = host.split('.');\n    const domparts = hostdom.split('.');\n    let matches = true;\n    for (let i = 0; i < parts.length; i++) {\n        if (parts[i] !== domparts[i]) {\n            matches = false;\n            break;\n        }\n    }\n    return matches;\n}\nexports.default = localHostOrDomainIs;\n//# sourceMappingURL=localHostOrDomainIs.js.map","\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ip_1 = __importDefault(require(\"ip\"));\nconst net_1 = __importDefault(require(\"net\"));\n/**\n * Returns the IP address of the host that the Navigator is running on, as\n * a string in the dot-separated integer format.\n *\n * Example:\n *\n * ``` js\n * myIpAddress()\n *   // would return the string \"198.95.249.79\" if you were running the\n *   // Navigator on that host.\n * ```\n *\n * @return {String} external IP address\n */\nfunction myIpAddress() {\n    return __awaiter(this, void 0, void 0, function* () {\n        return new Promise((resolve, reject) => {\n            // 8.8.8.8:53 is \"Google Public DNS\":\n            // https://developers.google.com/speed/public-dns/\n            const socket = net_1.default.connect({ host: '8.8.8.8', port: 53 });\n            const onError = () => {\n                // if we fail to access Google DNS (as in firewall blocks access),\n                // fallback to querying IP locally\n                resolve(ip_1.default.address());\n            };\n            socket.once('error', onError);\n            socket.once('connect', () => {\n                socket.removeListener('error', onError);\n                const addr = socket.address();\n                socket.destroy();\n                if (typeof addr === 'string') {\n                    resolve(addr);\n                }\n                else if (addr.address) {\n                    resolve(addr.address);\n                }\n                else {\n                    reject(new Error('Expected a `string`'));\n                }\n            });\n        });\n    });\n}\nexports.default = myIpAddress;\n//# sourceMappingURL=myIpAddress.js.map","\n/**\n * Returns true if the string matches the specified shell\n * expression.\n *\n * Actually, currently the patterns are shell expressions,\n * not regular expressions.\n *\n * Examples:\n *\n * ``` js\n * shExpMatch(\"http://home.netscape.com/people/ari/index.html\", \"*\\/ari/*\")\n *   // is true.\n *\n * shExpMatch(\"http://home.netscape.com/people/montulli/index.html\", \"*\\/ari/*\")\n *   // is false.\n * ```\n *\n * @param {String} str is any string to compare (e.g. the URL, or the hostname).\n * @param {String} shexp is a shell expression to compare against.\n * @return {Boolean} true if the string matches the shell expression.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction shExpMatch(str, shexp) {\n    const re = toRegExp(shexp);\n    return re.test(str);\n}\nexports.default = shExpMatch;\n/**\n * Converts a \"shell expression\" to a JavaScript RegExp.\n *\n * @api private\n */\nfunction toRegExp(str) {\n    str = String(str)\n        .replace(/\\./g, '\\\\.')\n        .replace(/\\?/g, '.')\n        .replace(/\\*/g, '.*');\n    return new RegExp(`^${str}$`);\n}\n//# sourceMappingURL=shExpMatch.js.map","\n/**\n * True during (or between) the specified time(s).\n *\n * Even though the examples don't show it, this parameter may be present in\n * each of the different parameter profiles, always as the last parameter.\n *\n *\n * Examples:\n *\n * ``` js\n * timerange(12)\n * true from noon to 1pm.\n *\n * timerange(12, 13)\n * same as above.\n *\n * timerange(12, \"GMT\")\n * true from noon to 1pm, in GMT timezone.\n *\n * timerange(9, 17)\n * true from 9am to 5pm.\n *\n * timerange(8, 30, 17, 00)\n * true from 8:30am to 5:00pm.\n *\n * timerange(0, 0, 0, 0, 0, 30)\n * true between midnight and 30 seconds past midnight.\n * ```\n *\n * timeRange(hour)\n * timeRange(hour1, hour2)\n * timeRange(hour1, min1, hour2, min2)\n * timeRange(hour1, min1, sec1, hour2, min2, sec2)\n * timeRange(hour1, min1, sec1, hour2, min2, sec2, gmt)\n *\n * @param {String} hour is the hour from 0 to 23. (0 is midnight, 23 is 11 pm.)\n * @param {String} min minutes from 0 to 59.\n * @param {String} sec seconds from 0 to 59.\n * @param {String} gmt either the string \"GMT\" for GMT timezone, or not specified, for local timezone.\n * @return {Boolean}\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction timeRange() {\n    // eslint-disable-next-line prefer-rest-params\n    const args = Array.prototype.slice.call(arguments);\n    const lastArg = args.pop();\n    const useGMTzone = lastArg === 'GMT';\n    const currentDate = new Date();\n    if (!useGMTzone) {\n        args.push(lastArg);\n    }\n    const noOfArgs = args.length;\n    let result = false;\n    let numericArgs = args.map((n) => parseInt(n, 10));\n    // timeRange(hour)\n    if (noOfArgs === 1) {\n        result = getCurrentHour(useGMTzone, currentDate) === numericArgs[0];\n        // timeRange(hour1, hour2)\n    }\n    else if (noOfArgs === 2) {\n        const currentHour = getCurrentHour(useGMTzone, currentDate);\n        result = numericArgs[0] <= currentHour && currentHour < numericArgs[1];\n        // timeRange(hour1, min1, hour2, min2)\n    }\n    else if (noOfArgs === 4) {\n        result = valueInRange(secondsElapsedToday(numericArgs[0], numericArgs[1], 0), secondsElapsedToday(getCurrentHour(useGMTzone, currentDate), getCurrentMinute(useGMTzone, currentDate), 0), secondsElapsedToday(numericArgs[2], numericArgs[3], 59));\n        // timeRange(hour1, min1, sec1, hour2, min2, sec2)\n    }\n    else if (noOfArgs === 6) {\n        result = valueInRange(secondsElapsedToday(numericArgs[0], numericArgs[1], numericArgs[2]), secondsElapsedToday(getCurrentHour(useGMTzone, currentDate), getCurrentMinute(useGMTzone, currentDate), getCurrentSecond(useGMTzone, currentDate)), secondsElapsedToday(numericArgs[3], numericArgs[4], numericArgs[5]));\n    }\n    return result;\n}\nexports.default = timeRange;\nfunction secondsElapsedToday(hh, mm, ss) {\n    return hh * 3600 + mm * 60 + ss;\n}\nfunction getCurrentHour(gmt, currentDate) {\n    return gmt ? currentDate.getUTCHours() : currentDate.getHours();\n}\nfunction getCurrentMinute(gmt, currentDate) {\n    return gmt ? currentDate.getUTCMinutes() : currentDate.getMinutes();\n}\nfunction getCurrentSecond(gmt, currentDate) {\n    return gmt ? currentDate.getUTCSeconds() : currentDate.getSeconds();\n}\n// start <= value <= finish\nfunction valueInRange(start, value, finish) {\n    return start <= value && value <= finish;\n}\n//# sourceMappingURL=timeRange.js.map","\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util_1 = require(\"./util\");\nconst weekdays = ['SUN', 'MON', 'TUE', 'WED', 'THU', 'FRI', 'SAT'];\n/**\n * Only the first parameter is mandatory. Either the second, the third, or both\n * may be left out.\n *\n * If only one parameter is present, the function yeilds a true value on the\n * weekday that the parameter represents. If the string \"GMT\" is specified as\n * a second parameter, times are taken to be in GMT, otherwise in local timezone.\n *\n * If both wd1 and wd1 are defined, the condition is true if the current weekday\n * is in between those two weekdays. Bounds are inclusive. If the \"GMT\" parameter\n * is specified, times are taken to be in GMT, otherwise the local timezone is\n * used.\n *\n * Valid \"weekday strings\" are:\n *\n *     SUN MON TUE WED THU FRI SAT\n *\n * Examples:\n *\n * ``` js\n * weekdayRange(\"MON\", \"FRI\")\n * true Monday trhough Friday (local timezone).\n *\n * weekdayRange(\"MON\", \"FRI\", \"GMT\")\n * same as above, but GMT timezone.\n *\n * weekdayRange(\"SAT\")\n * true on Saturdays local time.\n *\n * weekdayRange(\"SAT\", \"GMT\")\n * true on Saturdays GMT time.\n *\n * weekdayRange(\"FRI\", \"MON\")\n * true Friday through Monday (note, order does matter!).\n * ```\n *\n *\n * @param {String} wd1 one of the weekday strings.\n * @param {String} wd2 one of the weekday strings.\n * @param {String} gmt is either the string: GMT or is left out.\n * @return {Boolean}\n */\nfunction weekdayRange(wd1, wd2, gmt) {\n    let useGMTzone = false;\n    let wd1Index = -1;\n    let wd2Index = -1;\n    let wd2IsGmt = false;\n    if ((0, util_1.isGMT)(gmt)) {\n        useGMTzone = true;\n    }\n    else if ((0, util_1.isGMT)(wd2)) {\n        useGMTzone = true;\n        wd2IsGmt = true;\n    }\n    wd1Index = weekdays.indexOf(wd1);\n    if (!wd2IsGmt && isWeekday(wd2)) {\n        wd2Index = weekdays.indexOf(wd2);\n    }\n    let todaysDay = getTodaysDay(useGMTzone);\n    let result;\n    if (wd2Index < 0) {\n        result = todaysDay === wd1Index;\n    }\n    else if (wd1Index <= wd2Index) {\n        result = valueInRange(wd1Index, todaysDay, wd2Index);\n    }\n    else {\n        result =\n            valueInRange(wd1Index, todaysDay, 6) ||\n                valueInRange(0, todaysDay, wd2Index);\n    }\n    return result;\n}\nexports.default = weekdayRange;\nfunction getTodaysDay(gmt) {\n    return gmt ? new Date().getUTCDay() : new Date().getDay();\n}\n// start <= value <= finish\nfunction valueInRange(start, value, finish) {\n    return start <= value && value <= finish;\n}\nfunction isWeekday(v) {\n    return weekdays.indexOf(v) !== -1;\n}\n//# sourceMappingURL=weekdayRange.js.map"]}