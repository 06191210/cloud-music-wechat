{"version":3,"sources":["index.js","agent.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nconst get_uri_1 = __importDefault(require(\"get-uri\"));\nconst url_1 = require(\"url\");\nconst agent_1 = __importDefault(require(\"./agent\"));\nfunction createPacProxyAgent(uri, opts) {\n    // was an options object passed in first?\n    if (typeof uri === 'object') {\n        opts = uri;\n        // result of a url.parse() call?\n        if (opts.href) {\n            if (opts.path && !opts.pathname) {\n                opts.pathname = opts.path;\n            }\n            opts.slashes = true;\n            uri = url_1.format(opts);\n        }\n        else {\n            uri = opts.uri;\n        }\n    }\n    if (!opts) {\n        opts = {};\n    }\n    if (typeof uri !== 'string') {\n        throw new TypeError('a PAC file URI must be specified!');\n    }\n    return new agent_1.default(uri, opts);\n}\n(function (createPacProxyAgent) {\n    createPacProxyAgent.PacProxyAgent = agent_1.default;\n    /**\n     * Supported \"protocols\". Delegates out to the `get-uri` module.\n     */\n    createPacProxyAgent.protocols = Object.keys(get_uri_1.default.protocols);\n    createPacProxyAgent.prototype = agent_1.default.prototype;\n})(createPacProxyAgent || (createPacProxyAgent = {}));\nmodule.exports = createPacProxyAgent;\n//# sourceMappingURL=index.js.map","\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst net_1 = __importDefault(require(\"net\"));\nconst tls_1 = __importDefault(require(\"tls\"));\nconst once_1 = __importDefault(require(\"@tootallnate/once\"));\nconst crypto_1 = __importDefault(require(\"crypto\"));\nconst get_uri_1 = __importDefault(require(\"get-uri\"));\nconst debug_1 = __importDefault(require(\"debug\"));\nconst raw_body_1 = __importDefault(require(\"raw-body\"));\nconst url_1 = require(\"url\");\nconst http_proxy_agent_1 = require(\"http-proxy-agent\");\nconst https_proxy_agent_1 = require(\"https-proxy-agent\");\nconst socks_proxy_agent_1 = require(\"socks-proxy-agent\");\nconst pac_resolver_1 = __importDefault(require(\"pac-resolver\"));\nconst agent_base_1 = require(\"agent-base\");\nconst debug = debug_1.default('pac-proxy-agent');\n/**\n * The `PacProxyAgent` class.\n *\n * A few different \"protocol\" modes are supported (supported protocols are\n * backed by the `get-uri` module):\n *\n *   - \"pac+data\", \"data\" - refers to an embedded \"data:\" URI\n *   - \"pac+file\", \"file\" - refers to a local file\n *   - \"pac+ftp\", \"ftp\" - refers to a file located on an FTP server\n *   - \"pac+http\", \"http\" - refers to an HTTP endpoint\n *   - \"pac+https\", \"https\" - refers to an HTTPS endpoint\n *\n * @api public\n */\nclass PacProxyAgent extends agent_base_1.Agent {\n    constructor(uri, opts = {}) {\n        super(opts);\n        this.clearResolverPromise = () => {\n            this.resolverPromise = undefined;\n        };\n        debug('Creating PacProxyAgent with URI %o and options %o', uri, opts);\n        // Strip the \"pac+\" prefix\n        this.uri = uri.replace(/^pac\\+/i, '');\n        this.opts = Object.assign({}, opts);\n        this.cache = undefined;\n        this.resolver = undefined;\n        this.resolverHash = '';\n        this.resolverPromise = undefined;\n        // For `PacResolver`\n        if (!this.opts.filename) {\n            this.opts.filename = uri;\n        }\n    }\n    /**\n     * Loads the PAC proxy file from the source if necessary, and returns\n     * a generated `FindProxyForURL()` resolver function to use.\n     *\n     * @api private\n     */\n    getResolver() {\n        if (!this.resolverPromise) {\n            this.resolverPromise = this.loadResolver();\n            this.resolverPromise.then(this.clearResolverPromise, this.clearResolverPromise);\n        }\n        return this.resolverPromise;\n    }\n    loadResolver() {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                // (Re)load the contents of the PAC file URI\n                const code = yield this.loadPacFile();\n                // Create a sha1 hash of the JS code\n                const hash = crypto_1.default\n                    .createHash('sha1')\n                    .update(code)\n                    .digest('hex');\n                if (this.resolver && this.resolverHash === hash) {\n                    debug('Same sha1 hash for code - contents have not changed, reusing previous proxy resolver');\n                    return this.resolver;\n                }\n                // Cache the resolver\n                debug('Creating new proxy resolver instance');\n                this.resolver = pac_resolver_1.default(code, this.opts);\n                // Store that sha1 hash for future comparison purposes\n                this.resolverHash = hash;\n                return this.resolver;\n            }\n            catch (err) {\n                if (this.resolver && err.code === 'ENOTMODIFIED') {\n                    debug('Got ENOTMODIFIED response, reusing previous proxy resolver');\n                    return this.resolver;\n                }\n                throw err;\n            }\n        });\n    }\n    /**\n     * Loads the contents of the PAC proxy file.\n     *\n     * @api private\n     */\n    loadPacFile() {\n        return __awaiter(this, void 0, void 0, function* () {\n            debug('Loading PAC file: %o', this.uri);\n            const rs = yield get_uri_1.default(this.uri, { cache: this.cache });\n            debug('Got `Readable` instance for URI');\n            this.cache = rs;\n            const buf = yield raw_body_1.default(rs);\n            debug('Read %o byte PAC file from URI', buf.length);\n            return buf.toString('utf8');\n        });\n    }\n    /**\n     * Called when the node-core HTTP client library is creating a new HTTP request.\n     *\n     * @api protected\n     */\n    callback(req, opts) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { secureEndpoint } = opts;\n            // First, get a generated `FindProxyForURL()` function,\n            // either cached or retrieved from the source\n            const resolver = yield this.getResolver();\n            // Calculate the `url` parameter\n            const defaultPort = secureEndpoint ? 443 : 80;\n            let path = req.path;\n            let search = null;\n            const firstQuestion = path.indexOf('?');\n            if (firstQuestion !== -1) {\n                search = path.substring(firstQuestion);\n                path = path.substring(0, firstQuestion);\n            }\n            const urlOpts = Object.assign(Object.assign({}, opts), { protocol: secureEndpoint ? 'https:' : 'http:', pathname: path, search, \n                // need to use `hostname` instead of `host` otherwise `port` is ignored\n                hostname: opts.host, host: null, href: null, \n                // set `port` to null when it is the protocol default port (80 / 443)\n                port: defaultPort === opts.port ? null : opts.port });\n            const url = url_1.format(urlOpts);\n            debug('url: %o', url);\n            let result = yield resolver(url);\n            // Default to \"DIRECT\" if a falsey value was returned (or nothing)\n            if (!result) {\n                result = 'DIRECT';\n            }\n            const proxies = String(result)\n                .trim()\n                .split(/\\s*;\\s*/g)\n                .filter(Boolean);\n            if (this.opts.fallbackToDirect && !proxies.includes('DIRECT')) {\n                proxies.push('DIRECT');\n            }\n            for (const proxy of proxies) {\n                let agent = null;\n                let socket = null;\n                const [type, target] = proxy.split(/\\s+/);\n                debug('Attempting to use proxy: %o', proxy);\n                if (type === 'DIRECT') {\n                    // Direct connection to the destination endpoint\n                    socket = secureEndpoint ? tls_1.default.connect(opts) : net_1.default.connect(opts);\n                }\n                else if (type === 'SOCKS' || type === 'SOCKS5') {\n                    // Use a SOCKSv5h proxy\n                    agent = new socks_proxy_agent_1.SocksProxyAgent(`socks://${target}`);\n                }\n                else if (type === 'SOCKS4') {\n                    // Use a SOCKSv4a proxy\n                    agent = new socks_proxy_agent_1.SocksProxyAgent(`socks4a://${target}`);\n                }\n                else if (type === 'PROXY' ||\n                    type === 'HTTP' ||\n                    type === 'HTTPS') {\n                    // Use an HTTP or HTTPS proxy\n                    // http://dev.chromium.org/developers/design-documents/secure-web-proxy\n                    const proxyURL = `${type === 'HTTPS' ? 'https' : 'http'}://${target}`;\n                    const proxyOpts = Object.assign(Object.assign({}, this.opts), url_1.parse(proxyURL));\n                    if (secureEndpoint) {\n                        agent = new https_proxy_agent_1.HttpsProxyAgent(proxyOpts);\n                    }\n                    else {\n                        agent = new http_proxy_agent_1.HttpProxyAgent(proxyOpts);\n                    }\n                }\n                try {\n                    if (socket) {\n                        // \"DIRECT\" connection, wait for connection confirmation\n                        yield once_1.default(socket, 'connect');\n                        req.emit('proxy', { proxy, socket });\n                        return socket;\n                    }\n                    if (agent) {\n                        const s = yield agent.callback(req, opts);\n                        req.emit('proxy', { proxy, socket: s });\n                        return s;\n                    }\n                    throw new Error(`Could not determine proxy type for: ${proxy}`);\n                }\n                catch (err) {\n                    debug('Got error for proxy %o: %o', proxy, err);\n                    req.emit('proxy', { proxy, error: err });\n                }\n            }\n            throw new Error(`Failed to establish a socket connection to proxies: ${JSON.stringify(proxies)}`);\n        });\n    }\n}\nexports.default = PacProxyAgent;\n//# sourceMappingURL=agent.js.map"]}