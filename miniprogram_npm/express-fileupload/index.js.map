{"version":3,"sources":["index.js","processMultipart.js","uploadtimer.js","fileFactory.js","utilities.js","memHandler.js","tempFileHandler.js","processNested.js","isEligibleRequest.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA;ACFA,AHSA,ACHA,ACHA,AENA;ADIA,AHSA,ACHA,ACHA,AENA;ADIA,AHSA,ACHA,ACHA,AENA;ADIA,AHSA,AKfA,AJYA,ACHA,AENA;ADIA,AHSA,AKfA,AJYA,ACHA,AENA;ADIA,AHSA,AKfA,AJYA,ACHA,AENA;ADIA,AHSA,AKfA,AJYA,AKfA,AJYA,AENA;ADIA,AHSA,AKfA,AJYA,AKfA,AJYA,AENA;ADIA,AHSA,AKfA,AJYA,AKfA,AJYA,AENA;ADIA,AHSA,AKfA,AJYA,AMlBA,ADGA,AJYA,AENA;ADIA,AHSA,AKfA,AJYA,AMlBA,ADGA,AJYA,AENA;ADIA,AHSA,AKfA,AJYA,AMlBA,ADGA,AJYA,AENA;ADIA,AHSA,AQxBA,AHSA,AJYA,AMlBA,ADGA,AJYA,AENA;ADIA,AHSA,AQxBA,AHSA,AJYA,AMlBA,ADGA,AJYA,AENA;ADIA,AHSA,AQxBA,AHSA,AJYA,AMlBA,ADGA,AJYA,AENA;ADIA,AHSA,AQxBA,AHSA,AJYA,AMlBA,ADGA,AJYA,AENA;ADIA,AHSA,AQxBA,AHSA,AJYA,AMlBA,ADGA,AJYA,AENA;ADIA,AHSA,AQxBA,AHSA,AJYA,AMlBA,ADGA,AJYA,AENA;ADIA,AHSA,AQxBA,AHSA,AJYA,AMlBA,ADGA,AJYA,AENA;ADIA,AHSA,AQxBA,AHSA,AJYA,AMlBA,ADGA,AJYA,AENA;ADIA,AHSA,AQxBA,AHSA,AJYA,AMlBA,ADGA,AJYA,AENA;ADIA,AHSA,AQxBA,AHSA,AJYA,AMlBA,ADGA,AFMA;ADIA,AHSA,AQxBA,AHSA,AJYA,AMlBA,ADGA,AFMA;ADIA,AHSA,AQxBA,AHSA,AJYA,AMlBA,ADGA,AFMA;ADIA,AHSA,AQxBA,AHSA,AJYA,AMlBA,ADGA,AFMA;ADIA,AHSA,AQxBA,AHSA,AJYA,AMlBA,ADGA,AFMA;ADIA,AHSA,AQxBA,AHSA,AJYA,AMlBA,ADGA,AFMA;ADIA,AHSA,AQxBA,AHSA,AJYA,AMlBA,ADGA,AFMA;ADIA,AKfA,AHSA,AJYA,AMlBA,ADGA,AFMA;ADIA,AKfA,AHSA,AJYA,AMlBA,ADGA,AFMA;ADIA,AKfA,AHSA,AJYA,AMlBA,ADGA,AFMA;ADIA,AKfA,AHSA,AJYA,AMlBA,ADGA,AFMA;ADIA,AKfA,AHSA,AJYA,AMlBA,ADGA,AFMA;ADIA,AKfA,AHSA,AJYA,AMlBA,ADGA,AFMA;ADIA,AKfA,AHSA,AJYA,AMlBA,ADGA,AFMA;ADIA,AKfA,AHSA,AJYA,AMlBA,ADGA,AFMA;ADIA,AKfA,AHSA,AJYA,AMlBA,ADGA,AFMA;ADIA,AKfA,AHSA,AJYA,AMlBA,ADGA,AFMA;ADIA,AKfA,AHSA,AJYA,AMlBA,ADGA,AFMA;ADIA,AKfA,AHSA,AJYA,AMlBA,ADGA,AFMA;ADIA,AKfA,AHSA,AJYA,AMlBA,ADGA,AFMA;ADIA,AKfA,AHSA,AJYA,AMlBA,ADGA,AFMA;ADIA,AKfA,AHSA,AJYA,AMlBA,ADGA,AFMA;ADIA,AKfA,AHSA,AJYA,AMlBA,ADGA,AFMA;ADIA,AKfA,AHSA,AJYA,AMlBA,ADGA,AFMA;ADIA,AKfA,AHSA,AJYA,AKfA,AFMA;ADIA,AKfA,APqBA,AKfA,AFMA;ADIA,AFMA,AKfA,AFMA;ADIA,AFMA,AKfA,AFMA;ADIA,AFMA,AKfA,AFMA;ADIA,AFMA,AKfA,AFMA;ADIA,AFMA,AKfA,AFMA;ADIA,AFMA,AKfA,AFMA;ADIA,AFMA,AKfA,AFMA;ADIA,AFMA,AKfA,AFMA;ADIA,AFMA,AKfA,AFMA;ADIA,AFMA,AKfA,AFMA;ADIA,AFMA,AKfA,AFMA;ADIA,AFMA,AKfA,AFMA;ADIA,AFMA,AKfA,AFMA;ADIA,AFMA,AKfA,AFMA;ADIA,AFMA,AKfA,AFMA;ADIA,AFMA,AKfA,AFMA;AHUA,AKfA,AFMA;AHUA,AKfA,AFMA;AHUA,AKfA,AFMA;AHUA,AKfA,AFMA;AHUA,AKfA,AFMA;AHUA,AKfA,AFMA;AHUA,AKfA,AFMA;AHUA,AKfA,AFMA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nconst path = require('path');\nconst processMultipart = require('./processMultipart');\nconst isEligibleRequest = require('./isEligibleRequest');\nconst { buildOptions, debugLog } = require('./utilities');\nconst busboy = require('busboy'); // eslint-disable-line no-unused-vars\n\nconst DEFAULT_OPTIONS = {\n  debug: false,\n  uploadTimeout: 60000,\n  fileHandler: false,\n  uriDecodeFileNames: false,\n  safeFileNames: false,\n  preserveExtension: false,\n  abortOnLimit: false,\n  responseOnLimit: 'File size limit has been reached',\n  limitHandler: false,\n  createParentPath: false,\n  parseNested: false,\n  useTempFiles: false,\n  tempFileDir: path.join(process.cwd(), 'tmp')\n};\n\n/**\n * Expose the file upload middleware\n * @param {DEFAULT_OPTIONS & busboy.BusboyConfig} options - Middleware options.\n * @returns {Function} - express-fileupload middleware.\n */\nmodule.exports = (options) => {\n  const uploadOptions = buildOptions(DEFAULT_OPTIONS, options);\n  return (req, res, next) => {\n    if (!isEligibleRequest(req)) {\n      debugLog(uploadOptions, 'Request is not eligible for file upload!');\n      return next();\n    }\n    processMultipart(uploadOptions, req, res, next);\n  };\n};\n","const Busboy = require('busboy');\nconst UploadTimer = require('./uploadtimer');\nconst fileFactory = require('./fileFactory');\nconst memHandler = require('./memHandler');\nconst tempFileHandler = require('./tempFileHandler');\nconst processNested = require('./processNested');\nconst {\n  isFunc,\n  debugLog,\n  buildFields,\n  buildOptions,\n  parseFileName\n} = require('./utilities');\n\nconst waitFlushProperty = Symbol('wait flush property symbol');\n\n/**\n * Processes multipart request\n * Builds a req.body object for fields\n * Builds a req.files object for files\n * @param  {Object}   options expressFileupload and Busboy options\n * @param  {Object}   req     Express request object\n * @param  {Object}   res     Express response object\n * @param  {Function} next    Express next method\n * @return {void}\n */\nmodule.exports = (options, req, res, next) => {\n  req.files = null;\n\n  // Build busboy options and init busboy instance.\n  const busboyOptions = buildOptions(options, { headers: req.headers });\n  const busboy = Busboy(busboyOptions);\n\n  // Close connection with specified reason and http code, default: 400 Bad Request.\n  const closeConnection = (code, reason) => {\n    req.unpipe(busboy);\n    res.writeHead(code || 400, { Connection: 'close' });\n    res.end(reason || 'Bad Request');\n  };\n\n  // Express proxies sometimes attach multipart data to a buffer\n  if (req.body instanceof Buffer) {\n    req.body = Object.create(null);\n  }\n  // Build multipart req.body fields\n  busboy.on('field', (field, val) => req.body = buildFields(req.body, field, val));\n\n  // Build req.files fields\n  busboy.on('file', (field, file, info) => {\n    // Parse file name(cutting huge names, decoding, etc..).\n    const {filename:name, encoding, mimeType: mime} = info;\n    const filename = parseFileName(options, name);\n    // Define methods and handlers for upload process.\n    const {\n      dataHandler,\n      getFilePath,\n      getFileSize,\n      getHash,\n      complete,\n      cleanup,\n      getWritePromise\n    } = options.useTempFiles\n      ? tempFileHandler(options, field, filename) // Upload into temporary file.\n      : memHandler(options, field, filename);     // Upload into RAM.\n\n    const writePromise = options.useTempFiles\n      ? getWritePromise().catch(err => {\n        req.unpipe(busboy);\n        req.resume();\n        cleanup();\n        next(err);\n      }) : getWritePromise();\n\n    // Define upload timer.\n    const uploadTimer = new UploadTimer(options.uploadTimeout, () => {\n      file.removeAllListeners('data');\n      file.resume();\n      // After destroy an error event will be emitted and file clean up will be done.\n      file.destroy(new Error(`Upload timeout ${field}->${filename}, bytes:${getFileSize()}`));\n    });\n\n    file.on('limit', () => {\n      debugLog(options, `Size limit reached for ${field}->${filename}, bytes:${getFileSize()}`);\n      // Reset upload timer in case of file limit reached.\n      uploadTimer.clear();\n      // Run a user defined limit handler if it has been set.\n      if (isFunc(options.limitHandler)) return options.limitHandler(req, res, next);\n      // Close connection with 413 code and do cleanup if abortOnLimit set(default: false).\n      if (options.abortOnLimit) {\n        debugLog(options, `Aborting upload because of size limit ${field}->${filename}.`);\n        !isFunc(options.limitHandler) ? closeConnection(413, options.responseOnLimit) : '';\n        cleanup();\n      }\n    });\n\n    file.on('data', (data) => {\n      uploadTimer.set(); // Refresh upload timer each time new data chunk came.\n      dataHandler(data); // Handle new piece of data.\n    });\n\n    file.on('end', () => {\n      const size = getFileSize();\n      // Debug logging for file upload ending.\n      debugLog(options, `Upload finished ${field}->${filename}, bytes:${size}`);\n      // Reset upload timer in case of end event.\n      uploadTimer.clear();\n      // See https://github.com/richardgirges/express-fileupload/issues/191\n      // Do not add file instance to the req.files if original name and size are empty.\n      // Empty name and zero size indicates empty file field in the posted form.\n      if (!name && size === 0) {\n        if (options.useTempFiles) {\n          cleanup();\n          debugLog(options, `Removing the empty file ${field}->${filename}`);\n        }\n        return debugLog(options, `Don't add file instance if original name and size are empty`);\n      }\n      req.files = buildFields(req.files, field, fileFactory({\n        buffer: complete(),\n        name: filename,\n        tempFilePath: getFilePath(),\n        hash: getHash(),\n        size,\n        encoding,\n        truncated: file.truncated,\n        mimetype: mime\n      }, options));\n\n      if (!req[waitFlushProperty]) {\n        req[waitFlushProperty] = [];\n      }\n      req[waitFlushProperty].push(writePromise);\n    });\n\n    file.on('error', (err) => {\n      uploadTimer.clear(); // Reset upload timer in case of errors.\n      debugLog(options, err);\n      cleanup();\n      next();\n    });\n\n    // Debug logging for a new file upload.\n    debugLog(options, `New upload started ${field}->${filename}, bytes:${getFileSize()}`);\n    // Set new upload timeout for a new file.\n    uploadTimer.set();\n  });\n\n  busboy.on('finish', () => {\n    debugLog(options, `Busboy finished parsing request.`);\n    if (options.parseNested) {\n      req.body = processNested(req.body);\n      req.files = processNested(req.files);\n    }\n\n    if (!req[waitFlushProperty]) return next();\n    Promise.all(req[waitFlushProperty])\n      .then(() => {\n        delete req[waitFlushProperty];\n        next();\n      });\n  });\n\n  busboy.on('error', (err) => {\n    debugLog(options, `Busboy error`);\n    next(err);\n  });\n\n  req.pipe(busboy);\n};\n","class UploadTimer {\n  /**\n   * @constructor\n   * @param {number} timeout - timer timeout in msecs. \n   * @param {Function} callback - callback to run when timeout reached.\n   */\n  constructor(timeout = 0, callback = () => {}) {\n    this.timeout = timeout;\n    this.callback = callback;\n    this.timer = null;\n  }\n\n  clear() {\n    clearTimeout(this.timer);\n  }\n\n  set() {\n    // Do not start a timer if zero timeout or it hasn't been set. \n    if (!this.timeout) return false;\n    this.clear();\n    this.timer = setTimeout(this.callback, this.timeout);\n    return true;\n  }\n}\n\nmodule.exports = UploadTimer;\n","\n\nconst {\n  isFunc,\n  debugLog,\n  moveFile,\n  promiseCallback,\n  checkAndMakeDir,\n  saveBufferToFile\n} = require('./utilities');\n\n/**\n * Returns Local function that moves the file to a different location on the filesystem\n * which takes two function arguments to make it compatible w/ Promise or Callback APIs\n * @param {String} filePath - destination file path.\n * @param {Object} options - file factory options.\n * @param {Object} fileUploadOptions - middleware options.\n * @returns {Function}\n */\nconst moveFromTemp = (filePath, options, fileUploadOptions) => (resolve, reject) => {\n  debugLog(fileUploadOptions, `Moving temporary file ${options.tempFilePath} to ${filePath}`);\n  moveFile(options.tempFilePath, filePath, promiseCallback(resolve, reject));\n};\n\n/**\n * Returns Local function that moves the file from buffer to a different location on the filesystem\n * which takes two function arguments to make it compatible w/ Promise or Callback APIs\n * @param {String} filePath - destination file path.\n * @param {Object} options - file factory options.\n * @param {Object} fileUploadOptions - middleware options.\n * @returns {Function}\n */\nconst moveFromBuffer = (filePath, options, fileUploadOptions) => (resolve, reject) => {\n  debugLog(fileUploadOptions, `Moving uploaded buffer to ${filePath}`);\n  saveBufferToFile(options.buffer, filePath, promiseCallback(resolve, reject));\n};\n\nmodule.exports = (options, fileUploadOptions = {}) => {\n  // see: https://github.com/richardgirges/express-fileupload/issues/14\n  // firefox uploads empty file in case of cache miss when f5ing page.\n  // resulting in unexpected behavior. if there is no file data, the file is invalid.\n  // if (!fileUploadOptions.useTempFiles && !options.buffer.length) return;\n  \n  // Create and return file object.\n  return {\n    name: options.name,\n    data: options.buffer,\n    size: options.size,\n    encoding: options.encoding,\n    tempFilePath: options.tempFilePath,\n    truncated: options.truncated,\n    mimetype: options.mimetype,\n    md5: options.hash,\n    mv: (filePath, callback) => {\n      // Define a propper move function.\n      const moveFunc = fileUploadOptions.useTempFiles\n        ? moveFromTemp(filePath, options, fileUploadOptions)\n        : moveFromBuffer(filePath, options, fileUploadOptions);\n      // Create a folder for a file.\n      checkAndMakeDir(fileUploadOptions, filePath);\n      // If callback is passed in, use the callback API, otherwise return a promise.\n      return isFunc(callback) ? moveFunc(callback) : new Promise(moveFunc);\n    }\n  };\n};\n","\r\n\r\nconst fs = require('fs');\r\nconst path = require('path');\r\nconst { Readable } = require('stream');\r\n\r\n// Parameters for safe file name parsing.\r\nconst SAFE_FILE_NAME_REGEX = /[^\\w-]/g;\r\nconst MAX_EXTENSION_LENGTH = 3;\r\n\r\n// Parameters to generate unique temporary file names:\r\nconst TEMP_COUNTER_MAX = 65536;\r\nconst TEMP_PREFIX = 'tmp';\r\nlet tempCounter = 0;\r\n\r\n/**\r\n * Logs message to console if debug option set to true.\r\n * @param {Object} options - options object.\r\n * @param {string} msg - message to log.\r\n * @returns {boolean} - false if debug is off.\r\n */\r\nconst debugLog = (options, msg) => {\r\n  const opts = options || {};\r\n  if (!opts.debug) return false;\r\n  console.log(`Express-file-upload: ${msg}`); // eslint-disable-line\r\n  return true;\r\n};\r\n\r\n/**\r\n * Generates unique temporary file name. e.g. tmp-5000-156788789789.\r\n * @param {string} prefix - a prefix for generated unique file name.\r\n * @returns {string}\r\n */\r\nconst getTempFilename = (prefix = TEMP_PREFIX) => {\r\n  tempCounter = tempCounter >= TEMP_COUNTER_MAX ? 1 : tempCounter + 1;\r\n  return `${prefix}-${tempCounter}-${Date.now()}`;\r\n};\r\n\r\n/**\r\n * isFunc: Checks if argument is a function.\r\n * @returns {boolean} - Returns true if argument is a function.\r\n */\r\nconst isFunc = func => func && func.constructor && func.call && func.apply ? true: false;\r\n\r\n/**\r\n * Set errorFunc to the same value as successFunc for callback mode.\r\n * @returns {Function}\r\n */\r\nconst errorFunc = (resolve, reject) => isFunc(reject) ? reject : resolve;\r\n\r\n/**\r\n * Return a callback function for promise resole/reject args.\r\n * Ensures that callback is called only once.\r\n * @returns {Function}\r\n */\r\nconst promiseCallback = (resolve, reject) => {\r\n  let hasFired = false;\r\n  return (err) => {\r\n    if (hasFired) {\r\n      return;\r\n    }\r\n\r\n    hasFired = true;\r\n    return err ? errorFunc(resolve, reject)(err) : resolve();\r\n  };\r\n};\r\n\r\n/**\r\n * Builds instance options from arguments objects(can't be arrow function).\r\n * @returns {Object} - result options.\r\n */\r\nconst buildOptions = function() {\r\n  const result = {};\r\n  [...arguments].forEach(options => {\r\n    if (!options || typeof options !== 'object') return;\r\n    Object.keys(options).forEach(i => result[i] = options[i]);\r\n  });\r\n  return result;\r\n};\r\n\r\n// The default prototypes for both objects and arrays.\r\n// Used by isSafeFromPollution\r\nconst OBJECT_PROTOTYPE_KEYS = Object.getOwnPropertyNames(Object.prototype);\r\nconst ARRAY_PROTOTYPE_KEYS = Object.getOwnPropertyNames(Array.prototype);\r\n\r\n/**\r\n * Determines whether a key insertion into an object could result in a prototype pollution\r\n * @param {Object} base - The object whose insertion we are checking\r\n * @param {string} key - The key that will be inserted\r\n */\r\nconst isSafeFromPollution = (base, key) => {\r\n  // We perform an instanceof check instead of Array.isArray as the former is more\r\n  // permissive for cases in which the object as an Array prototype but was not constructed\r\n  // via an Array constructor or literal.\r\n  const TOUCHES_ARRAY_PROTOTYPE = (base instanceof Array) && ARRAY_PROTOTYPE_KEYS.includes(key);\r\n  const TOUCHES_OBJECT_PROTOTYPE = OBJECT_PROTOTYPE_KEYS.includes(key);\r\n\r\n  return !TOUCHES_ARRAY_PROTOTYPE && !TOUCHES_OBJECT_PROTOTYPE;\r\n};\r\n\r\n/**\r\n * Builds request fields (using to build req.body and req.files)\r\n * @param {Object} instance - request object.\r\n * @param {string} field - field name.\r\n * @param {any} value - field value.\r\n * @returns {Object}\r\n */\r\nconst buildFields = (instance, field, value) => {\r\n  // Do nothing if value is not set.\r\n  if (value === null || value === undefined) return instance;\r\n  instance = instance || Object.create(null);\r\n\r\n  if (!isSafeFromPollution(instance, field)) {\r\n    return instance;\r\n  }\r\n  // Non-array fields\r\n  if (!instance[field]) {\r\n    instance[field] = value;\r\n    return instance;\r\n  }\r\n  // Array fields\r\n  if (instance[field] instanceof Array) {\r\n    instance[field].push(value);\r\n  } else {\r\n    instance[field] = [instance[field], value];\r\n  }\r\n  return instance;\r\n};\r\n\r\n/**\r\n * Creates a folder for file specified in the path variable\r\n * @param {Object} fileUploadOptions\r\n * @param {string} filePath\r\n * @returns {boolean}\r\n */\r\nconst checkAndMakeDir = (fileUploadOptions, filePath) => {\r\n  // Check upload options were set.\r\n  if (!fileUploadOptions) return false;\r\n  if (!fileUploadOptions.createParentPath) return false;\r\n  // Check whether folder for the file exists.\r\n  if (!filePath) return false;\r\n  const parentPath = path.dirname(filePath);\r\n  // Create folder if it doesn't exist.\r\n  if (!fs.existsSync(parentPath)) fs.mkdirSync(parentPath, { recursive: true });\r\n  // Checks folder again and return a results.\r\n  return fs.existsSync(parentPath);\r\n};\r\n\r\n/**\r\n * Deletes a file.\r\n * @param {string} file - Path to the file to delete.\r\n * @param {Function} callback\r\n */\r\nconst deleteFile = (file, callback) => fs.unlink(file, callback);\r\n\r\n/**\r\n * Copy file via streams\r\n * @param {string} src - Path to the source file\r\n * @param {string} dst - Path to the destination file.\r\n */\r\nconst copyFile = (src, dst, callback) => {\r\n  // cbCalled flag and runCb helps to run cb only once.\r\n  let cbCalled = false;\r\n  let runCb = (err) => {\r\n    if (cbCalled) return;\r\n    cbCalled = true;\r\n    callback(err);\r\n  };\r\n  // Create read stream\r\n  let readable = fs.createReadStream(src);\r\n  readable.on('error', runCb);\r\n  // Create write stream\r\n  let writable = fs.createWriteStream(dst);\r\n  writable.on('error', (err)=>{\r\n    readable.destroy();\r\n    runCb(err);\r\n  });\r\n  writable.on('close', () => runCb());\r\n  // Copy file via piping streams.\r\n  readable.pipe(writable);\r\n};\r\n\r\n/**\r\n * moveFile: moves the file from src to dst.\r\n * Firstly trying to rename the file if no luck copying it to dst and then deleteing src.\r\n * @param {string} src - Path to the source file\r\n * @param {string} dst - Path to the destination file.\r\n * @param {Function} callback - A callback function.\r\n */\r\nconst moveFile = (src, dst, callback) => fs.rename(src, dst, err => (err\r\n  ? copyFile(src, dst, err => err ? callback(err) : deleteFile(src, callback))\r\n  : callback()\r\n));\r\n\r\n/**\r\n * Save buffer data to a file.\r\n * @param {Buffer} buffer - buffer to save to a file.\r\n * @param {string} filePath - path to a file.\r\n */\r\nconst saveBufferToFile = (buffer, filePath, callback) => {\r\n  if (!Buffer.isBuffer(buffer)) {\r\n    return callback(new Error('buffer variable should be type of Buffer!'));\r\n  }\r\n  // Setup readable stream from buffer.\r\n  let streamData = buffer;\r\n  let readStream = Readable();\r\n  readStream._read = () => {\r\n    readStream.push(streamData);\r\n    streamData = null;\r\n  };\r\n  // Setup file system writable stream.\r\n  let fstream = fs.createWriteStream(filePath);\r\n  // console.log(\"Calling saveBuffer\");\r\n  fstream.on('error', err => {\r\n    // console.log(\"err cb\")\r\n    callback(err);\r\n  });\r\n  fstream.on('close', () => {\r\n    // console.log(\"close cb\");\r\n    callback();\r\n  });\r\n  // Copy file via piping streams.\r\n  readStream.pipe(fstream);\r\n};\r\n\r\n/**\r\n * Decodes uriEncoded file names.\r\n * @param fileName {String} - file name to decode.\r\n * @returns {String}\r\n */\r\nconst uriDecodeFileName = (opts, fileName) => {\r\n  return opts.uriDecodeFileNames ? decodeURIComponent(fileName) : fileName;\r\n};\r\n\r\n/**\r\n * Parses filename and extension and returns object {name, extension}.\r\n * @param {boolean|integer} preserveExtension - true/false or number of characters for extension.\r\n * @param {string} fileName - file name to parse.\r\n * @returns {Object} - { name, extension }.\r\n */\r\nconst parseFileNameExtension = (preserveExtension, fileName) => {\r\n  const preserveExtensionLength = parseInt(preserveExtension);\r\n  const result = {name: fileName, extension: ''};\r\n  if (!preserveExtension && preserveExtensionLength !== 0) return result;\r\n  // Define maximum extension length\r\n  const maxExtLength = isNaN(preserveExtensionLength)\r\n    ? MAX_EXTENSION_LENGTH\r\n    : Math.abs(preserveExtensionLength);\r\n\r\n  const nameParts = fileName.split('.');\r\n  if (nameParts.length < 2) return result;\r\n\r\n  let extension = nameParts.pop();\r\n  if (\r\n    extension.length > maxExtLength &&\r\n    maxExtLength > 0\r\n  ) {\r\n    nameParts[nameParts.length - 1] +=\r\n      '.' +\r\n      extension.substr(0, extension.length - maxExtLength);\r\n    extension = extension.substr(-maxExtLength);\r\n  }\r\n\r\n  result.extension = maxExtLength ? extension : '';\r\n  result.name = nameParts.join('.');\r\n  return result;\r\n};\r\n\r\n/**\r\n * Parse file name and extension.\r\n * @param {Object} opts - middleware options.\r\n * @param {string} fileName - Uploaded file name.\r\n * @returns {string}\r\n */\r\nconst parseFileName = (opts, fileName) => {\r\n  // Check fileName argument\r\n  if (!fileName || typeof fileName !== 'string') return getTempFilename();\r\n  // Cut off file name if it's lenght more then 255.\r\n  let parsedName = fileName.length <= 255 ? fileName : fileName.substr(0, 255);\r\n  // Decode file name if uriDecodeFileNames option set true.\r\n  parsedName = uriDecodeFileName(opts, parsedName);\r\n  // Stop parsing file name if safeFileNames options hasn't been set.\r\n  if (!opts.safeFileNames) return parsedName;\r\n  // Set regular expression for the file name.\r\n  const nameRegex = typeof opts.safeFileNames === 'object' && opts.safeFileNames instanceof RegExp\r\n    ? opts.safeFileNames\r\n    : SAFE_FILE_NAME_REGEX;\r\n  // Parse file name extension.\r\n  let {name, extension} = parseFileNameExtension(opts.preserveExtension, parsedName);\r\n  if (extension.length) extension = '.' + extension.replace(nameRegex, '');\r\n\r\n  return name.replace(nameRegex, '').concat(extension);\r\n};\r\n\r\nmodule.exports = {\r\n  isFunc,\r\n  debugLog,\r\n  copyFile, // For testing purpose.\r\n  moveFile,\r\n  errorFunc,\r\n  deleteFile, // For testing purpose.\r\n  buildFields,\r\n  buildOptions,\r\n  parseFileName,\r\n  getTempFilename,\r\n  promiseCallback,\r\n  checkAndMakeDir,\r\n  saveBufferToFile,\r\n  uriDecodeFileName,\r\n  isSafeFromPollution\r\n};\r\n","const crypto = require('crypto');\nconst { debugLog } = require('./utilities');\n\n/**\n * memHandler - In memory upload handler\n * @param {Object} options\n * @param {String} fieldname\n * @param {String} filename\n * @returns {Object}\n */\nmodule.exports = (options, fieldname, filename) => {\n  const buffers = [];\n  const hash = crypto.createHash('md5');\n  let fileSize = 0;\n  let completed = false;\n\n  const getBuffer = () => Buffer.concat(buffers, fileSize);\n\n  return {\n    dataHandler: (data) => {\n      if (completed === true) {\n        debugLog(options, `Error: got ${fieldname}->${filename} data chunk for completed upload!`);\n        return;\n      }\n      buffers.push(data);\n      hash.update(data);\n      fileSize += data.length;\n      debugLog(options, `Uploading ${fieldname}->${filename}, bytes:${fileSize}...`);\n    },\n    getBuffer: getBuffer,\n    getFilePath: () => '',\n    getFileSize: () => fileSize,\n    getHash: () => hash.digest('hex'),\n    complete: () => {\n      debugLog(options, `Upload ${fieldname}->${filename} completed, bytes:${fileSize}.`);\n      completed = true;\n      return getBuffer();\n    },\n    cleanup: () => { completed = true; },\n    getWritePromise: () => Promise.resolve()\n  };\n};\n","const fs = require('fs');\nconst path = require('path');\nconst crypto = require('crypto');\nconst {\n  debugLog,\n  checkAndMakeDir,\n  getTempFilename,\n  deleteFile\n} = require('./utilities');\n\nmodule.exports = (options, fieldname, filename) => {\n  const dir = path.normalize(options.tempFileDir);\n  const tempFilePath = path.join(dir, getTempFilename());\n  checkAndMakeDir({ createParentPath: true }, tempFilePath);\n\n  debugLog(options, `Temporary file path is ${tempFilePath}`);\n \n  const hash = crypto.createHash('md5');\n  let fileSize = 0;\n  let completed = false;\n\n  debugLog(options, `Opening write stream for ${fieldname}->${filename}...`);\n  const writeStream = fs.createWriteStream(tempFilePath);\n  const writePromise = new Promise((resolve, reject) => {\n    writeStream.on('finish', () => resolve());\n    writeStream.on('error', (err) => {\n      debugLog(options, `Error write temp file: ${err}`);\n      reject(err);\n    });\n  });\n\n  return {\n    dataHandler: (data) => {\n      if (completed === true) {\n        debugLog(options, `Error: got ${fieldname}->${filename} data chunk for completed upload!`);\n        return;\n      }\n      writeStream.write(data);\n      hash.update(data);\n      fileSize += data.length;\n      debugLog(options, `Uploading ${fieldname}->${filename}, bytes:${fileSize}...`);\n    },\n    getFilePath: () => tempFilePath,\n    getFileSize: () => fileSize,\n    getHash: () => hash.digest('hex'),\n    complete: () => {\n      completed = true;\n      debugLog(options, `Upload ${fieldname}->${filename} completed, bytes:${fileSize}.`);\n      if (writeStream !== false) writeStream.end();\n      // Return empty buff since data was uploaded into a temp file.\n      return Buffer.concat([]);\n    },\n    cleanup: () => {\n      completed = true;\n      debugLog(options, `Cleaning up temporary file ${tempFilePath}...`);\n      writeStream.end();\n      deleteFile(tempFilePath, err => (err \n        ? debugLog(options, `Cleaning up temporary file ${tempFilePath} failed: ${err}`)\n        : debugLog(options, `Cleaning up temporary file ${tempFilePath} done.`)\n      ));\n    },\n    getWritePromise: () => writePromise\n  };\n};\n","const { isSafeFromPollution } = require(\"./utilities\");\n\nmodule.exports = function(data){\n  if (!data || data.length < 1) return Object.create(null);\n\n  let d = Object.create(null),\n    keys = Object.keys(data);\n\n  for (let i = 0; i < keys.length; i++) {\n    let key = keys[i],\n      value = data[key],\n      current = d,\n      keyParts = key\n        .replace(new RegExp(/\\[/g), '.')\n        .replace(new RegExp(/\\]/g), '')\n        .split('.');\n\n    for (let index = 0; index < keyParts.length; index++){\n      let k = keyParts[index];\n\n      // Ensure we don't allow prototype pollution\n      if (!isSafeFromPollution(current, k)) {\n        continue;\n      }\n\n      if (index >= keyParts.length - 1){\n        current[k] = value;\n      } else {\n        if (!current[k]) current[k] = !isNaN(keyParts[index + 1]) ? [] : Object.create(null);\n        current = current[k];\n      }\n    }\n  }\n  return d;\n};\n","const ACCEPTABLE_CONTENT_TYPE = /^(multipart\\/.+);(.*)$/i;\nconst UNACCEPTABLE_METHODS = ['GET', 'HEAD'];\n\n/**\n * Ensures the request contains a content body\n * @param  {Object}  req Express req object\n * @returns {Boolean}\n */\nconst hasBody = (req) => {\n  return ('transfer-encoding' in req.headers) ||\n    ('content-length' in req.headers && req.headers['content-length'] !== '0');\n};\n\n/**\n * Ensures the request is not using a non-compliant multipart method\n * such as GET or HEAD\n * @param  {Object}  req Express req object\n * @returns {Boolean}\n */\nconst hasAcceptableMethod = req => !UNACCEPTABLE_METHODS.includes(req.method);\n\n/**\n * Ensures that only multipart requests are processed by express-fileupload\n * @param  {Object}  req Express req object\n * @returns {Boolean}\n */\nconst hasAcceptableContentType = req => ACCEPTABLE_CONTENT_TYPE.test(req.headers['content-type']);\n\n/**\n * Ensures that the request in question is eligible for file uploads\n * @param {Object} req Express req object\n * @returns {Boolean}\n */\nmodule.exports = req => hasBody(req) && hasAcceptableMethod(req) && hasAcceptableContentType(req);\n"]}