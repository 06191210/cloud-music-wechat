{"version":3,"sources":["main.js","util/index.js","util/request.js","util/crypto.js","util/config.json","server.js","package.json","util/apicache.js","util/memory-cache.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ADIA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,ACHA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AGTA,AFMA,ACHA;AFOA,AIZA,ADGA,AFMA,ACHA;AFOA,AIZA,ADGA,AFMA,ACHA;AFOA,AIZA,ADGA,AFMA,ACHA;AFOA,AKfA,ADGA,ADGA,AFMA,ACHA;AFOA,AKfA,ADGA,ADGA,AFMA,ACHA;AFOA,AKfA,ADGA,ADGA,AFMA,ACHA;AFOA,AMlBA,ADGA,ADGA,ADGA,AFMA,ACHA;AFOA,AMlBA,ADGA,ADGA,ADGA,AFMA,ACHA;AFOA,AMlBA,ADGA,ADGA,ADGA,AFMA,ACHA;AFOA,AMlBA,ADGA,AENA,AHSA,ADGA,AFMA,ACHA;AFOA,AMlBA,ADGA,AENA,AHSA,ADGA,AFMA,ACHA;AFOA,AMlBA,ADGA,AENA,AHSA,ADGA,AFMA,ACHA;AFOA,AMlBA,ADGA,AENA,AHSA,ADGA,AFMA,AOrBA,ANkBA;AFOA,AMlBA,ADGA,AENA,AJYA,AFMA,AOrBA,ANkBA;AFOA,AMlBA,ADGA,AENA,AJYA,AFMA,AOrBA,ANkBA;AFOA,AMlBA,ADGA,AENA,AJYA,AFMA,AOrBA,ANkBA;AFOA,AMlBA,ADGA,AENA,AJYA,AKfA,ANkBA;AFOA,AMlBA,ADGA,AENA,AJYA,AKfA,ANkBA;AFOA,AMlBA,ADGA,AENA,AJYA,AKfA,ANkBA;AFOA,AMlBA,ADGA,AENA,AJYA,AKfA,ANkBA;AFOA,AMlBA,ADGA,AENA,AJYA,AKfA,ANkBA;AFOA,AMlBA,ADGA,AENA,AJYA,AKfA,ANkBA;AFOA,AMlBA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,AJYA,AKfA,ANkBA;AIXA,ADGA,AENA,ACHA,ANkBA;AIXA,ADGA,AENA,ACHA,ANkBA;AIXA,ADGA,AENA,ACHA,ANkBA;AIXA,ADGA,AENA,ACHA,ANkBA;AIXA,ADGA,AENA,ACHA,ANkBA;AIXA,ADGA,AENA,ACHA,ANkBA;AIXA,ADGA,AENA,ACHA,ANkBA;AIXA,ADGA,AENA,ACHA,ANkBA;AIXA,ADGA,AENA,ACHA,ANkBA;AIXA,ADGA,AENA,ACHA,ANkBA;AIXA,ADGA,AENA,ACHA,ANkBA;AIXA,ADGA,AENA,ALeA;AIXA,ADGA,AENA,ALeA;AIXA,ADGA,AENA,ALeA;AIXA,ADGA,AENA,ALeA;AIXA,ADGA,AENA,ALeA;AIXA,ADGA,AENA,ALeA;AIXA,ADGA,AENA,ALeA;AIXA,ADGA,AENA,ALeA;AIXA,ADGA,AENA,ALeA;AIXA,ADGA,AENA,ALeA;AIXA,ADGA,AENA,ALeA;AIXA,ADGA,AENA,ALeA;AIXA,ADGA,AENA,ALeA;AIXA,ADGA,AENA,ALeA;AIXA,ADGA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA,ALeA;AGRA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AFOA,AENA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["const fs = require('fs')\nconst path = require('path')\nconst { cookieToJson } = require('./util')\nconst request = require('./util/request')\n\n/** @type {Record<string, any>} */\nlet obj = {}\nfs.readdirSync(path.join(__dirname, 'module'))\n  .reverse()\n  .forEach((file) => {\n    if (!file.endsWith('.js')) return\n    let fileModule = require(path.join(__dirname, 'module', file))\n    let fn = file.split('.').shift() || ''\n    obj[fn] = function (data = {}) {\n      if (typeof data.cookie === 'string') {\n        data.cookie = cookieToJson(data.cookie)\n      }\n      return fileModule(\n        {\n          ...data,\n          cookie: data.cookie ? data.cookie : {},\n        },\n        request,\n      )\n    }\n  })\n\n/**\n * @type {Record<string, any> & import(\"./server\")}\n */\nmodule.exports = {\n  ...require('./server'),\n  ...obj,\n}\n","module.exports = {\n  toBoolean(val) {\n    if (typeof val === 'boolean') return val\n    if (val === '') return val\n    return val === 'true' || val == '1'\n  },\n  cookieToJson(cookie) {\n    if (!cookie) return {}\n    let cookieArr = cookie.split(';')\n    let obj = {}\n    cookieArr.forEach((i) => {\n      let arr = i.split('=')\n      obj[arr[0]] = arr[1]\n    })\n    return obj\n  },\n  getRandom(num) {\n    var random = Math.floor(\n      (Math.random() + Math.floor(Math.random() * 9 + 1)) *\n        Math.pow(10, num - 1),\n    )\n    return random\n  },\n}\n","const encrypt = require('./crypto')\nconst axios = require('axios')\nconst PacProxyAgent = require('pac-proxy-agent')\nconst http = require('http')\nconst https = require('https')\nconst tunnel = require('tunnel')\nconst { URLSearchParams, URL } = require('url')\nconst config = require('../util/config.json')\n// request.debug = true // 开启可看到更详细信息\n\nconst chooseUserAgent = (ua = false) => {\n  const userAgentList = {\n    mobile: [\n      // iOS 13.5.1 14.0 beta with safari\n      'Mozilla/5.0 (iPhone; CPU iPhone OS 13_5_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1.1 Mobile/15E148 Safari/604.1',\n      'Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Mobile/15E148 Safari/604.',\n      // iOS with qq micromsg\n      'Mozilla/5.0 (iPhone; CPU iPhone OS 13_5_1 like Mac OS X) AppleWebKit/602.1.50 (KHTML like Gecko) Mobile/14A456 QQ/6.5.7.408 V1_IPH_SQ_6.5.7_1_APP_A Pixel/750 Core/UIWebView NetType/4G Mem/103',\n      'Mozilla/5.0 (iPhone; CPU iPhone OS 13_5_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/15E148 MicroMessenger/7.0.15(0x17000f27) NetType/WIFI Language/zh',\n      // Android -> Huawei Xiaomi\n      'Mozilla/5.0 (Linux; Android 9; PCT-AL10) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.64 HuaweiBrowser/10.0.3.311 Mobile Safari/537.36',\n      'Mozilla/5.0 (Linux; U; Android 9; zh-cn; Redmi Note 8 Build/PKQ1.190616.001) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/71.0.3578.141 Mobile Safari/537.36 XiaoMi/MiuiBrowser/12.5.22',\n      // Android + qq micromsg\n      'Mozilla/5.0 (Linux; Android 10; YAL-AL00 Build/HUAWEIYAL-AL00; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/78.0.3904.62 XWEB/2581 MMWEBSDK/200801 Mobile Safari/537.36 MMWEBID/3027 MicroMessenger/7.0.18.1740(0x27001235) Process/toolsmp WeChat/arm64 NetType/WIFI Language/zh_CN ABI/arm64',\n      'Mozilla/5.0 (Linux; U; Android 8.1.0; zh-cn; BKK-AL10 Build/HONORBKK-AL10) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/66.0.3359.126 MQQBrowser/10.6 Mobile Safari/537.36',\n    ],\n    pc: [\n      // macOS 10.15.6  Firefox / Chrome / Safari\n      'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:80.0) Gecko/20100101 Firefox/80.0',\n      'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.30 Safari/537.36',\n      'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1.2 Safari/605.1.15',\n      // Windows 10 Firefox / Chrome / Edge\n      'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:80.0) Gecko/20100101 Firefox/80.0',\n      'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/86.0.4240.30 Safari/537.36',\n      'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/42.0.2311.135 Safari/537.36 Edge/13.10586',\n      // Linux 就算了\n    ],\n  }\n  let realUserAgentList =\n    userAgentList[ua] || userAgentList.mobile.concat(userAgentList.pc)\n  return ['mobile', 'pc', false].indexOf(ua) > -1\n    ? realUserAgentList[Math.floor(Math.random() * realUserAgentList.length)]\n    : ua\n}\nconst createRequest = (method, url, data = {}, options) => {\n  return new Promise((resolve, reject) => {\n    let headers = { 'User-Agent': chooseUserAgent(options.ua) }\n    if (method.toUpperCase() === 'POST')\n      headers['Content-Type'] = 'application/x-www-form-urlencoded'\n    if (url.includes('music.163.com'))\n      headers['Referer'] = 'https://music.163.com'\n    let ip = options.realIP || options.ip || ''\n    // console.log(ip)\n    if (ip) {\n      headers['X-Real-IP'] = ip\n      headers['X-Forwarded-For'] = ip\n    }\n    // headers['X-Real-IP'] = '118.88.88.88'\n    if (typeof options.cookie === 'object') {\n      options.cookie = {\n        ...options.cookie,\n        __remember_me: true,\n        NMTID: 'xxx',\n      }\n      if (!options.cookie.MUSIC_U) {\n        // 游客\n        if (!options.cookie.MUSIC_A) {\n          options.cookie.MUSIC_A = config.anonymous_token\n        }\n      }\n      headers['Cookie'] = Object.keys(options.cookie)\n        .map(\n          (key) =>\n            encodeURIComponent(key) +\n            '=' +\n            encodeURIComponent(options.cookie[key]),\n        )\n        .join('; ')\n    } else if (options.cookie) {\n      headers['Cookie'] = options.cookie\n    } else {\n      headers['Cookie'] = '__remember_me=true; NMTID=xxx'\n    }\n    // console.log(options.cookie, headers['Cookie'])\n    if (options.crypto === 'weapi') {\n      let csrfToken = (headers['Cookie'] || '').match(/_csrf=([^(;|$)]+)/)\n      data.csrf_token = csrfToken ? csrfToken[1] : ''\n      data = encrypt.weapi(data)\n      url = url.replace(/\\w*api/, 'weapi')\n    } else if (options.crypto === 'linuxapi') {\n      data = encrypt.linuxapi({\n        method: method,\n        url: url.replace(/\\w*api/, 'api'),\n        params: data,\n      })\n      headers['User-Agent'] =\n        'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36'\n      url = 'https://music.163.com/api/linux/forward'\n    } else if (options.crypto === 'eapi') {\n      const cookie = options.cookie || {}\n      const csrfToken = cookie['__csrf'] || ''\n      const header = {\n        osver: cookie.osver, //系统版本\n        deviceId: cookie.deviceId, //encrypt.base64.encode(imei + '\\t02:00:00:00:00:00\\t5106025eb79a5247\\t70ffbaac7')\n        appver: cookie.appver || '8.7.01', // app版本\n        versioncode: cookie.versioncode || '140', //版本号\n        mobilename: cookie.mobilename, //设备model\n        buildver: cookie.buildver || Date.now().toString().substr(0, 10),\n        resolution: cookie.resolution || '1920x1080', //设备分辨率\n        __csrf: csrfToken,\n        os: cookie.os || 'android',\n        channel: cookie.channel,\n        requestId: `${Date.now()}_${Math.floor(Math.random() * 1000)\n          .toString()\n          .padStart(4, '0')}`,\n      }\n      if (cookie.MUSIC_U) header['MUSIC_U'] = cookie.MUSIC_U\n      if (cookie.MUSIC_A) header['MUSIC_A'] = cookie.MUSIC_A\n      headers['Cookie'] = Object.keys(header)\n        .map(\n          (key) =>\n            encodeURIComponent(key) + '=' + encodeURIComponent(header[key]),\n        )\n        .join('; ')\n      data.header = header\n      data = encrypt.eapi(options.url, data)\n      url = url.replace(/\\w*api/, 'eapi')\n    }\n    const answer = { status: 500, body: {}, cookie: [] }\n    let settings = {\n      method: method,\n      url: url,\n      headers: headers,\n      data: new URLSearchParams(data).toString(),\n      httpAgent: new http.Agent({ keepAlive: true }),\n      httpsAgent: new https.Agent({ keepAlive: true }),\n    }\n\n    if (options.crypto === 'eapi') settings.encoding = null\n\n    if (options.proxy) {\n      if (options.proxy.indexOf('pac') > -1) {\n        settings.httpAgent = new PacProxyAgent(options.proxy)\n        settings.httpsAgent = new PacProxyAgent(options.proxy)\n      } else {\n        const purl = new URL(options.proxy)\n        if (purl.hostname) {\n          const agent = tunnel.httpsOverHttp({\n            proxy: {\n              host: purl.hostname,\n              port: purl.port || 80,\n            },\n          })\n          settings.httpsAgent = agent\n          settings.httpAgent = agent\n          settings.proxy = false\n        } else {\n          console.error('代理配置无效,不使用代理')\n        }\n      }\n    } else {\n      settings.proxy = false\n    }\n    if (options.crypto === 'eapi') {\n      settings = {\n        ...settings,\n        responseType: 'arraybuffer',\n      }\n    }\n    axios(settings)\n      .then((res) => {\n        const body = res.data\n        answer.cookie = (res.headers['set-cookie'] || []).map((x) =>\n          x.replace(/\\s*Domain=[^(;|$)]+;*/, ''),\n        )\n        try {\n          if (options.crypto === 'eapi') {\n            answer.body = JSON.parse(encrypt.decrypt(body).toString())\n          } else {\n            answer.body = body\n          }\n\n          answer.status = answer.body.code || res.status\n          if (\n            [201, 302, 400, 502, 800, 801, 802, 803].indexOf(answer.body.code) >\n            -1\n          ) {\n            // 特殊状态码\n            answer.status = 200\n          }\n        } catch (e) {\n          // console.log(e)\n          try {\n            answer.body = JSON.parse(body.toString())\n          } catch (err) {\n            // console.log(err)\n            // can't decrypt and can't parse directly\n            answer.body = body\n          }\n          answer.status = res.status\n        }\n\n        answer.status =\n          100 < answer.status && answer.status < 600 ? answer.status : 400\n        if (answer.status === 200) resolve(answer)\n        else reject(answer)\n      })\n      .catch((err) => {\n        answer.status = 502\n        answer.body = { code: 502, msg: err }\n        reject(answer)\n      })\n  })\n}\n\nmodule.exports = createRequest\n","const crypto = require('crypto')\nconst iv = Buffer.from('0102030405060708')\nconst presetKey = Buffer.from('0CoJUm6Qyw8W8jud')\nconst linuxapiKey = Buffer.from('rFgB&h#%2?^eDg:Q')\nconst base62 = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'\nconst publicKey =\n  '-----BEGIN PUBLIC KEY-----\\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDgtQn2JZ34ZC28NWYpAUd98iZ37BUrX/aKzmFbt7clFSs6sXqHauqKWqdtLkF2KexO40H1YTX8z2lSgBBOAxLsvaklV8k4cBFK9snQXE9/DDaFt6Rr7iVZMldczhC0JNgTz+SHXT6CBHuX3e9SdB1Ua44oncaTWz7OBGLbCiK45wIDAQAB\\n-----END PUBLIC KEY-----'\nconst eapiKey = 'e82ckenh8dichen8'\n\nconst aesEncrypt = (buffer, mode, key, iv) => {\n  const cipher = crypto.createCipheriv('aes-128-' + mode, key, iv)\n  return Buffer.concat([cipher.update(buffer), cipher.final()])\n}\n\nconst rsaEncrypt = (buffer, key) => {\n  buffer = Buffer.concat([Buffer.alloc(128 - buffer.length), buffer])\n  return crypto.publicEncrypt(\n    { key: key, padding: crypto.constants.RSA_NO_PADDING },\n    buffer,\n  )\n}\n\nconst weapi = (object) => {\n  const text = JSON.stringify(object)\n  const secretKey = crypto\n    .randomBytes(16)\n    .map((n) => base62.charAt(n % 62).charCodeAt())\n  return {\n    params: aesEncrypt(\n      Buffer.from(\n        aesEncrypt(Buffer.from(text), 'cbc', presetKey, iv).toString('base64'),\n      ),\n      'cbc',\n      secretKey,\n      iv,\n    ).toString('base64'),\n    encSecKey: rsaEncrypt(secretKey.reverse(), publicKey).toString('hex'),\n  }\n}\n\nconst linuxapi = (object) => {\n  const text = JSON.stringify(object)\n  return {\n    eparams: aesEncrypt(Buffer.from(text), 'ecb', linuxapiKey, '')\n      .toString('hex')\n      .toUpperCase(),\n  }\n}\n\nconst eapi = (url, object) => {\n  const text = typeof object === 'object' ? JSON.stringify(object) : object\n  const message = `nobody${url}use${text}md5forencrypt`\n  const digest = crypto.createHash('md5').update(message).digest('hex')\n  const data = `${url}-36cd479b6b5-${text}-36cd479b6b5-${digest}`\n  return {\n    params: aesEncrypt(Buffer.from(data), 'ecb', eapiKey, '')\n      .toString('hex')\n      .toUpperCase(),\n  }\n}\n\nconst decrypt = (cipherBuffer) => {\n  const decipher = crypto.createDecipheriv('aes-128-ecb', eapiKey, '')\n  return Buffer.concat([decipher.update(cipherBuffer), decipher.final()])\n}\n\nmodule.exports = { weapi, linuxapi, eapi, decrypt }\n","module.exports = {\n  \"anonymous_token\": \"bf8bfeabb1aa84f9c8c3906c04a04fb864322804c83f5d607e91a04eae463c9436bd1a17ec353cf780b396507a3f7464e8a60f4bbc019437993166e004087dd32d1490298caf655c2353e58daa0bc13cc7d5c198250968580b12c1b8817e3f5c807e650dd04abd3fb8130b7ae43fcc5b\",\n  \"resourceTypeMap\": {\n    \"0\": \"R_SO_4_\",\n    \"1\": \"R_MV_5_\",\n    \"2\": \"A_PL_0_\",\n    \"3\": \"R_AL_3_\",\n    \"4\": \"A_DJ_1_\",\n    \"5\": \"R_VI_62_\",\n    \"6\": \"A_EV_2_\",\n    \"7\": \"A_DR_14_\"\n  }\n}","const fs = require('fs')\nconst path = require('path')\nconst express = require('express')\nconst request = require('./util/request')\nconst packageJSON = require('./package.json')\nconst exec = require('child_process').exec\nconst cache = require('./util/apicache').middleware\nconst { cookieToJson } = require('./util/index')\nconst fileUpload = require('express-fileupload')\nconst decode = require('safe-decode-uri-component')\n\n/**\n * The version check result.\n * @readonly\n * @enum {number}\n */\nconst VERSION_CHECK_RESULT = {\n  FAILED: -1,\n  NOT_LATEST: 0,\n  LATEST: 1,\n}\n\n/**\n * @typedef {{\n *   identifier?: string,\n *   route: string,\n *   module: any\n * }} ModuleDefinition\n */\n\n/**\n * @typedef {{\n *   port?: number,\n *   host?: string,\n *   checkVersion?: boolean,\n *   moduleDefs?: ModuleDefinition[]\n * }} NcmApiOptions\n */\n\n/**\n * @typedef {{\n *   status: VERSION_CHECK_RESULT,\n *   ourVersion?: string,\n *   npmVersion?: string,\n * }} VersionCheckResult\n */\n\n/**\n * @typedef {{\n *  server?: import('http').Server,\n * }} ExpressExtension\n */\n\n/**\n * Get the module definitions dynamically.\n *\n * @param {string} modulesPath The path to modules (JS).\n * @param {Record<string, string>} [specificRoute] The specific route of specific modules.\n * @param {boolean} [doRequire] If true, require() the module directly.\n * Otherwise, print out the module path. Default to true.\n * @returns {Promise<ModuleDefinition[]>} The module definitions.\n *\n * @example getModuleDefinitions(\"./module\", {\"album_new.js\": \"/album/create\"})\n */\nasync function getModulesDefinitions(\n  modulesPath,\n  specificRoute,\n  doRequire = true,\n) {\n  const files = await fs.promises.readdir(modulesPath)\n  const parseRoute = (/** @type {string} */ fileName) =>\n    specificRoute && fileName in specificRoute\n      ? specificRoute[fileName]\n      : `/${fileName.replace(/\\.js$/i, '').replace(/_/g, '/')}`\n\n  const modules = files\n    .reverse()\n    .filter((file) => file.endsWith('.js'))\n    .map((file) => {\n      const identifier = file.split('.').shift()\n      const route = parseRoute(file)\n      const modulePath = path.join(modulesPath, file)\n      const module = doRequire ? require(modulePath) : modulePath\n\n      return { identifier, route, module }\n    })\n\n  return modules\n}\n\n/**\n * Check if the version of this API is latest.\n *\n * @returns {Promise<VersionCheckResult>} If true, this API is up-to-date;\n * otherwise, this API should be upgraded and you would\n * need to notify users to upgrade it manually.\n */\nasync function checkVersion() {\n  return new Promise((resolve) => {\n    exec('npm info NeteaseCloudMusicApi version', (err, stdout) => {\n      if (!err) {\n        let version = stdout.trim()\n\n        /**\n         * @param {VERSION_CHECK_RESULT} status\n         */\n        const resolveStatus = (status) =>\n          resolve({\n            status,\n            ourVersion: packageJSON.version,\n            npmVersion: version,\n          })\n\n        resolveStatus(\n          packageJSON.version < version\n            ? VERSION_CHECK_RESULT.NOT_LATEST\n            : VERSION_CHECK_RESULT.LATEST,\n        )\n      }\n    })\n\n    resolve({\n      status: VERSION_CHECK_RESULT.FAILED,\n    })\n  })\n}\n\n/**\n * Construct the server of NCM API.\n *\n * @param {ModuleDefinition[]} [moduleDefs] Customized module definitions [advanced]\n * @returns {Promise<import(\"express\").Express>} The server instance.\n */\nasync function consturctServer(moduleDefs) {\n  const app = express()\n  app.set('trust proxy', true)\n\n  /**\n   * CORS & Preflight request\n   */\n  app.use((req, res, next) => {\n    if (req.path !== '/' && !req.path.includes('.')) {\n      res.set({\n        'Access-Control-Allow-Credentials': true,\n        'Access-Control-Allow-Origin': req.headers.origin || '*',\n        'Access-Control-Allow-Headers': 'X-Requested-With,Content-Type',\n        'Access-Control-Allow-Methods': 'PUT,POST,GET,DELETE,OPTIONS',\n        'Content-Type': 'application/json; charset=utf-8',\n      })\n    }\n    req.method === 'OPTIONS' ? res.status(204).end() : next()\n  })\n\n  /**\n   * Cookie Parser\n   */\n  app.use((req, _, next) => {\n    req.cookies = {}\n    //;(req.headers.cookie || '').split(/\\s*;\\s*/).forEach((pair) => { //  Polynomial regular expression //\n    ;(req.headers.cookie || '').split(/;\\s+|(?<!\\s)\\s+$/g).forEach((pair) => {\n      let crack = pair.indexOf('=')\n      if (crack < 1 || crack == pair.length - 1) return\n      req.cookies[decode(pair.slice(0, crack)).trim()] = decode(\n        pair.slice(crack + 1),\n      ).trim()\n    })\n    next()\n  })\n\n  /**\n   * Body Parser and File Upload\n   */\n  app.use(express.json())\n  app.use(express.urlencoded({ extended: false }))\n\n  app.use(fileUpload())\n\n  /**\n   * Serving static files\n   */\n  app.use(express.static(path.join(__dirname, 'public')))\n\n  /**\n   * Cache\n   */\n  app.use(cache('2 minutes', (_, res) => res.statusCode === 200))\n\n  /**\n   * Special Routers\n   */\n  const special = {\n    'daily_signin.js': '/daily_signin',\n    'fm_trash.js': '/fm_trash',\n    'personal_fm.js': '/personal_fm',\n  }\n\n  /**\n   * Load every modules in this directory\n   */\n  const moduleDefinitions =\n    moduleDefs ||\n    (await getModulesDefinitions(path.join(__dirname, 'module'), special))\n\n  for (const moduleDef of moduleDefinitions) {\n    // Register the route.\n    app.use(moduleDef.route, async (req, res) => {\n      ;[req.query, req.body].forEach((item) => {\n        if (typeof item.cookie === 'string') {\n          item.cookie = cookieToJson(decode(item.cookie))\n        }\n      })\n\n      let query = Object.assign(\n        {},\n        { cookie: req.cookies },\n        req.query,\n        req.body,\n        req.files,\n      )\n\n      try {\n        const moduleResponse = await moduleDef.module(query, (...params) => {\n          // 参数注入客户端IP\n          const obj = [...params]\n          let ip = req.ip\n\n          if (ip.substr(0, 7) == '::ffff:') {\n            ip = ip.substr(7)\n          }\n          // console.log(ip)\n          obj[3] = {\n            ...obj[3],\n            ip,\n          }\n          return request(...obj)\n        })\n        console.log('[OK]', decode(req.originalUrl))\n\n        const cookies = moduleResponse.cookie\n        if (Array.isArray(cookies) && cookies.length > 0) {\n          if (req.protocol === 'https') {\n            // Try to fix CORS SameSite Problem\n            res.append(\n              'Set-Cookie',\n              cookies.map((cookie) => {\n                return cookie + '; SameSite=None; Secure'\n              }),\n            )\n          } else {\n            res.append('Set-Cookie', cookies)\n          }\n        }\n        res.status(moduleResponse.status).send(moduleResponse.body)\n      } catch (/** @type {*} */ moduleResponse) {\n        console.log('[ERR]', decode(req.originalUrl), {\n          status: moduleResponse.status,\n          body: moduleResponse.body,\n        })\n        if (!moduleResponse.body) {\n          res.status(404).send({\n            code: 404,\n            data: null,\n            msg: 'Not Found',\n          })\n          return\n        }\n        if (moduleResponse.body.code == '301')\n          moduleResponse.body.msg = '需要登录'\n        res.append('Set-Cookie', moduleResponse.cookie)\n        res.status(moduleResponse.status).send(moduleResponse.body)\n      }\n    })\n  }\n\n  return app\n}\n\n/**\n * Serve the NCM API.\n * @param {NcmApiOptions} options\n * @returns {Promise<import('express').Express & ExpressExtension>}\n */\nasync function serveNcmApi(options) {\n  const port = Number(options.port || process.env.PORT || '3000')\n  const host = options.host || process.env.HOST || ''\n\n  const checkVersionSubmission =\n    options.checkVersion &&\n    checkVersion().then(({ npmVersion, ourVersion, status }) => {\n      if (status == VERSION_CHECK_RESULT.NOT_LATEST) {\n        console.log(\n          `最新版本: ${npmVersion}, 当前版本: ${ourVersion}, 请及时更新`,\n        )\n      }\n    })\n  const constructServerSubmission = consturctServer(options.moduleDefs)\n\n  const [_, app] = await Promise.all([\n    checkVersionSubmission,\n    constructServerSubmission,\n  ])\n\n  /** @type {import('express').Express & ExpressExtension} */\n  const appExt = app\n  appExt.server = app.listen(port, host, () => {\n    console.log(`server running @ http://${host ? host : 'localhost'}:${port}`)\n  })\n\n  return appExt\n}\n\nmodule.exports = {\n  serveNcmApi,\n  getModulesDefinitions,\n}\n","module.exports = {\n  \"name\": \"NeteaseCloudMusicApi\",\n  \"version\": \"4.8.2\",\n  \"description\": \"网易云音乐 NodeJS 版 API\",\n  \"scripts\": {\n    \"start\": \"node app.js\",\n    \"test\": \"mocha -r intelli-espower-loader -t 30000 server.test.js main.test.js --exit\",\n    \"lint\": \"eslint \\\"**/*.{js,ts}\\\"\",\n    \"lint-fix\": \"eslint --fix \\\"**/*.{js,ts}\\\"\",\n    \"prepare\": \"husky install\",\n    \"pkgwin\": \"pkg . -t node14-win-x64 -o app\",\n    \"pkglinux\": \"pkg . -t node14-linux-x64 -o app\",\n    \"pkgmacos\": \"pkg . -t node14-macos-x64 -o app\"\n  },\n  \"bin\": \"./app.js\",\n  \"pkg\": {\n    \"scripts\": \"module/*.js\",\n    \"assets\": [\n      \"/node_modules/vm2/lib/contextify.js\",\n      \"/public\"\n    ]\n  },\n  \"keywords\": [\n    \"网易云音乐\",\n    \"网易云\",\n    \"音乐\",\n    \"网易云音乐nodejs\"\n  ],\n  \"main\": \"main.js\",\n  \"types\": \"./interface.d.ts\",\n  \"engines\": {\n    \"node\": \">=12\"\n  },\n  \"lint-staged\": {\n    \"*.js\": [\n      \"eslint --fix\",\n      \"git add\"\n    ]\n  },\n  \"author\": \"binaryify\",\n  \"license\": \"MIT\",\n  \"files\": [\n    \"module\",\n    \"util\",\n    \"plugins\",\n    \"main.d.ts\",\n    \"interface.d.ts\",\n    \"module_types\",\n    \"server.js\",\n    \"generateConfig.js\",\n    \"public\"\n  ],\n  \"dependencies\": {\n    \"axios\": \"^0.24.0\",\n    \"express\": \"^4.17.1\",\n    \"express-fileupload\": \"^1.1.9\",\n    \"md5\": \"^2.3.0\",\n    \"music-metadata\": \"^7.5.3\",\n    \"pac-proxy-agent\": \"^5.0.0\",\n    \"qrcode\": \"^1.4.4\",\n    \"safe-decode-uri-component\": \"^1.2.1\",\n    \"tunnel\": \"^0.0.6\",\n    \"yargs\": \"^17.1.1\"\n  },\n  \"devDependencies\": {\n    \"@types/express\": \"^4.17.13\",\n    \"@types/express-fileupload\": \"^1.2.2\",\n    \"@types/mocha\": \"^9.1.0\",\n    \"@types/node\": \"16.11.19\",\n    \"@typescript-eslint/eslint-plugin\": \"5.0.0\",\n    \"@typescript-eslint/parser\": \"5.0.0\",\n    \"eslint\": \"8.7.0\",\n    \"eslint-config-prettier\": \"8.5.0\",\n    \"eslint-plugin-html\": \"6.2.0\",\n    \"eslint-plugin-prettier\": \"4.0.0\",\n    \"husky\": \"7.0.4\",\n    \"intelli-espower-loader\": \"1.1.0\",\n    \"lint-staged\": \"12.1.7\",\n    \"mocha\": \"10.0.0\",\n    \"power-assert\": \"1.6.1\",\n    \"prettier\": \"2.7.1\",\n    \"typescript\": \"4.5.2\"\n  }\n}\n","var url = require('url')\nvar MemoryCache = require('./memory-cache')\n\nvar t = {\n  ms: 1,\n  second: 1000,\n  minute: 60000,\n  hour: 3600000,\n  day: 3600000 * 24,\n  week: 3600000 * 24 * 7,\n  month: 3600000 * 24 * 30,\n}\n\nvar instances = []\n\nvar matches = function (a) {\n  return function (b) {\n    return a === b\n  }\n}\n\nvar doesntMatch = function (a) {\n  return function (b) {\n    return !matches(a)(b)\n  }\n}\n\nvar logDuration = function (d, prefix) {\n  var str = d > 1000 ? (d / 1000).toFixed(2) + 'sec' : d + 'ms'\n  return '\\x1b[33m- ' + (prefix ? prefix + ' ' : '') + str + '\\x1b[0m'\n}\n\nfunction getSafeHeaders(res) {\n  return res.getHeaders ? res.getHeaders() : res._headers\n}\n\nfunction ApiCache() {\n  var memCache = new MemoryCache()\n\n  var globalOptions = {\n    debug: false,\n    defaultDuration: 3600000,\n    enabled: true,\n    appendKey: [],\n    jsonp: false,\n    redisClient: false,\n    headerBlacklist: [],\n    statusCodes: {\n      include: [],\n      exclude: [],\n    },\n    events: {\n      expire: undefined,\n    },\n    headers: {\n      // 'cache-control':  'no-cache' // example of header overwrite\n    },\n    trackPerformance: false,\n  }\n\n  var middlewareOptions = []\n  var instance = this\n  var index = null\n  var timers = {}\n  var performanceArray = [] // for tracking cache hit rate\n\n  instances.push(this)\n  this.id = instances.length\n\n  function debug(a, b, c, d) {\n    var arr = ['\\x1b[36m[apicache]\\x1b[0m', a, b, c, d].filter(function (arg) {\n      return arg !== undefined\n    })\n    var debugEnv =\n      process.env.DEBUG &&\n      process.env.DEBUG.split(',').indexOf('apicache') !== -1\n\n    return (globalOptions.debug || debugEnv) && console.log.apply(null, arr)\n  }\n\n  function shouldCacheResponse(request, response, toggle) {\n    var opt = globalOptions\n    var codes = opt.statusCodes\n\n    if (!response) return false\n\n    if (toggle && !toggle(request, response)) {\n      return false\n    }\n\n    if (\n      codes.exclude &&\n      codes.exclude.length &&\n      codes.exclude.indexOf(response.statusCode) !== -1\n    )\n      return false\n    if (\n      codes.include &&\n      codes.include.length &&\n      codes.include.indexOf(response.statusCode) === -1\n    )\n      return false\n\n    return true\n  }\n\n  function addIndexEntries(key, req) {\n    var groupName = req.apicacheGroup\n\n    if (groupName) {\n      debug('group detected \"' + groupName + '\"')\n      var group = (index.groups[groupName] = index.groups[groupName] || [])\n      group.unshift(key)\n    }\n\n    index.all.unshift(key)\n  }\n\n  function filterBlacklistedHeaders(headers) {\n    return Object.keys(headers)\n      .filter(function (key) {\n        return globalOptions.headerBlacklist.indexOf(key) === -1\n      })\n      .reduce(function (acc, header) {\n        acc[header] = headers[header]\n        return acc\n      }, {})\n  }\n\n  function createCacheObject(status, headers, data, encoding) {\n    return {\n      status: status,\n      headers: filterBlacklistedHeaders(headers),\n      data: data,\n      encoding: encoding,\n      timestamp: new Date().getTime() / 1000, // seconds since epoch.  This is used to properly decrement max-age headers in cached responses.\n    }\n  }\n\n  function cacheResponse(key, value, duration) {\n    var redis = globalOptions.redisClient\n    var expireCallback = globalOptions.events.expire\n\n    if (redis && redis.connected) {\n      try {\n        redis.hset(key, 'response', JSON.stringify(value))\n        redis.hset(key, 'duration', duration)\n        redis.expire(key, duration / 1000, expireCallback || function () {})\n      } catch (err) {\n        debug('[apicache] error in redis.hset()')\n      }\n    } else {\n      memCache.add(key, value, duration, expireCallback)\n    }\n\n    // add automatic cache clearing from duration, includes max limit on setTimeout\n    timers[key] = setTimeout(function () {\n      instance.clear(key, true)\n    }, Math.min(duration, 2147483647))\n  }\n\n  function accumulateContent(res, content) {\n    if (content) {\n      if (typeof content == 'string') {\n        res._apicache.content = (res._apicache.content || '') + content\n      } else if (Buffer.isBuffer(content)) {\n        var oldContent = res._apicache.content\n\n        if (typeof oldContent === 'string') {\n          oldContent = !Buffer.from\n            ? new Buffer(oldContent)\n            : Buffer.from(oldContent)\n        }\n\n        if (!oldContent) {\n          oldContent = !Buffer.alloc ? new Buffer(0) : Buffer.alloc(0)\n        }\n\n        res._apicache.content = Buffer.concat(\n          [oldContent, content],\n          oldContent.length + content.length,\n        )\n      } else {\n        res._apicache.content = content\n      }\n    }\n  }\n\n  function makeResponseCacheable(\n    req,\n    res,\n    next,\n    key,\n    duration,\n    strDuration,\n    toggle,\n  ) {\n    // monkeypatch res.end to create cache object\n    res._apicache = {\n      write: res.write,\n      writeHead: res.writeHead,\n      end: res.end,\n      cacheable: true,\n      content: undefined,\n    }\n\n    // append header overwrites if applicable\n    Object.keys(globalOptions.headers).forEach(function (name) {\n      res.setHeader(name, globalOptions.headers[name])\n    })\n\n    res.writeHead = function () {\n      // add cache control headers\n      if (!globalOptions.headers['cache-control']) {\n        if (shouldCacheResponse(req, res, toggle)) {\n          res.setHeader(\n            'cache-control',\n            'max-age=' + (duration / 1000).toFixed(0),\n          )\n        } else {\n          res.setHeader('cache-control', 'no-cache, no-store, must-revalidate')\n        }\n      }\n\n      res._apicache.headers = Object.assign({}, getSafeHeaders(res))\n      return res._apicache.writeHead.apply(this, arguments)\n    }\n\n    // patch res.write\n    res.write = function (content) {\n      accumulateContent(res, content)\n      return res._apicache.write.apply(this, arguments)\n    }\n\n    // patch res.end\n    res.end = function (content, encoding) {\n      if (shouldCacheResponse(req, res, toggle)) {\n        accumulateContent(res, content)\n\n        if (res._apicache.cacheable && res._apicache.content) {\n          addIndexEntries(key, req)\n          var headers = res._apicache.headers || getSafeHeaders(res)\n          var cacheObject = createCacheObject(\n            res.statusCode,\n            headers,\n            res._apicache.content,\n            encoding,\n          )\n          cacheResponse(key, cacheObject, duration)\n\n          // display log entry\n          var elapsed = new Date() - req.apicacheTimer\n          debug(\n            'adding cache entry for \"' + key + '\" @ ' + strDuration,\n            logDuration(elapsed),\n          )\n          debug('_apicache.headers: ', res._apicache.headers)\n          debug('res.getHeaders(): ', getSafeHeaders(res))\n          debug('cacheObject: ', cacheObject)\n        }\n      }\n\n      return res._apicache.end.apply(this, arguments)\n    }\n\n    next()\n  }\n\n  function sendCachedResponse(\n    request,\n    response,\n    cacheObject,\n    toggle,\n    next,\n    duration,\n  ) {\n    if (toggle && !toggle(request, response)) {\n      return next()\n    }\n\n    var headers = getSafeHeaders(response)\n\n    Object.assign(\n      headers,\n      filterBlacklistedHeaders(cacheObject.headers || {}),\n      {\n        // set properly-decremented max-age header.  This ensures that max-age is in sync with the cache expiration.\n        'cache-control':\n          'max-age=' +\n          Math.max(\n            0,\n            (\n              duration / 1000 -\n              (new Date().getTime() / 1000 - cacheObject.timestamp)\n            ).toFixed(0),\n          ),\n      },\n    )\n\n    // only embed apicache headers when not in production environment\n\n    // unstringify buffers\n    var data = cacheObject.data\n    if (data && data.type === 'Buffer') {\n      data =\n        typeof data.data === 'number'\n          ? new Buffer.alloc(data.data)\n          : new Buffer.from(data.data)\n    }\n\n    // test Etag against If-None-Match for 304\n    var cachedEtag = cacheObject.headers.etag\n    var requestEtag = request.headers['if-none-match']\n\n    if (requestEtag && cachedEtag === requestEtag) {\n      response.writeHead(304, headers)\n      return response.end()\n    }\n\n    response.writeHead(cacheObject.status || 200, headers)\n\n    return response.end(data, cacheObject.encoding)\n  }\n\n  function syncOptions() {\n    for (var i in middlewareOptions) {\n      Object.assign(\n        middlewareOptions[i].options,\n        globalOptions,\n        middlewareOptions[i].localOptions,\n      )\n    }\n  }\n\n  this.clear = function (target, isAutomatic) {\n    var group = index.groups[target]\n    var redis = globalOptions.redisClient\n\n    if (group) {\n      debug('clearing group \"' + target + '\"')\n\n      group.forEach(function (key) {\n        debug('clearing cached entry for \"' + key + '\"')\n        clearTimeout(timers[key])\n        delete timers[key]\n        if (!globalOptions.redisClient) {\n          memCache.delete(key)\n        } else {\n          try {\n            redis.del(key)\n          } catch (err) {\n            console.log('[apicache] error in redis.del(\"' + key + '\")')\n          }\n        }\n        index.all = index.all.filter(doesntMatch(key))\n      })\n\n      delete index.groups[target]\n    } else if (target) {\n      debug(\n        'clearing ' +\n          (isAutomatic ? 'expired' : 'cached') +\n          ' entry for \"' +\n          target +\n          '\"',\n      )\n      clearTimeout(timers[target])\n      delete timers[target]\n      // clear actual cached entry\n      if (!redis) {\n        memCache.delete(target)\n      } else {\n        try {\n          redis.del(target)\n        } catch (err) {\n          console.log('[apicache] error in redis.del(\"' + target + '\")')\n        }\n      }\n\n      // remove from global index\n      index.all = index.all.filter(doesntMatch(target))\n\n      // remove target from each group that it may exist in\n      Object.keys(index.groups).forEach(function (groupName) {\n        index.groups[groupName] = index.groups[groupName].filter(\n          doesntMatch(target),\n        )\n\n        // delete group if now empty\n        if (!index.groups[groupName].length) {\n          delete index.groups[groupName]\n        }\n      })\n    } else {\n      debug('clearing entire index')\n\n      if (!redis) {\n        memCache.clear()\n      } else {\n        // clear redis keys one by one from internal index to prevent clearing non-apicache entries\n        index.all.forEach(function (key) {\n          clearTimeout(timers[key])\n          delete timers[key]\n          try {\n            redis.del(key)\n          } catch (err) {\n            console.log('[apicache] error in redis.del(\"' + key + '\")')\n          }\n        })\n      }\n      this.resetIndex()\n    }\n\n    return this.getIndex()\n  }\n\n  function parseDuration(duration, defaultDuration) {\n    if (typeof duration === 'number') return duration\n\n    if (typeof duration === 'string') {\n      var split = duration.match(/^([\\d\\.,]+)\\s?(\\w+)$/)\n\n      if (split.length === 3) {\n        var len = parseFloat(split[1])\n        var unit = split[2].replace(/s$/i, '').toLowerCase()\n        if (unit === 'm') {\n          unit = 'ms'\n        }\n\n        return (len || 1) * (t[unit] || 0)\n      }\n    }\n\n    return defaultDuration\n  }\n\n  this.getDuration = function (duration) {\n    return parseDuration(duration, globalOptions.defaultDuration)\n  }\n\n  /**\n   * Return cache performance statistics (hit rate).  Suitable for putting into a route:\n   * <code>\n   * app.get('/api/cache/performance', (req, res) => {\n   *    res.json(apicache.getPerformance())\n   * })\n   * </code>\n   */\n  this.getPerformance = function () {\n    return performanceArray.map(function (p) {\n      return p.report()\n    })\n  }\n\n  this.getIndex = function (group) {\n    if (group) {\n      return index.groups[group]\n    } else {\n      return index\n    }\n  }\n\n  this.middleware = function cache(\n    strDuration,\n    middlewareToggle,\n    localOptions,\n  ) {\n    var duration = instance.getDuration(strDuration)\n    var opt = {}\n\n    middlewareOptions.push({\n      options: opt,\n    })\n\n    var options = function (localOptions) {\n      if (localOptions) {\n        middlewareOptions.find(function (middleware) {\n          return middleware.options === opt\n        }).localOptions = localOptions\n      }\n\n      syncOptions()\n\n      return opt\n    }\n\n    options(localOptions)\n\n    /**\n     * A Function for non tracking performance\n     */\n    function NOOPCachePerformance() {\n      this.report = this.hit = this.miss = function () {} // noop;\n    }\n\n    /**\n     * A function for tracking and reporting hit rate.  These statistics are returned by the getPerformance() call above.\n     */\n    function CachePerformance() {\n      /**\n       * Tracks the hit rate for the last 100 requests.\n       * If there have been fewer than 100 requests, the hit rate just considers the requests that have happened.\n       */\n      this.hitsLast100 = new Uint8Array(100 / 4) // each hit is 2 bits\n\n      /**\n       * Tracks the hit rate for the last 1000 requests.\n       * If there have been fewer than 1000 requests, the hit rate just considers the requests that have happened.\n       */\n      this.hitsLast1000 = new Uint8Array(1000 / 4) // each hit is 2 bits\n\n      /**\n       * Tracks the hit rate for the last 10000 requests.\n       * If there have been fewer than 10000 requests, the hit rate just considers the requests that have happened.\n       */\n      this.hitsLast10000 = new Uint8Array(10000 / 4) // each hit is 2 bits\n\n      /**\n       * Tracks the hit rate for the last 100000 requests.\n       * If there have been fewer than 100000 requests, the hit rate just considers the requests that have happened.\n       */\n      this.hitsLast100000 = new Uint8Array(100000 / 4) // each hit is 2 bits\n\n      /**\n       * The number of calls that have passed through the middleware since the server started.\n       */\n      this.callCount = 0\n\n      /**\n       * The total number of hits since the server started\n       */\n      this.hitCount = 0\n\n      /**\n       * The key from the last cache hit.  This is useful in identifying which route these statistics apply to.\n       */\n      this.lastCacheHit = null\n\n      /**\n       * The key from the last cache miss.  This is useful in identifying which route these statistics apply to.\n       */\n      this.lastCacheMiss = null\n\n      /**\n       * Return performance statistics\n       */\n      this.report = function () {\n        return {\n          lastCacheHit: this.lastCacheHit,\n          lastCacheMiss: this.lastCacheMiss,\n          callCount: this.callCount,\n          hitCount: this.hitCount,\n          missCount: this.callCount - this.hitCount,\n          hitRate: this.callCount == 0 ? null : this.hitCount / this.callCount,\n          hitRateLast100: this.hitRate(this.hitsLast100),\n          hitRateLast1000: this.hitRate(this.hitsLast1000),\n          hitRateLast10000: this.hitRate(this.hitsLast10000),\n          hitRateLast100000: this.hitRate(this.hitsLast100000),\n        }\n      }\n\n      /**\n       * Computes a cache hit rate from an array of hits and misses.\n       * @param {Uint8Array} array An array representing hits and misses.\n       * @returns a number between 0 and 1, or null if the array has no hits or misses\n       */\n      this.hitRate = function (array) {\n        var hits = 0\n        var misses = 0\n        for (var i = 0; i < array.length; i++) {\n          var n8 = array[i]\n          for (j = 0; j < 4; j++) {\n            switch (n8 & 3) {\n              case 1:\n                hits++\n                break\n              case 2:\n                misses++\n                break\n            }\n            n8 >>= 2\n          }\n        }\n        var total = hits + misses\n        if (total == 0) return null\n        return hits / total\n      }\n\n      /**\n       * Record a hit or miss in the given array.  It will be recorded at a position determined\n       * by the current value of the callCount variable.\n       * @param {Uint8Array} array An array representing hits and misses.\n       * @param {boolean} hit true for a hit, false for a miss\n       * Each element in the array is 8 bits, and encodes 4 hit/miss records.\n       * Each hit or miss is encoded as to bits as follows:\n       * 00 means no hit or miss has been recorded in these bits\n       * 01 encodes a hit\n       * 10 encodes a miss\n       */\n      this.recordHitInArray = function (array, hit) {\n        var arrayIndex = ~~(this.callCount / 4) % array.length\n        var bitOffset = (this.callCount % 4) * 2 // 2 bits per record, 4 records per uint8 array element\n        var clearMask = ~(3 << bitOffset)\n        var record = (hit ? 1 : 2) << bitOffset\n        array[arrayIndex] = (array[arrayIndex] & clearMask) | record\n      }\n\n      /**\n       * Records the hit or miss in the tracking arrays and increments the call count.\n       * @param {boolean} hit true records a hit, false records a miss\n       */\n      this.recordHit = function (hit) {\n        this.recordHitInArray(this.hitsLast100, hit)\n        this.recordHitInArray(this.hitsLast1000, hit)\n        this.recordHitInArray(this.hitsLast10000, hit)\n        this.recordHitInArray(this.hitsLast100000, hit)\n        if (hit) this.hitCount++\n        this.callCount++\n      }\n\n      /**\n       * Records a hit event, setting lastCacheMiss to the given key\n       * @param {string} key The key that had the cache hit\n       */\n      this.hit = function (key) {\n        this.recordHit(true)\n        this.lastCacheHit = key\n      }\n\n      /**\n       * Records a miss event, setting lastCacheMiss to the given key\n       * @param {string} key The key that had the cache miss\n       */\n      this.miss = function (key) {\n        this.recordHit(false)\n        this.lastCacheMiss = key\n      }\n    }\n\n    var perf = globalOptions.trackPerformance\n      ? new CachePerformance()\n      : new NOOPCachePerformance()\n\n    performanceArray.push(perf)\n\n    var cache = function (req, res, next) {\n      function bypass() {\n        debug('bypass detected, skipping cache.')\n        return next()\n      }\n\n      // initial bypass chances\n      if (!opt.enabled) return bypass()\n      if (\n        req.headers['x-apicache-bypass'] ||\n        req.headers['x-apicache-force-fetch']\n      )\n        return bypass()\n\n      // REMOVED IN 0.11.1 TO CORRECT MIDDLEWARE TOGGLE EXECUTE ORDER\n      // if (typeof middlewareToggle === 'function') {\n      //   if (!middlewareToggle(req, res)) return bypass()\n      // } else if (middlewareToggle !== undefined && !middlewareToggle) {\n      //   return bypass()\n      // }\n\n      // embed timer\n      req.apicacheTimer = new Date()\n\n      // In Express 4.x the url is ambigious based on where a router is mounted.  originalUrl will give the full Url\n      var key = req.originalUrl || req.url\n\n      // Remove querystring from key if jsonp option is enabled\n      if (opt.jsonp) {\n        key = url.parse(key).pathname\n      }\n\n      // add appendKey (either custom function or response path)\n      if (typeof opt.appendKey === 'function') {\n        key += '$$appendKey=' + opt.appendKey(req, res)\n      } else if (opt.appendKey.length > 0) {\n        var appendKey = req\n\n        for (var i = 0; i < opt.appendKey.length; i++) {\n          appendKey = appendKey[opt.appendKey[i]]\n        }\n        key += '$$appendKey=' + appendKey\n      }\n\n      // attempt cache hit\n      var redis = opt.redisClient\n      var cached = !redis ? memCache.getValue(key) : null\n\n      // send if cache hit from memory-cache\n      if (cached) {\n        var elapsed = new Date() - req.apicacheTimer\n        debug(\n          'sending cached (memory-cache) version of',\n          key,\n          logDuration(elapsed),\n        )\n\n        perf.hit(key)\n        return sendCachedResponse(\n          req,\n          res,\n          cached,\n          middlewareToggle,\n          next,\n          duration,\n        )\n      }\n\n      // send if cache hit from redis\n      if (redis && redis.connected) {\n        try {\n          redis.hgetall(key, function (err, obj) {\n            if (!err && obj && obj.response) {\n              var elapsed = new Date() - req.apicacheTimer\n              debug(\n                'sending cached (redis) version of',\n                key,\n                logDuration(elapsed),\n              )\n\n              perf.hit(key)\n              return sendCachedResponse(\n                req,\n                res,\n                JSON.parse(obj.response),\n                middlewareToggle,\n                next,\n                duration,\n              )\n            } else {\n              perf.miss(key)\n              return makeResponseCacheable(\n                req,\n                res,\n                next,\n                key,\n                duration,\n                strDuration,\n                middlewareToggle,\n              )\n            }\n          })\n        } catch (err) {\n          // bypass redis on error\n          perf.miss(key)\n          return makeResponseCacheable(\n            req,\n            res,\n            next,\n            key,\n            duration,\n            strDuration,\n            middlewareToggle,\n          )\n        }\n      } else {\n        perf.miss(key)\n        return makeResponseCacheable(\n          req,\n          res,\n          next,\n          key,\n          duration,\n          strDuration,\n          middlewareToggle,\n        )\n      }\n    }\n\n    cache.options = options\n\n    return cache\n  }\n\n  this.options = function (options) {\n    if (options) {\n      Object.assign(globalOptions, options)\n      syncOptions()\n\n      if ('defaultDuration' in options) {\n        // Convert the default duration to a number in milliseconds (if needed)\n        globalOptions.defaultDuration = parseDuration(\n          globalOptions.defaultDuration,\n          3600000,\n        )\n      }\n\n      if (globalOptions.trackPerformance) {\n        debug(\n          'WARNING: using trackPerformance flag can cause high memory usage!',\n        )\n      }\n\n      return this\n    } else {\n      return globalOptions\n    }\n  }\n\n  this.resetIndex = function () {\n    index = {\n      all: [],\n      groups: {},\n    }\n  }\n\n  this.newInstance = function (config) {\n    var instance = new ApiCache()\n\n    if (config) {\n      instance.options(config)\n    }\n\n    return instance\n  }\n\n  this.clone = function () {\n    return this.newInstance(this.options())\n  }\n\n  // initialize index\n  this.resetIndex()\n}\n\nmodule.exports = new ApiCache()\n","function MemoryCache() {\n  this.cache = {}\n  this.size = 0\n}\n\nMemoryCache.prototype.add = function (key, value, time, timeoutCallback) {\n  var old = this.cache[key]\n  var instance = this\n\n  var entry = {\n    value: value,\n    expire: time + Date.now(),\n    timeout: setTimeout(function () {\n      instance.delete(key)\n      return (\n        timeoutCallback &&\n        typeof timeoutCallback === 'function' &&\n        timeoutCallback(value, key)\n      )\n    }, time),\n  }\n\n  this.cache[key] = entry\n  this.size = Object.keys(this.cache).length\n\n  return entry\n}\n\nMemoryCache.prototype.delete = function (key) {\n  var entry = this.cache[key]\n\n  if (entry) {\n    clearTimeout(entry.timeout)\n  }\n\n  delete this.cache[key]\n\n  this.size = Object.keys(this.cache).length\n\n  return null\n}\n\nMemoryCache.prototype.get = function (key) {\n  var entry = this.cache[key]\n\n  return entry\n}\n\nMemoryCache.prototype.getValue = function (key) {\n  var entry = this.get(key)\n\n  return entry && entry.value\n}\n\nMemoryCache.prototype.clear = function () {\n  Object.keys(this.cache).forEach(function (key) {\n    this.delete(key)\n  }, this)\n\n  return true\n}\n\nmodule.exports = MemoryCache\n"]}