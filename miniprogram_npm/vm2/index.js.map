{"version":3,"sources":["index.js","lib/main.js","lib/bridge.js","lib/script.js","lib/vm.js","lib/events.js","lib/transformer.js","lib/compiler.js","lib/nodevm.js","lib/resolver-compat.js","lib/resolver.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA,ACHA;AFOA,ADGA,AENA,ACHA;AFOA,ADGA,AENA,ACHA;AFOA,AGTA,AJYA,AENA,ACHA;AFOA,AGTA,AJYA,AENA,ACHA;AFOA,AGTA,AJYA,AENA,ACHA;AFOA,AGTA,AJYA,AENA,AGTA,AFMA;AFOA,AGTA,AJYA,AENA,AGTA,AFMA;AFOA,AGTA,AJYA,AENA,AGTA,AFMA;AFOA,AKfA,AFMA,AJYA,AENA,AGTA,AFMA;AFOA,AKfA,AFMA,AJYA,AENA,AGTA,AFMA;AFOA,AKfA,AFMA,AFMA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ALeA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ALeA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ALeA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ANkBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ANkBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ANkBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AKfA,AFMA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,AGTA,AFMA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,ACHA,ACHA,APqBA,ACHA;AFOA,AGTA,AGTA,AENA,APqBA,ACHA;AFOA,AGTA,AGTA,AENA,APqBA,ACHA;AFOA,AGTA,AGTA,AENA,APqBA,ACHA;AFOA,AGTA,AGTA,AENA,APqBA,ACHA;AFOA,AGTA,AGTA,AENA,APqBA,ACHA;AFOA,AGTA,AGTA,AENA,APqBA,ACHA;AFOA,AGTA,AGTA,AENA,APqBA,ACHA;AFOA,AGTA,AGTA,AENA,APqBA,ACHA;AFOA,AGTA,AGTA,AENA,APqBA,ACHA;AFOA,AGTA,AGTA,AENA,APqBA,ACHA;AFOA,AGTA,AGTA,AENA,APqBA,ACHA;AFOA,AGTA,AGTA,AENA,APqBA,ACHA;AFOA,AGTA,AGTA,AENA,APqBA,ACHA;AFOA,AGTA,AGTA,AENA,APqBA,ACHA;AFOA,AGTA,AGTA,AENA,APqBA,ACHA;AFOA,AGTA,AGTA,AENA,APqBA,ACHA;AFOA,AGTA,AGTA,AENA,APqBA,ACHA;AFOA,AGTA,AGTA,AENA,APqBA,ACHA;AFOA,AGTA,AGTA,AENA,APqBA,ACHA;AFOA,AGTA,AGTA,AENA,APqBA,ACHA;AFOA,AGTA,AGTA,AENA,APqBA,ACHA;AFOA,AGTA,AGTA,AENA,APqBA,ACHA;AFOA,AGTA,AGTA,AENA,APqBA,ACHA;AFOA,AGTA,AGTA,AENA,APqBA,ACHA;AFOA,AGTA,AGTA,AENA,APqBA,ACHA;AFOA,AGTA,AGTA,AENA,APqBA,ACHA;AFOA,AGTA,AGTA,AENA,APqBA,ACHA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AGTA,AENA,ANkBA;AFOA,AGTA,AKfA,ANkBA;AFOA,AGTA,AKfA,ANkBA;AFOA,AGTA,AKfA,ANkBA;AFOA,AGTA,AKfA,ANkBA;AFOA,AGTA,AKfA,ANkBA;AFOA,AGTA,AKfA,ANkBA;AFOA,AGTA,AKfA,ANkBA;AFOA,AGTA,AKfA,ANkBA;AFOA,AGTA,AKfA,ANkBA;AFOA,AGTA,AKfA,ANkBA;AFOA,AGTA,AKfA,ANkBA;AFOA,AGTA,AKfA,ANkBA;AFOA,AGTA,AKfA,ANkBA;AFOA,AGTA,AKfA,ANkBA;AFOA,AGTA,AKfA,ANkBA;AFOA,AGTA,AKfA,ANkBA;AFOA,AGTA,AKfA,ANkBA;AFOA,AGTA,AKfA,ANkBA;AFOA,AGTA,AKfA,ANkBA;AFOA,AGTA,AKfA,ANkBA;AFOA,AGTA,AKfA,ANkBA;AFOA,AGTA,AKfA,ANkBA;AFOA,AGTA,AKfA,ANkBA;AFOA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA,AKfA;ARyBA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA,AGTA;AHUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["if (parseInt(process.versions.node.split('.')[0]) < 6) throw new Error('vm2 requires Node.js version 6 or newer.');\n\nmodule.exports = require('./lib/main');\n","\n\nconst {\n\tVMError\n} = require('./bridge');\nconst {\n\tVMScript\n} = require('./script');\nconst {\n\tVM\n} = require('./vm');\nconst {\n\tNodeVM\n} = require('./nodevm');\n\nexports.VMError = VMError;\nexports.VMScript = VMScript;\nexports.NodeVM = NodeVM;\nexports.VM = VM;\n","\n\n/**\n * __        ___    ____  _   _ ___ _   _  ____\n * \\ \\      / / \\  |  _ \\| \\ | |_ _| \\ | |/ ___|\n *  \\ \\ /\\ / / _ \\ | |_) |  \\| || ||  \\| | |  _\n *   \\ V  V / ___ \\|  _ <| |\\  || || |\\  | |_| |\n *    \\_/\\_/_/   \\_\\_| \\_\\_| \\_|___|_| \\_|\\____|\n *\n * This file is critical for vm2. It implements the bridge between the host and the sandbox.\n * If you do not know exactly what you are doing, you should NOT edit this file.\n *\n * The file is loaded in the host and sandbox to handle objects in both directions.\n * This is done to ensure that RangeErrors are from the correct context.\n * The boundary between the sandbox and host might throw RangeErrors from both contexts.\n * Therefore, thisFromOther and friends can handle objects from both domains.\n *\n * Method parameters have comments to tell from which context they came.\n *\n */\n\nconst globalsList = [\n\t'Number',\n\t'String',\n\t'Boolean',\n\t'Date',\n\t'RegExp',\n\t'Map',\n\t'WeakMap',\n\t'Set',\n\t'WeakSet',\n\t'Promise',\n\t'Function'\n];\n\nconst errorsList = [\n\t'RangeError',\n\t'ReferenceError',\n\t'SyntaxError',\n\t'TypeError',\n\t'EvalError',\n\t'URIError',\n\t'Error'\n];\n\nconst OPNA = 'Operation not allowed on contextified object.';\n\nconst thisGlobalPrototypes = {\n\t__proto__: null,\n\tObject: Object.prototype,\n\tArray: Array.prototype\n};\n\nfor (let i = 0; i < globalsList.length; i++) {\n\tconst key = globalsList[i];\n\tconst g = global[key];\n\tif (g) thisGlobalPrototypes[key] = g.prototype;\n}\n\nfor (let i = 0; i < errorsList.length; i++) {\n\tconst key = errorsList[i];\n\tconst g = global[key];\n\tif (g) thisGlobalPrototypes[key] = g.prototype;\n}\n\nconst {\n\tgetPrototypeOf: thisReflectGetPrototypeOf,\n\tsetPrototypeOf: thisReflectSetPrototypeOf,\n\tdefineProperty: thisReflectDefineProperty,\n\tdeleteProperty: thisReflectDeleteProperty,\n\tgetOwnPropertyDescriptor: thisReflectGetOwnPropertyDescriptor,\n\tisExtensible: thisReflectIsExtensible,\n\tpreventExtensions: thisReflectPreventExtensions,\n\tapply: thisReflectApply,\n\tconstruct: thisReflectConstruct,\n\tset: thisReflectSet,\n\tget: thisReflectGet,\n\thas: thisReflectHas,\n\townKeys: thisReflectOwnKeys,\n\tenumerate: thisReflectEnumerate,\n} = Reflect;\n\nconst thisObject = Object;\nconst {\n\tfreeze: thisObjectFreeze,\n\tprototype: thisObjectPrototype\n} = thisObject;\nconst thisObjectHasOwnProperty = thisObjectPrototype.hasOwnProperty;\nconst ThisProxy = Proxy;\nconst ThisWeakMap = WeakMap;\nconst {\n\tget: thisWeakMapGet,\n\tset: thisWeakMapSet\n} = ThisWeakMap.prototype;\nconst ThisMap = Map;\nconst thisMapGet = ThisMap.prototype.get;\nconst thisMapSet = ThisMap.prototype.set;\nconst thisFunction = Function;\nconst thisFunctionBind = thisFunction.prototype.bind;\nconst thisArrayIsArray = Array.isArray;\nconst thisErrorCaptureStackTrace = Error.captureStackTrace;\n\nconst thisSymbolToString = Symbol.prototype.toString;\nconst thisSymbolToStringTag = Symbol.toStringTag;\nconst thisSymbolIterator = Symbol.iterator;\nconst thisSymbolNodeJSUtilInspectCustom = Symbol.for('nodejs.util.inspect.custom');\n\n/**\n * VMError.\n *\n * @public\n * @extends {Error}\n */\nclass VMError extends Error {\n\n\t/**\n\t * Create VMError instance.\n\t *\n\t * @public\n\t * @param {string} message - Error message.\n\t * @param {string} code - Error code.\n\t */\n\tconstructor(message, code) {\n\t\tsuper(message);\n\n\t\tthis.name = 'VMError';\n\t\tthis.code = code;\n\n\t\tthisErrorCaptureStackTrace(this, this.constructor);\n\t}\n}\n\nthisGlobalPrototypes['VMError'] = VMError.prototype;\n\nfunction thisUnexpected() {\n\treturn new VMError('Unexpected');\n}\n\nif (!thisReflectSetPrototypeOf(exports, null)) throw thisUnexpected();\n\nfunction thisSafeGetOwnPropertyDescriptor(obj, key) {\n\tconst desc = thisReflectGetOwnPropertyDescriptor(obj, key);\n\tif (!desc) return desc;\n\tif (!thisReflectSetPrototypeOf(desc, null)) throw thisUnexpected();\n\treturn desc;\n}\n\nfunction thisThrowCallerCalleeArgumentsAccess(key) {\n\t\n\tthisThrowCallerCalleeArgumentsAccess[key];\n\treturn thisUnexpected();\n}\n\nfunction thisIdMapping(factory, other) {\n\treturn other;\n}\n\nconst thisThrowOnKeyAccessHandler = thisObjectFreeze({\n\t__proto__: null,\n\tget(target, key, receiver) {\n\t\tif (typeof key === 'symbol') {\n\t\t\tkey = thisReflectApply(thisSymbolToString, key, []);\n\t\t}\n\t\tthrow new VMError(`Unexpected access to key '${key}'`);\n\t}\n});\n\nconst emptyForzenObject = thisObjectFreeze({\n\t__proto__: null\n});\n\nconst thisThrowOnKeyAccess = new ThisProxy(emptyForzenObject, thisThrowOnKeyAccessHandler);\n\nfunction SafeBase() {}\n\nif (!thisReflectDefineProperty(SafeBase, 'prototype', {\n\t__proto__: null,\n\tvalue: thisThrowOnKeyAccess\n})) throw thisUnexpected();\n\nfunction SHARED_FUNCTION() {}\n\nconst TEST_PROXY_HANDLER = thisObjectFreeze({\n\t__proto__: thisThrowOnKeyAccess,\n\tconstruct() {\n\t\treturn this;\n\t}\n});\n\nfunction thisIsConstructor(obj) {\n\t// Note: obj@any(unsafe)\n\tconst Func = new ThisProxy(obj, TEST_PROXY_HANDLER);\n\ttry {\n\t\t// eslint-disable-next-line no-new\n\t\tnew Func();\n\t\treturn true;\n\t} catch (e) {\n\t\treturn false;\n\t}\n}\n\nfunction thisCreateTargetObject(obj, proto) {\n\t// Note: obj@any(unsafe) proto@any(unsafe) returns@this(unsafe) throws@this(unsafe)\n\tlet base;\n\tif (typeof obj === 'function') {\n\t\tif (thisIsConstructor(obj)) {\n\t\t\t// Bind the function since bound functions do not have a prototype property.\n\t\t\tbase = thisReflectApply(thisFunctionBind, SHARED_FUNCTION, [null]);\n\t\t} else {\n\t\t\tbase = () => {};\n\t\t}\n\t} else if (thisArrayIsArray(obj)) {\n\t\tbase = [];\n\t} else {\n\t\treturn {__proto__: proto};\n\t}\n\tif (!thisReflectSetPrototypeOf(base, proto)) throw thisUnexpected();\n\treturn base;\n}\n\nfunction createBridge(otherInit, registerProxy) {\n\n\tconst mappingOtherToThis = new ThisWeakMap();\n\tconst protoMappings = new ThisMap();\n\tconst protoName = new ThisMap();\n\n\tfunction thisAddProtoMapping(proto, other, name) {\n\t\t// Note: proto@this(unsafe) other@other(unsafe) name@this(unsafe) throws@this(unsafe)\n\t\tthisReflectApply(thisMapSet, protoMappings, [proto, thisIdMapping]);\n\t\tthisReflectApply(thisMapSet, protoMappings, [other,\n\t\t\t(factory, object) => thisProxyOther(factory, object, proto)]);\n\t\tif (name) thisReflectApply(thisMapSet, protoName, [proto, name]);\n\t}\n\n\tfunction thisAddProtoMappingFactory(protoFactory, other, name) {\n\t\t// Note: protoFactory@this(unsafe) other@other(unsafe) name@this(unsafe) throws@this(unsafe)\n\t\tlet proto;\n\t\tthisReflectApply(thisMapSet, protoMappings, [other,\n\t\t\t(factory, object) => {\n\t\t\t\tif (!proto) {\n\t\t\t\t\tproto = protoFactory();\n\t\t\t\t\tthisReflectApply(thisMapSet, protoMappings, [proto, thisIdMapping]);\n\t\t\t\t\tif (name) thisReflectApply(thisMapSet, protoName, [proto, name]);\n\t\t\t\t}\n\t\t\t\treturn thisProxyOther(factory, object, proto);\n\t\t\t}]);\n\t}\n\n\tconst result = {\n\t\t__proto__: null,\n\t\tglobalPrototypes: thisGlobalPrototypes,\n\t\tsafeGetOwnPropertyDescriptor: thisSafeGetOwnPropertyDescriptor,\n\t\tfromArguments: thisFromOtherArguments,\n\t\tfrom: thisFromOther,\n\t\tfromWithFactory: thisFromOtherWithFactory,\n\t\tensureThis: thisEnsureThis,\n\t\tmapping: mappingOtherToThis,\n\t\tconnect: thisConnect,\n\t\treflectSet: thisReflectSet,\n\t\treflectGet: thisReflectGet,\n\t\treflectDefineProperty: thisReflectDefineProperty,\n\t\treflectDeleteProperty: thisReflectDeleteProperty,\n\t\treflectApply: thisReflectApply,\n\t\treflectConstruct: thisReflectConstruct,\n\t\treflectHas: thisReflectHas,\n\t\treflectOwnKeys: thisReflectOwnKeys,\n\t\treflectEnumerate: thisReflectEnumerate,\n\t\treflectGetPrototypeOf: thisReflectGetPrototypeOf,\n\t\treflectIsExtensible: thisReflectIsExtensible,\n\t\treflectPreventExtensions: thisReflectPreventExtensions,\n\t\tobjectHasOwnProperty: thisObjectHasOwnProperty,\n\t\tweakMapSet: thisWeakMapSet,\n\t\taddProtoMapping: thisAddProtoMapping,\n\t\taddProtoMappingFactory: thisAddProtoMappingFactory,\n\t\tdefaultFactory,\n\t\tprotectedFactory,\n\t\treadonlyFactory,\n\t\tVMError\n\t};\n\n\tconst isHost = typeof otherInit !== 'object';\n\n\tif (isHost) {\n\t\totherInit = otherInit(result, registerProxy);\n\t}\n\n\tresult.other = otherInit;\n\n\tconst {\n\t\tglobalPrototypes: otherGlobalPrototypes,\n\t\tsafeGetOwnPropertyDescriptor: otherSafeGetOwnPropertyDescriptor,\n\t\tfromArguments: otherFromThisArguments,\n\t\tfrom: otherFromThis,\n\t\tmapping: mappingThisToOther,\n\t\treflectSet: otherReflectSet,\n\t\treflectGet: otherReflectGet,\n\t\treflectDefineProperty: otherReflectDefineProperty,\n\t\treflectDeleteProperty: otherReflectDeleteProperty,\n\t\treflectApply: otherReflectApply,\n\t\treflectConstruct: otherReflectConstruct,\n\t\treflectHas: otherReflectHas,\n\t\treflectOwnKeys: otherReflectOwnKeys,\n\t\treflectEnumerate: otherReflectEnumerate,\n\t\treflectGetPrototypeOf: otherReflectGetPrototypeOf,\n\t\treflectIsExtensible: otherReflectIsExtensible,\n\t\treflectPreventExtensions: otherReflectPreventExtensions,\n\t\tobjectHasOwnProperty: otherObjectHasOwnProperty,\n\t\tweakMapSet: otherWeakMapSet\n\t} = otherInit;\n\n\tfunction thisOtherHasOwnProperty(object, key) {\n\t\t// Note: object@other(safe) key@prim throws@this(unsafe)\n\t\ttry {\n\t\t\treturn otherReflectApply(otherObjectHasOwnProperty, object, [key]) === true;\n\t\t} catch (e) { // @other(unsafe)\n\t\t\tthrow thisFromOtherForThrow(e);\n\t\t}\n\t}\n\n\tfunction thisDefaultGet(handler, object, key, desc) {\n\t\t// Note: object@other(unsafe) key@prim desc@other(safe)\n\t\tlet ret; // @other(unsafe)\n\t\tif (desc.get || desc.set) {\n\t\t\tconst getter = desc.get;\n\t\t\tif (!getter) return undefined;\n\t\t\ttry {\n\t\t\t\tret = otherReflectApply(getter, object, [key]);\n\t\t\t} catch (e) {\n\t\t\t\tthrow thisFromOtherForThrow(e);\n\t\t\t}\n\t\t} else {\n\t\t\tret = desc.value;\n\t\t}\n\t\treturn handler.fromOtherWithContext(ret);\n\t}\n\n\tfunction otherFromThisIfAvailable(to, from, key) {\n\t\t// Note: to@other(safe) from@this(safe) key@prim throws@this(unsafe)\n\t\tif (!thisReflectApply(thisObjectHasOwnProperty, from, [key])) return false;\n\t\ttry {\n\t\t\tto[key] = otherFromThis(from[key]);\n\t\t} catch (e) { // @other(unsafe)\n\t\t\tthrow thisFromOtherForThrow(e);\n\t\t}\n\t\treturn true;\n\t}\n\n\tclass BaseHandler extends SafeBase {\n\n\t\tconstructor(object) {\n\t\t\t// Note: object@other(unsafe) throws@this(unsafe)\n\t\t\tsuper();\n\t\t\tthis.objectWrapper = () => object;\n\t\t}\n\n\t\tgetObject() {\n\t\t\treturn this.objectWrapper();\n\t\t}\n\n\t\tgetFactory() {\n\t\t\treturn defaultFactory;\n\t\t}\n\n\t\tfromOtherWithContext(other) {\n\t\t\t// Note: other@other(unsafe) throws@this(unsafe)\n\t\t\treturn thisFromOtherWithFactory(this.getFactory(), other);\n\t\t}\n\n\t\tdoPreventExtensions(target, object, factory) {\n\t\t\t// Note: target@this(unsafe) object@other(unsafe) throws@this(unsafe)\n\t\t\tlet keys; // @other(safe-array-of-prim)\n\t\t\ttry {\n\t\t\t\tkeys = otherReflectOwnKeys(object);\n\t\t\t} catch (e) { // @other(unsafe)\n\t\t\t\tthrow thisFromOtherForThrow(e);\n\t\t\t}\n\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\tconst key = keys[i]; // @prim\n\t\t\t\tlet desc;\n\t\t\t\ttry {\n\t\t\t\t\tdesc = otherSafeGetOwnPropertyDescriptor(object, key);\n\t\t\t\t} catch (e) { // @other(unsafe)\n\t\t\t\t\tthrow thisFromOtherForThrow(e);\n\t\t\t\t}\n\t\t\t\tif (!desc) continue;\n\t\t\t\tif (!desc.configurable) {\n\t\t\t\t\tconst current = thisSafeGetOwnPropertyDescriptor(target, key);\n\t\t\t\t\tif (current && !current.configurable) continue;\n\t\t\t\t\tif (desc.get || desc.set) {\n\t\t\t\t\t\tdesc.get = this.fromOtherWithContext(desc.get);\n\t\t\t\t\t\tdesc.set = this.fromOtherWithContext(desc.set);\n\t\t\t\t\t} else if (typeof object === 'function' && (key === 'caller' || key === 'callee' || key === 'arguments')) {\n\t\t\t\t\t\tdesc.value = null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdesc.value = this.fromOtherWithContext(desc.value);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (desc.get || desc.set) {\n\t\t\t\t\t\tdesc = {\n\t\t\t\t\t\t\t__proto__: null,\n\t\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\t\tenumerable: desc.enumerable,\n\t\t\t\t\t\t\twritable: true,\n\t\t\t\t\t\t\tvalue: null\n\t\t\t\t\t\t};\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdesc.value = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!thisReflectDefineProperty(target, key, desc)) throw thisUnexpected();\n\t\t\t}\n\t\t\tif (!thisReflectPreventExtensions(target)) throw thisUnexpected();\n\t\t}\n\n\t\tget(target, key, receiver) {\n\t\t\t// Note: target@this(unsafe) key@prim receiver@this(unsafe) throws@this(unsafe)\n\t\t\tconst object = this.getObject(); // @other(unsafe)\n\t\t\tswitch (key) {\n\t\t\t\tcase 'constructor': {\n\t\t\t\t\tconst desc = otherSafeGetOwnPropertyDescriptor(object, key);\n\t\t\t\t\tif (desc) return thisDefaultGet(this, object, key, desc);\n\t\t\t\t\tconst proto = thisReflectGetPrototypeOf(target);\n\t\t\t\t\treturn proto === null ? undefined : proto.constructor;\n\t\t\t\t}\n\t\t\t\tcase '__proto__': {\n\t\t\t\t\tconst desc = otherSafeGetOwnPropertyDescriptor(object, key);\n\t\t\t\t\tif (desc) return thisDefaultGet(this, object, key, desc);\n\t\t\t\t\treturn thisReflectGetPrototypeOf(target);\n\t\t\t\t}\n\t\t\t\tcase thisSymbolToStringTag:\n\t\t\t\t\tif (!thisOtherHasOwnProperty(object, thisSymbolToStringTag)) {\n\t\t\t\t\t\tconst proto = thisReflectGetPrototypeOf(target);\n\t\t\t\t\t\tconst name = thisReflectApply(thisMapGet, protoName, [proto]);\n\t\t\t\t\t\tif (name) return name;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'arguments':\n\t\t\t\tcase 'caller':\n\t\t\t\tcase 'callee':\n\t\t\t\t\tif (typeof object === 'function' && thisOtherHasOwnProperty(object, key)) {\n\t\t\t\t\t\tthrow thisThrowCallerCalleeArgumentsAccess(key);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlet ret; // @other(unsafe)\n\t\t\ttry {\n\t\t\t\tret = otherReflectGet(object, key);\n\t\t\t} catch (e) { // @other(unsafe)\n\t\t\t\tthrow thisFromOtherForThrow(e);\n\t\t\t}\n\t\t\treturn this.fromOtherWithContext(ret);\n\t\t}\n\n\t\tset(target, key, value, receiver) {\n\t\t\t// Note: target@this(unsafe) key@prim value@this(unsafe) receiver@this(unsafe) throws@this(unsafe)\n\t\t\tconst object = this.getObject(); // @other(unsafe)\n\t\t\tif (key === '__proto__' && !thisOtherHasOwnProperty(object, key)) {\n\t\t\t\treturn this.setPrototypeOf(target, value);\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tvalue = otherFromThis(value);\n\t\t\t\treturn otherReflectSet(object, key, value) === true;\n\t\t\t} catch (e) { // @other(unsafe)\n\t\t\t\tthrow thisFromOtherForThrow(e);\n\t\t\t}\n\t\t}\n\n\t\tgetPrototypeOf(target) {\n\t\t\t// Note: target@this(unsafe)\n\t\t\treturn thisReflectGetPrototypeOf(target);\n\t\t}\n\n\t\tsetPrototypeOf(target, value) {\n\t\t\t// Note: target@this(unsafe) throws@this(unsafe)\n\t\t\tthrow new VMError(OPNA);\n\t\t}\n\n\t\tapply(target, context, args) {\n\t\t\t// Note: target@this(unsafe) context@this(unsafe) args@this(safe-array) throws@this(unsafe)\n\t\t\tconst object = this.getObject(); // @other(unsafe)\n\t\t\tlet ret; // @other(unsafe)\n\t\t\ttry {\n\t\t\t\tcontext = otherFromThis(context);\n\t\t\t\targs = otherFromThisArguments(args);\n\t\t\t\tret = otherReflectApply(object, context, args);\n\t\t\t} catch (e) { // @other(unsafe)\n\t\t\t\tthrow thisFromOtherForThrow(e);\n\t\t\t}\n\t\t\treturn thisFromOther(ret);\n\t\t}\n\n\t\tconstruct(target, args, newTarget) {\n\t\t\t// Note: target@this(unsafe) args@this(safe-array) newTarget@this(unsafe) throws@this(unsafe)\n\t\t\tconst object = this.getObject(); // @other(unsafe)\n\t\t\tlet ret; // @other(unsafe)\n\t\t\ttry {\n\t\t\t\targs = otherFromThisArguments(args);\n\t\t\t\tret = otherReflectConstruct(object, args);\n\t\t\t} catch (e) { // @other(unsafe)\n\t\t\t\tthrow thisFromOtherForThrow(e);\n\t\t\t}\n\t\t\treturn thisFromOtherWithFactory(this.getFactory(), ret, thisFromOther(object));\n\t\t}\n\n\t\tgetOwnPropertyDescriptorDesc(target, prop, desc) {\n\t\t\t// Note: target@this(unsafe) prop@prim desc@other{safe} throws@this(unsafe)\n\t\t\tconst object = this.getObject(); // @other(unsafe)\n\t\t\tif (desc && typeof object === 'function' && (prop === 'arguments' || prop === 'caller' || prop === 'callee')) desc.value = null;\n\t\t\treturn desc;\n\t\t}\n\n\t\tgetOwnPropertyDescriptor(target, prop) {\n\t\t\t// Note: target@this(unsafe) prop@prim throws@this(unsafe)\n\t\t\tconst object = this.getObject(); // @other(unsafe)\n\t\t\tlet desc; // @other(safe)\n\t\t\ttry {\n\t\t\t\tdesc = otherSafeGetOwnPropertyDescriptor(object, prop);\n\t\t\t} catch (e) { // @other(unsafe)\n\t\t\t\tthrow thisFromOtherForThrow(e);\n\t\t\t}\n\n\t\t\tdesc = this.getOwnPropertyDescriptorDesc(target, prop, desc);\n\n\t\t\tif (!desc) return undefined;\n\n\t\t\tlet thisDesc;\n\t\t\tif (desc.get || desc.set) {\n\t\t\t\tthisDesc = {\n\t\t\t\t\t__proto__: null,\n\t\t\t\t\tget: this.fromOtherWithContext(desc.get),\n\t\t\t\t\tset: this.fromOtherWithContext(desc.set),\n\t\t\t\t\tenumerable: desc.enumerable === true,\n\t\t\t\t\tconfigurable: desc.configurable === true\n\t\t\t\t};\n\t\t\t} else {\n\t\t\t\tthisDesc = {\n\t\t\t\t\t__proto__: null,\n\t\t\t\t\tvalue: this.fromOtherWithContext(desc.value),\n\t\t\t\t\twritable: desc.writable === true,\n\t\t\t\t\tenumerable: desc.enumerable === true,\n\t\t\t\t\tconfigurable: desc.configurable === true\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (!thisDesc.configurable) {\n\t\t\t\tconst oldDesc = thisSafeGetOwnPropertyDescriptor(target, prop);\n\t\t\t\tif (!oldDesc || oldDesc.configurable || oldDesc.writable !== thisDesc.writable) {\n\t\t\t\t\tif (!thisReflectDefineProperty(target, prop, thisDesc)) throw thisUnexpected();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn thisDesc;\n\t\t}\n\n\t\tdefinePropertyDesc(target, prop, desc) {\n\t\t\t// Note: target@this(unsafe) prop@prim desc@this(safe) throws@this(unsafe)\n\t\t\treturn desc;\n\t\t}\n\n\t\tdefineProperty(target, prop, desc) {\n\t\t\t// Note: target@this(unsafe) prop@prim desc@this(unsafe) throws@this(unsafe)\n\t\t\tconst object = this.getObject(); // @other(unsafe)\n\t\t\tif (!thisReflectSetPrototypeOf(desc, null)) throw thisUnexpected();\n\n\t\t\tdesc = this.definePropertyDesc(target, prop, desc);\n\n\t\t\tif (!desc) return false;\n\n\t\t\tlet otherDesc = {__proto__: null};\n\t\t\tlet hasFunc = true;\n\t\t\tlet hasValue = true;\n\t\t\tlet hasBasic = true;\n\t\t\thasFunc &= otherFromThisIfAvailable(otherDesc, desc, 'get');\n\t\t\thasFunc &= otherFromThisIfAvailable(otherDesc, desc, 'set');\n\t\t\thasValue &= otherFromThisIfAvailable(otherDesc, desc, 'value');\n\t\t\thasValue &= otherFromThisIfAvailable(otherDesc, desc, 'writable');\n\t\t\thasBasic &= otherFromThisIfAvailable(otherDesc, desc, 'enumerable');\n\t\t\thasBasic &= otherFromThisIfAvailable(otherDesc, desc, 'configurable');\n\n\t\t\ttry {\n\t\t\t\tif (!otherReflectDefineProperty(object, prop, otherDesc)) return false;\n\t\t\t\tif (otherDesc.configurable !== true && (!hasBasic || !(hasFunc || hasValue))) {\n\t\t\t\t\totherDesc = otherSafeGetOwnPropertyDescriptor(object, prop);\n\t\t\t\t}\n\t\t\t} catch (e) { // @other(unsafe)\n\t\t\t\tthrow thisFromOtherForThrow(e);\n\t\t\t}\n\n\t\t\tif (!otherDesc.configurable) {\n\t\t\t\tlet thisDesc;\n\t\t\t\tif (otherDesc.get || otherDesc.set) {\n\t\t\t\t\tthisDesc = {\n\t\t\t\t\t\t__proto__: null,\n\t\t\t\t\t\tget: this.fromOtherWithContext(otherDesc.get),\n\t\t\t\t\t\tset: this.fromOtherWithContext(otherDesc.set),\n\t\t\t\t\t\tenumerable: otherDesc.enumerable,\n\t\t\t\t\t\tconfigurable: otherDesc.configurable\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tthisDesc = {\n\t\t\t\t\t\t__proto__: null,\n\t\t\t\t\t\tvalue: this.fromOtherWithContext(otherDesc.value),\n\t\t\t\t\t\twritable: otherDesc.writable,\n\t\t\t\t\t\tenumerable: otherDesc.enumerable,\n\t\t\t\t\t\tconfigurable: otherDesc.configurable\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (!thisReflectDefineProperty(target, prop, thisDesc)) throw thisUnexpected();\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tdeleteProperty(target, prop) {\n\t\t\t// Note: target@this(unsafe) prop@prim throws@this(unsafe)\n\t\t\tconst object = this.getObject(); // @other(unsafe)\n\t\t\ttry {\n\t\t\t\treturn otherReflectDeleteProperty(object, prop) === true;\n\t\t\t} catch (e) { // @other(unsafe)\n\t\t\t\tthrow thisFromOtherForThrow(e);\n\t\t\t}\n\t\t}\n\n\t\thas(target, key) {\n\t\t\t// Note: target@this(unsafe) key@prim throws@this(unsafe)\n\t\t\tconst object = this.getObject(); // @other(unsafe)\n\t\t\ttry {\n\t\t\t\treturn otherReflectHas(object, key) === true;\n\t\t\t} catch (e) { // @other(unsafe)\n\t\t\t\tthrow thisFromOtherForThrow(e);\n\t\t\t}\n\t\t}\n\n\t\tisExtensible(target) {\n\t\t\t// Note: target@this(unsafe) throws@this(unsafe)\n\t\t\tconst object = this.getObject(); // @other(unsafe)\n\t\t\ttry {\n\t\t\t\tif (otherReflectIsExtensible(object)) return true;\n\t\t\t} catch (e) { // @other(unsafe)\n\t\t\t\tthrow thisFromOtherForThrow(e);\n\t\t\t}\n\t\t\tif (thisReflectIsExtensible(target)) {\n\t\t\t\tthis.doPreventExtensions(target, object, this);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\townKeys(target) {\n\t\t\t// Note: target@this(unsafe) throws@this(unsafe)\n\t\t\tconst object = this.getObject(); // @other(unsafe)\n\t\t\tlet res; // @other(unsafe)\n\t\t\ttry {\n\t\t\t\tres = otherReflectOwnKeys(object);\n\t\t\t} catch (e) { // @other(unsafe)\n\t\t\t\tthrow thisFromOtherForThrow(e);\n\t\t\t}\n\t\t\treturn thisFromOther(res);\n\t\t}\n\n\t\tpreventExtensions(target) {\n\t\t\t// Note: target@this(unsafe) throws@this(unsafe)\n\t\t\tconst object = this.getObject(); // @other(unsafe)\n\t\t\ttry {\n\t\t\t\tif (!otherReflectPreventExtensions(object)) return false;\n\t\t\t} catch (e) { // @other(unsafe)\n\t\t\t\tthrow thisFromOtherForThrow(e);\n\t\t\t}\n\t\t\tif (thisReflectIsExtensible(target)) {\n\t\t\t\tthis.doPreventExtensions(target, object, this);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tenumerate(target) {\n\t\t\t// Note: target@this(unsafe) throws@this(unsafe)\n\t\t\tconst object = this.getObject(); // @other(unsafe)\n\t\t\tlet res; // @other(unsafe)\n\t\t\ttry {\n\t\t\t\tres = otherReflectEnumerate(object);\n\t\t\t} catch (e) { // @other(unsafe)\n\t\t\t\tthrow thisFromOtherForThrow(e);\n\t\t\t}\n\t\t\treturn this.fromOtherWithContext(res);\n\t\t}\n\n\t}\n\n\tBaseHandler.prototype[thisSymbolNodeJSUtilInspectCustom] = undefined;\n\tBaseHandler.prototype[thisSymbolToStringTag] = 'VM2 Wrapper';\n\tBaseHandler.prototype[thisSymbolIterator] = undefined;\n\n\tfunction defaultFactory(object) {\n\t\t// Note: other@other(unsafe) returns@this(unsafe) throws@this(unsafe)\n\t\treturn new BaseHandler(object);\n\t}\n\n\tclass ProtectedHandler extends BaseHandler {\n\n\t\tgetFactory() {\n\t\t\treturn protectedFactory;\n\t\t}\n\n\t\tset(target, key, value, receiver) {\n\t\t\t// Note: target@this(unsafe) key@prim value@this(unsafe) receiver@this(unsafe) throws@this(unsafe)\n\t\t\tif (typeof value === 'function') {\n\t\t\t\treturn thisReflectDefineProperty(receiver, key, {\n\t\t\t\t\t__proto__: null,\n\t\t\t\t\tvalue: value,\n\t\t\t\t\twritable: true,\n\t\t\t\t\tenumerable: true,\n\t\t\t\t\tconfigurable: true\n\t\t\t\t}) === true;\n\t\t\t}\n\t\t\treturn super.set(target, key, value, receiver);\n\t\t}\n\n\t\tdefinePropertyDesc(target, prop, desc) {\n\t\t\t// Note: target@this(unsafe) prop@prim desc@this(safe) throws@this(unsafe)\n\t\t\tif (desc && (desc.set || desc.get || typeof desc.value === 'function')) return undefined;\n\t\t\treturn desc;\n\t\t}\n\n\t}\n\n\tfunction protectedFactory(object) {\n\t\t// Note: other@other(unsafe) returns@this(unsafe) throws@this(unsafe)\n\t\treturn new ProtectedHandler(object);\n\t}\n\n\tclass ReadOnlyHandler extends BaseHandler {\n\n\t\tgetFactory() {\n\t\t\treturn readonlyFactory;\n\t\t}\n\n\t\tset(target, key, value, receiver) {\n\t\t\t// Note: target@this(unsafe) key@prim value@this(unsafe) receiver@this(unsafe) throws@this(unsafe)\n\t\t\treturn thisReflectDefineProperty(receiver, key, {\n\t\t\t\t__proto__: null,\n\t\t\t\tvalue: value,\n\t\t\t\twritable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true\n\t\t\t});\n\t\t}\n\n\t\tsetPrototypeOf(target, value) {\n\t\t\t// Note: target@this(unsafe) throws@this(unsafe)\n\t\t\treturn false;\n\t\t}\n\n\t\tdefineProperty(target, prop, desc) {\n\t\t\t// Note: target@this(unsafe) prop@prim desc@this(unsafe) throws@this(unsafe)\n\t\t\treturn false;\n\t\t}\n\n\t\tdeleteProperty(target, prop) {\n\t\t\t// Note: target@this(unsafe) prop@prim throws@this(unsafe)\n\t\t\treturn false;\n\t\t}\n\n\t\tisExtensible(target) {\n\t\t\t// Note: target@this(unsafe) throws@this(unsafe)\n\t\t\treturn false;\n\t\t}\n\n\t\tpreventExtensions(target) {\n\t\t\t// Note: target@this(unsafe) throws@this(unsafe)\n\t\t\treturn false;\n\t\t}\n\n\t}\n\n\tfunction readonlyFactory(object) {\n\t\t// Note: other@other(unsafe) returns@this(unsafe) throws@this(unsafe)\n\t\treturn new ReadOnlyHandler(object);\n\t}\n\n\tclass ReadOnlyMockHandler extends ReadOnlyHandler {\n\n\t\tconstructor(object, mock) {\n\t\t\t// Note: object@other(unsafe) mock:this(unsafe) throws@this(unsafe)\n\t\t\tsuper(object);\n\t\t\tthis.mock = mock;\n\t\t}\n\n\t\tget(target, key, receiver) {\n\t\t\t// Note: target@this(unsafe) key@prim receiver@this(unsafe) throws@this(unsafe)\n\t\t\tconst object = this.getObject(); // @other(unsafe)\n\t\t\tconst mock = this.mock;\n\t\t\tif (thisReflectApply(thisObjectHasOwnProperty, mock, key) && !thisOtherHasOwnProperty(object, key)) {\n\t\t\t\treturn mock[key];\n\t\t\t}\n\t\t\treturn super.get(target, key, receiver);\n\t\t}\n\n\t}\n\n\tfunction thisFromOther(other) {\n\t\t// Note: other@other(unsafe) returns@this(unsafe) throws@this(unsafe)\n\t\treturn thisFromOtherWithFactory(defaultFactory, other);\n\t}\n\n\tfunction thisProxyOther(factory, other, proto) {\n\t\tconst target = thisCreateTargetObject(other, proto);\n\t\tconst handler = factory(other);\n\t\tconst proxy = new ThisProxy(target, handler);\n\t\ttry {\n\t\t\totherReflectApply(otherWeakMapSet, mappingThisToOther, [proxy, other]);\n\t\t\tregisterProxy(proxy, handler);\n\t\t} catch (e) {\n\t\t\tthrow new VMError('Unexpected error');\n\t\t}\n\t\tif (!isHost) {\n\t\t\tthisReflectApply(thisWeakMapSet, mappingOtherToThis, [other, proxy]);\n\t\t\treturn proxy;\n\t\t}\n\t\tconst proxy2 = new ThisProxy(proxy, emptyForzenObject);\n\t\ttry {\n\t\t\totherReflectApply(otherWeakMapSet, mappingThisToOther, [proxy2, other]);\n\t\t\tregisterProxy(proxy2, handler);\n\t\t} catch (e) {\n\t\t\tthrow new VMError('Unexpected error');\n\t\t}\n\t\tthisReflectApply(thisWeakMapSet, mappingOtherToThis, [other, proxy2]);\n\t\treturn proxy2;\n\t}\n\n\tfunction thisEnsureThis(other) {\n\t\tconst type = typeof other;\n\t\tswitch (type) {\n\t\t\tcase 'object':\n\t\t\t\tif (other === null) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t// fallthrough\n\t\t\tcase 'function':\n\t\t\t\tlet proto = thisReflectGetPrototypeOf(other);\n\t\t\t\tif (!proto) {\n\t\t\t\t\treturn other;\n\t\t\t\t}\n\t\t\t\twhile (proto) {\n\t\t\t\t\tconst mapping = thisReflectApply(thisMapGet, protoMappings, [proto]);\n\t\t\t\t\tif (mapping) {\n\t\t\t\t\t\tconst mapped = thisReflectApply(thisWeakMapGet, mappingOtherToThis, [other]);\n\t\t\t\t\t\tif (mapped) return mapped;\n\t\t\t\t\t\treturn mapping(defaultFactory, other);\n\t\t\t\t\t}\n\t\t\t\t\tproto = thisReflectGetPrototypeOf(proto);\n\t\t\t\t}\n\t\t\t\treturn other;\n\t\t\tcase 'undefined':\n\t\t\tcase 'string':\n\t\t\tcase 'number':\n\t\t\tcase 'boolean':\n\t\t\tcase 'symbol':\n\t\t\tcase 'bigint':\n\t\t\t\treturn other;\n\n\t\t\tdefault: // new, unknown types can be dangerous\n\t\t\t\tthrow new VMError(`Unknown type '${type}'`);\n\t\t}\n\t}\n\n\tfunction thisFromOtherForThrow(other) {\n\t\tfor (let loop = 0; loop < 10; loop++) {\n\t\t\tconst type = typeof other;\n\t\t\tswitch (type) {\n\t\t\t\tcase 'object':\n\t\t\t\t\tif (other === null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\t// fallthrough\n\t\t\t\tcase 'function':\n\t\t\t\t\tconst mapped = thisReflectApply(thisWeakMapGet, mappingOtherToThis, [other]);\n\t\t\t\t\tif (mapped) return mapped;\n\t\t\t\t\tlet proto;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tproto = otherReflectGetPrototypeOf(other);\n\t\t\t\t\t} catch (e) { // @other(unsafe)\n\t\t\t\t\t\tother = e;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (!proto) {\n\t\t\t\t\t\treturn thisProxyOther(defaultFactory, other, null);\n\t\t\t\t\t}\n\t\t\t\t\tfor (;;) {\n\t\t\t\t\t\tconst mapping = thisReflectApply(thisMapGet, protoMappings, [proto]);\n\t\t\t\t\t\tif (mapping) return mapping(defaultFactory, other);\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tproto = otherReflectGetPrototypeOf(proto);\n\t\t\t\t\t\t} catch (e) { // @other(unsafe)\n\t\t\t\t\t\t\tother = e;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!proto) return thisProxyOther(defaultFactory, other, thisObjectPrototype);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'undefined':\n\t\t\t\tcase 'string':\n\t\t\t\tcase 'number':\n\t\t\t\tcase 'boolean':\n\t\t\t\tcase 'symbol':\n\t\t\t\tcase 'bigint':\n\t\t\t\t\treturn other;\n\n\t\t\t\tdefault: // new, unknown types can be dangerous\n\t\t\t\t\tthrow new VMError(`Unknown type '${type}'`);\n\t\t\t}\n\t\t}\n\t\tthrow new VMError('Exception recursion depth');\n\t}\n\n\tfunction thisFromOtherWithFactory(factory, other, proto) {\n\t\tconst type = typeof other;\n\t\tswitch (type) {\n\t\t\tcase 'object':\n\t\t\t\tif (other === null) {\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\t// fallthrough\n\t\t\tcase 'function':\n\t\t\t\tconst mapped = thisReflectApply(thisWeakMapGet, mappingOtherToThis, [other]);\n\t\t\t\tif (mapped) return mapped;\n\t\t\t\tif (proto) {\n\t\t\t\t\treturn thisProxyOther(factory, other, proto);\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\tproto = otherReflectGetPrototypeOf(other);\n\t\t\t\t} catch (e) { // @other(unsafe)\n\t\t\t\t\tthrow thisFromOtherForThrow(e);\n\t\t\t\t}\n\t\t\t\tif (!proto) {\n\t\t\t\t\treturn thisProxyOther(factory, other, null);\n\t\t\t\t}\n\t\t\t\tdo {\n\t\t\t\t\tconst mapping = thisReflectApply(thisMapGet, protoMappings, [proto]);\n\t\t\t\t\tif (mapping) return mapping(factory, other);\n\t\t\t\t\ttry {\n\t\t\t\t\t\tproto = otherReflectGetPrototypeOf(proto);\n\t\t\t\t\t} catch (e) { // @other(unsafe)\n\t\t\t\t\t\tthrow thisFromOtherForThrow(e);\n\t\t\t\t\t}\n\t\t\t\t} while (proto);\n\t\t\t\treturn thisProxyOther(factory, other, thisObjectPrototype);\n\t\t\tcase 'undefined':\n\t\t\tcase 'string':\n\t\t\tcase 'number':\n\t\t\tcase 'boolean':\n\t\t\tcase 'symbol':\n\t\t\tcase 'bigint':\n\t\t\t\treturn other;\n\n\t\t\tdefault: // new, unknown types can be dangerous\n\t\t\t\tthrow new VMError(`Unknown type '${type}'`);\n\t\t}\n\t}\n\n\tfunction thisFromOtherArguments(args) {\n\t\t// Note: args@other(safe-array) returns@this(safe-array) throws@this(unsafe)\n\t\tconst arr = [];\n\t\tfor (let i = 0; i < args.length; i++) {\n\t\t\tconst value = thisFromOther(args[i]);\n\t\t\tthisReflectDefineProperty(arr, i, {\n\t\t\t\t__proto__: null,\n\t\t\t\tvalue: value,\n\t\t\t\twritable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tconfigurable: true\n\t\t\t});\n\t\t}\n\t\treturn arr;\n\t}\n\n\tfunction thisConnect(obj, other) {\n\t\t// Note: obj@this(unsafe) other@other(unsafe) throws@this(unsafe)\n\t\ttry {\n\t\t\totherReflectApply(otherWeakMapSet, mappingThisToOther, [obj, other]);\n\t\t} catch (e) {\n\t\t\tthrow new VMError('Unexpected error');\n\t\t}\n\t\tthisReflectApply(thisWeakMapSet, mappingOtherToThis, [other, obj]);\n\t}\n\n\tthisAddProtoMapping(thisGlobalPrototypes.Object, otherGlobalPrototypes.Object);\n\tthisAddProtoMapping(thisGlobalPrototypes.Array, otherGlobalPrototypes.Array);\n\n\tfor (let i = 0; i < globalsList.length; i++) {\n\t\tconst key = globalsList[i];\n\t\tconst tp = thisGlobalPrototypes[key];\n\t\tconst op = otherGlobalPrototypes[key];\n\t\tif (tp && op) thisAddProtoMapping(tp, op, key);\n\t}\n\n\tfor (let i = 0; i < errorsList.length; i++) {\n\t\tconst key = errorsList[i];\n\t\tconst tp = thisGlobalPrototypes[key];\n\t\tconst op = otherGlobalPrototypes[key];\n\t\tif (tp && op) thisAddProtoMapping(tp, op, 'Error');\n\t}\n\n\tthisAddProtoMapping(thisGlobalPrototypes.VMError, otherGlobalPrototypes.VMError, 'Error');\n\n\tresult.BaseHandler = BaseHandler;\n\tresult.ProtectedHandler = ProtectedHandler;\n\tresult.ReadOnlyHandler = ReadOnlyHandler;\n\tresult.ReadOnlyMockHandler = ReadOnlyMockHandler;\n\n\treturn result;\n}\n\nexports.createBridge = createBridge;\nexports.VMError = VMError;\n","\n\nconst {Script} = require('vm');\nconst {\n\tlookupCompiler,\n\tremoveShebang\n} = require('./compiler');\nconst {\n\ttransformer\n} = require('./transformer');\n\nconst objectDefineProperties = Object.defineProperties;\n\nconst MODULE_PREFIX = '(function (exports, require, module, __filename, __dirname) { ';\nconst STRICT_MODULE_PREFIX = MODULE_PREFIX + '\"use strict\"; ';\nconst MODULE_SUFFIX = '\\n});';\n\n/**\n * Class Script\n *\n * @public\n */\nclass VMScript {\n\n\t/**\n\t * The script code with wrapping. If set will invalidate the cache.<br>\n\t * Writable only for backwards compatibility.\n\t *\n\t * @public\n\t * @readonly\n\t * @member {string} code\n\t * @memberOf VMScript#\n\t */\n\n\t/**\n\t * The filename used for this script.\n\t *\n\t * @public\n\t * @readonly\n\t * @since v3.9.0\n\t * @member {string} filename\n\t * @memberOf VMScript#\n\t */\n\n\t/**\n\t * The line offset use for stack traces.\n\t *\n\t * @public\n\t * @readonly\n\t * @since v3.9.0\n\t * @member {number} lineOffset\n\t * @memberOf VMScript#\n\t */\n\n\t/**\n\t * The column offset use for stack traces.\n\t *\n\t * @public\n\t * @readonly\n\t * @since v3.9.0\n\t * @member {number} columnOffset\n\t * @memberOf VMScript#\n\t */\n\n\t/**\n\t * The compiler to use to get the JavaScript code.\n\t *\n\t * @public\n\t * @readonly\n\t * @since v3.9.0\n\t * @member {(string|compileCallback)} compiler\n\t * @memberOf VMScript#\n\t */\n\n\t/**\n\t * The prefix for the script.\n\t *\n\t * @private\n\t * @member {string} _prefix\n\t * @memberOf VMScript#\n\t */\n\n\t/**\n\t * The suffix for the script.\n\t *\n\t * @private\n\t * @member {string} _suffix\n\t * @memberOf VMScript#\n\t */\n\n\t/**\n\t * The compiled vm.Script for the VM or if not compiled <code>null</code>.\n\t *\n\t * @private\n\t * @member {?vm.Script} _compiledVM\n\t * @memberOf VMScript#\n\t */\n\n\t/**\n\t * The compiled vm.Script for the NodeVM or if not compiled <code>null</code>.\n\t *\n\t * @private\n\t * @member {?vm.Script} _compiledNodeVM\n\t * @memberOf VMScript#\n\t */\n\n\t/**\n\t * The compiled vm.Script for the NodeVM in strict mode or if not compiled <code>null</code>.\n\t *\n\t * @private\n\t * @member {?vm.Script} _compiledNodeVMStrict\n\t * @memberOf VMScript#\n\t */\n\n\t/**\n\t * The resolved compiler to use to get the JavaScript code.\n\t *\n\t * @private\n\t * @readonly\n\t * @member {compileCallback} _compiler\n\t * @memberOf VMScript#\n\t */\n\n\t/**\n\t * The script to run without wrapping.\n\t *\n\t * @private\n\t * @member {string} _code\n\t * @memberOf VMScript#\n\t */\n\n\t/**\n\t * Whether or not the script contains async functions.\n\t *\n\t * @private\n\t * @member {boolean} _hasAsync\n\t * @memberOf VMScript#\n\t */\n\n\t/**\n\t * Create VMScript instance.\n\t *\n\t * @public\n\t * @param {string} code - Code to run.\n\t * @param {(string|Object)} [options] - Options map or filename.\n\t * @param {string} [options.filename=\"vm.js\"] - Filename that shows up in any stack traces produced from this script.\n\t * @param {number} [options.lineOffset=0] - Passed to vm.Script options.\n\t * @param {number} [options.columnOffset=0] - Passed to vm.Script options.\n\t * @param {(string|compileCallback)} [options.compiler=\"javascript\"] - The compiler to use.\n\t * @throws {VMError} If the compiler is unknown or if coffee-script was requested but the module not found.\n\t */\n\tconstructor(code, options) {\n\t\tconst sCode = `${code}`;\n\t\tlet useFileName;\n\t\tlet useOptions;\n\t\tif (arguments.length === 2) {\n\t\t\tif (typeof options === 'object') {\n\t\t\t\tuseOptions = options || {__proto__: null};\n\t\t\t\tuseFileName = useOptions.filename;\n\t\t\t} else {\n\t\t\t\tuseOptions = {__proto__: null};\n\t\t\t\tuseFileName = options;\n\t\t\t}\n\t\t} else if (arguments.length > 2) {\n\t\t\t// We do it this way so that there are no more arguments in the function.\n\t\t\t// eslint-disable-next-line prefer-rest-params\n\t\t\tuseOptions = arguments[2] || {__proto__: null};\n\t\t\tuseFileName = options || useOptions.filename;\n\t\t} else {\n\t\t\tuseOptions = {__proto__: null};\n\t\t}\n\n\t\tconst {\n\t\t\tcompiler = 'javascript',\n\t\t\tlineOffset = 0,\n\t\t\tcolumnOffset = 0\n\t\t} = useOptions;\n\n\t\t// Throw if the compiler is unknown.\n\t\tconst resolvedCompiler = lookupCompiler(compiler);\n\n\t\tobjectDefineProperties(this, {\n\t\t\t__proto__: null,\n\t\t\tcode: {\n\t\t\t\t__proto__: null,\n\t\t\t\t// Put this here so that it is enumerable, and looks like a property.\n\t\t\t\tget() {\n\t\t\t\t\treturn this._prefix + this._code + this._suffix;\n\t\t\t\t},\n\t\t\t\tset(value) {\n\t\t\t\t\tconst strNewCode = String(value);\n\t\t\t\t\tif (strNewCode === this._code && this._prefix === '' && this._suffix === '') return;\n\t\t\t\t\tthis._code = strNewCode;\n\t\t\t\t\tthis._prefix = '';\n\t\t\t\t\tthis._suffix = '';\n\t\t\t\t\tthis._compiledVM = null;\n\t\t\t\t\tthis._compiledNodeVM = null;\n\t\t\t\t\tthis._compiledCode = null;\n\t\t\t\t},\n\t\t\t\tenumerable: true\n\t\t\t},\n\t\t\tfilename: {\n\t\t\t\t__proto__: null,\n\t\t\t\tvalue: useFileName || 'vm.js',\n\t\t\t\tenumerable: true\n\t\t\t},\n\t\t\tlineOffset: {\n\t\t\t\t__proto__: null,\n\t\t\t\tvalue: lineOffset,\n\t\t\t\tenumerable: true\n\t\t\t},\n\t\t\tcolumnOffset: {\n\t\t\t\t__proto__: null,\n\t\t\t\tvalue: columnOffset,\n\t\t\t\tenumerable: true\n\t\t\t},\n\t\t\tcompiler: {\n\t\t\t\t__proto__: null,\n\t\t\t\tvalue: compiler,\n\t\t\t\tenumerable: true\n\t\t\t},\n\t\t\t_code: {\n\t\t\t\t__proto__: null,\n\t\t\t\tvalue: sCode,\n\t\t\t\twritable: true\n\t\t\t},\n\t\t\t_prefix: {\n\t\t\t\t__proto__: null,\n\t\t\t\tvalue: '',\n\t\t\t\twritable: true\n\t\t\t},\n\t\t\t_suffix: {\n\t\t\t\t__proto__: null,\n\t\t\t\tvalue: '',\n\t\t\t\twritable: true\n\t\t\t},\n\t\t\t_compiledVM: {\n\t\t\t\t__proto__: null,\n\t\t\t\tvalue: null,\n\t\t\t\twritable: true\n\t\t\t},\n\t\t\t_compiledNodeVM: {\n\t\t\t\t__proto__: null,\n\t\t\t\tvalue: null,\n\t\t\t\twritable: true\n\t\t\t},\n\t\t\t_compiledNodeVMStrict: {\n\t\t\t\t__proto__: null,\n\t\t\t\tvalue: null,\n\t\t\t\twritable: true\n\t\t\t},\n\t\t\t_compiledCode: {\n\t\t\t\t__proto__: null,\n\t\t\t\tvalue: null,\n\t\t\t\twritable: true\n\t\t\t},\n\t\t\t_hasAsync: {\n\t\t\t\t__proto__: null,\n\t\t\t\tvalue: false,\n\t\t\t\twritable: true\n\t\t\t},\n\t\t\t_compiler: {__proto__: null, value: resolvedCompiler}\n\t\t});\n\t}\n\n\t/**\n\t * Wraps the code.<br>\n\t * This will replace the old wrapping.<br>\n\t * Will invalidate the code cache.\n\t *\n\t * @public\n\t * @deprecated Since v3.9.0. Wrap your code before passing it into the VMScript object.\n\t * @param {string} prefix - String that will be appended before the script code.\n\t * @param {script} suffix - String that will be appended behind the script code.\n\t * @return {this} This for chaining.\n\t * @throws {TypeError} If prefix or suffix is a Symbol.\n\t */\n\twrap(prefix, suffix) {\n\t\tconst strPrefix = `${prefix}`;\n\t\tconst strSuffix = `${suffix}`;\n\t\tif (this._prefix === strPrefix && this._suffix === strSuffix) return this;\n\t\tthis._prefix = strPrefix;\n\t\tthis._suffix = strSuffix;\n\t\tthis._compiledVM = null;\n\t\tthis._compiledNodeVM = null;\n\t\tthis._compiledNodeVMStrict = null;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Compile this script. <br>\n\t * This is useful to detect syntax errors in the script.\n\t *\n\t * @public\n\t * @return {this} This for chaining.\n\t * @throws {SyntaxError} If there is a syntax error in the script.\n\t */\n\tcompile() {\n\t\tthis._compileVM();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the compiled code.\n\t *\n\t * @private\n\t * @return {string} The code.\n\t */\n\tgetCompiledCode() {\n\t\tif (!this._compiledCode) {\n\t\t\tconst comp = this._compiler(this._prefix + removeShebang(this._code) + this._suffix, this.filename);\n\t\t\tconst res = transformer(null, comp, false, false, this.filename);\n\t\t\tthis._compiledCode = res.code;\n\t\t\tthis._hasAsync = res.hasAsync;\n\t\t}\n\t\treturn this._compiledCode;\n\t}\n\n\t/**\n\t * Compiles this script to a vm.Script.\n\t *\n\t * @private\n\t * @param {string} prefix - JavaScript code that will be used as prefix.\n\t * @param {string} suffix - JavaScript code that will be used as suffix.\n\t * @return {vm.Script} The compiled vm.Script.\n\t * @throws {SyntaxError} If there is a syntax error in the script.\n\t */\n\t_compile(prefix, suffix) {\n\t\treturn new Script(prefix + this.getCompiledCode() + suffix, {\n\t\t\t__proto__: null,\n\t\t\tfilename: this.filename,\n\t\t\tdisplayErrors: false,\n\t\t\tlineOffset: this.lineOffset,\n\t\t\tcolumnOffset: this.columnOffset\n\t\t});\n\t}\n\n\t/**\n\t * Will return the cached version of the script intended for VM or compile it.\n\t *\n\t * @private\n\t * @return {vm.Script} The compiled script\n\t * @throws {SyntaxError} If there is a syntax error in the script.\n\t */\n\t_compileVM() {\n\t\tlet script = this._compiledVM;\n\t\tif (!script) {\n\t\t\tthis._compiledVM = script = this._compile('', '');\n\t\t}\n\t\treturn script;\n\t}\n\n\t/**\n\t * Will return the cached version of the script intended for NodeVM or compile it.\n\t *\n\t * @private\n\t * @return {vm.Script} The compiled script\n\t * @throws {SyntaxError} If there is a syntax error in the script.\n\t */\n\t_compileNodeVM() {\n\t\tlet script = this._compiledNodeVM;\n\t\tif (!script) {\n\t\t\tthis._compiledNodeVM = script = this._compile(MODULE_PREFIX, MODULE_SUFFIX);\n\t\t}\n\t\treturn script;\n\t}\n\n\t/**\n\t * Will return the cached version of the script intended for NodeVM in strict mode or compile it.\n\t *\n\t * @private\n\t * @return {vm.Script} The compiled script\n\t * @throws {SyntaxError} If there is a syntax error in the script.\n\t */\n\t_compileNodeVMStrict() {\n\t\tlet script = this._compiledNodeVMStrict;\n\t\tif (!script) {\n\t\t\tthis._compiledNodeVMStrict = script = this._compile(STRICT_MODULE_PREFIX, MODULE_SUFFIX);\n\t\t}\n\t\treturn script;\n\t}\n\n}\n\nexports.MODULE_PREFIX = MODULE_PREFIX;\nexports.STRICT_MODULE_PREFIX = STRICT_MODULE_PREFIX;\nexports.MODULE_SUFFIX = MODULE_SUFFIX;\nexports.VMScript = VMScript;\n","\n\n/**\n * This callback will be called to transform a script to JavaScript.\n *\n * @callback compileCallback\n * @param {string} code - Script code to transform to JavaScript.\n * @param {string} filename - Filename of this script.\n * @return {string} JavaScript code that represents the script code.\n */\n\n/**\n * This callback will be called to resolve a module if it couldn't be found.\n *\n * @callback resolveCallback\n * @param {string} moduleName - Name of the modulusedRequiree to resolve.\n * @param {string} dirname - Name of the current directory.\n * @return {(string|undefined)} The file or directory to use to load the requested module.\n */\n\nconst fs = require('fs');\nconst pa = require('path');\nconst {\n\tScript,\n\tcreateContext\n} = require('vm');\nconst {\n\tEventEmitter\n} = require('events');\nconst {\n\tINSPECT_MAX_BYTES\n} = require('buffer');\nconst {\n\tcreateBridge,\n\tVMError\n} = require('./bridge');\nconst {\n\ttransformer,\n\tINTERNAL_STATE_NAME\n} = require('./transformer');\nconst {\n\tlookupCompiler\n} = require('./compiler');\nconst {\n\tVMScript\n} = require('./script');\n\nconst objectDefineProperties = Object.defineProperties;\n\n/**\n * Host objects\n *\n * @private\n */\nconst HOST = Object.freeze({\n\tBuffer,\n\tFunction,\n\tObject,\n\ttransformAndCheck,\n\tINSPECT_MAX_BYTES,\n\tINTERNAL_STATE_NAME\n});\n\n/**\n * Compile a script.\n *\n * @private\n * @param {string} filename - Filename of the script.\n * @param {string} script - Script.\n * @return {vm.Script} The compiled script.\n */\nfunction compileScript(filename, script) {\n\treturn new Script(script, {\n\t\t__proto__: null,\n\t\tfilename,\n\t\tdisplayErrors: false\n\t});\n}\n\n/**\n * Default run options for vm.Script.runInContext\n *\n * @private\n */\nconst DEFAULT_RUN_OPTIONS = Object.freeze({__proto__: null, displayErrors: false});\n\nfunction checkAsync(allow) {\n\tif (!allow) throw new VMError('Async not available');\n}\n\nfunction transformAndCheck(args, code, isAsync, isGenerator, allowAsync) {\n\tconst ret = transformer(args, code, isAsync, isGenerator, undefined);\n\tcheckAsync(allowAsync || !ret.hasAsync);\n\treturn ret.code;\n}\n\n/**\n *\n * This callback will be called and has a specific time to finish.<br>\n * No parameters will be supplied.<br>\n * If parameters are required, use a closure.\n *\n * @private\n * @callback runWithTimeout\n * @return {*}\n *\n */\n\nlet cacheTimeoutContext = null;\nlet cacheTimeoutScript = null;\n\n/**\n * Run a function with a specific timeout.\n *\n * @private\n * @param {runWithTimeout} fn - Function to run with the specific timeout.\n * @param {number} timeout - The amount of time to give the function to finish.\n * @return {*} The value returned by the function.\n * @throws {Error} If the function took to long.\n */\nfunction doWithTimeout(fn, timeout) {\n\tif (!cacheTimeoutContext) {\n\t\tcacheTimeoutContext = createContext();\n\t\tcacheTimeoutScript = new Script('fn()', {\n\t\t\t__proto__: null,\n\t\t\tfilename: 'timeout_bridge.js',\n\t\t\tdisplayErrors: false\n\t\t});\n\t}\n\tcacheTimeoutContext.fn = fn;\n\ttry {\n\t\treturn cacheTimeoutScript.runInContext(cacheTimeoutContext, {\n\t\t\t__proto__: null,\n\t\t\tdisplayErrors: false,\n\t\t\ttimeout\n\t\t});\n\t} finally {\n\t\tcacheTimeoutContext.fn = null;\n\t}\n}\n\nconst bridgeScript = compileScript(`${__dirname}/bridge.js`,\n\t`(function(global) {\"use strict\"; const exports = {};${fs.readFileSync(`${__dirname}/bridge.js`, 'utf8')}\\nreturn exports;})`);\nconst setupSandboxScript = compileScript(`${__dirname}/setup-sandbox.js`,\n\t`(function(global, host, bridge, data, context) { ${fs.readFileSync(`${__dirname}/setup-sandbox.js`, 'utf8')}\\n})`);\nconst getGlobalScript = compileScript('get_global.js', 'this');\n\nlet getGeneratorFunctionScript = null;\nlet getAsyncFunctionScript = null;\nlet getAsyncGeneratorFunctionScript = null;\ntry {\n\tgetGeneratorFunctionScript = compileScript('get_generator_function.js', '(function*(){}).constructor');\n} catch (ex) {}\ntry {\n\tgetAsyncFunctionScript = compileScript('get_async_function.js', '(async function(){}).constructor');\n} catch (ex) {}\ntry {\n\tgetAsyncGeneratorFunctionScript = compileScript('get_async_generator_function.js', '(async function*(){}).constructor');\n} catch (ex) {}\n\n/**\n * Class VM.\n *\n * @public\n */\nclass VM extends EventEmitter {\n\n\t/**\n\t * The timeout for {@link VM#run} calls.\n\t *\n\t * @public\n\t * @since v3.9.0\n\t * @member {number} timeout\n\t * @memberOf VM#\n\t */\n\n\t/**\n\t * Get the global sandbox object.\n\t *\n\t * @public\n\t * @readonly\n\t * @since v3.9.0\n\t * @member {Object} sandbox\n\t * @memberOf VM#\n\t */\n\n\t/**\n\t * The compiler to use to get the JavaScript code.\n\t *\n\t * @public\n\t * @readonly\n\t * @since v3.9.0\n\t * @member {(string|compileCallback)} compiler\n\t * @memberOf VM#\n\t */\n\n\t/**\n\t * The resolved compiler to use to get the JavaScript code.\n\t *\n\t * @private\n\t * @readonly\n\t * @member {compileCallback} _compiler\n\t * @memberOf VM#\n\t */\n\n\t/**\n\t * Create a new VM instance.\n\t *\n\t * @public\n\t * @param {Object} [options] - VM options.\n\t * @param {number} [options.timeout] - The amount of time until a call to {@link VM#run} will timeout.\n\t * @param {Object} [options.sandbox] - Objects that will be copied into the global object of the sandbox.\n\t * @param {(string|compileCallback)} [options.compiler=\"javascript\"] - The compiler to use.\n\t * @param {boolean} [options.eval=true] - Allow the dynamic evaluation of code via eval(code) or Function(code)().<br>\n\t * Only available for node v10+.\n\t * @param {boolean} [options.wasm=true] - Allow to run wasm code.<br>\n\t * Only available for node v10+.\n\t * @param {boolean} [options.allowAsync=true] - Allows for async functions.\n\t * @throws {VMError} If the compiler is unknown.\n\t */\n\tconstructor(options = {}) {\n\t\tsuper();\n\n\t\t// Read all options\n\t\tconst {\n\t\t\ttimeout,\n\t\t\tsandbox,\n\t\t\tcompiler = 'javascript',\n\t\t\tallowAsync: optAllowAsync = true\n\t\t} = options;\n\t\tconst allowEval = options.eval !== false;\n\t\tconst allowWasm = options.wasm !== false;\n\t\tconst allowAsync = optAllowAsync && !options.fixAsync;\n\n\t\t// Early error if sandbox is not an object.\n\t\tif (sandbox && 'object' !== typeof sandbox) {\n\t\t\tthrow new VMError('Sandbox must be object.');\n\t\t}\n\n\t\t// Early error if compiler can't be found.\n\t\tconst resolvedCompiler = lookupCompiler(compiler);\n\n\t\t// Create a new context for this vm.\n\t\tconst _context = createContext(undefined, {\n\t\t\t__proto__: null,\n\t\t\tcodeGeneration: {\n\t\t\t\t__proto__: null,\n\t\t\t\tstrings: allowEval,\n\t\t\t\twasm: allowWasm\n\t\t\t}\n\t\t});\n\n\t\tconst sandboxGlobal = getGlobalScript.runInContext(_context, DEFAULT_RUN_OPTIONS);\n\n\t\t// Initialize the sandbox bridge\n\t\tconst {\n\t\t\tcreateBridge: sandboxCreateBridge\n\t\t} = bridgeScript.runInContext(_context, DEFAULT_RUN_OPTIONS)(sandboxGlobal);\n\n\t\t// Initialize the bridge\n\t\tconst bridge = createBridge(sandboxCreateBridge, () => {});\n\n\t\tconst data = {\n\t\t\t__proto__: null,\n\t\t\tallowAsync\n\t\t};\n\n\t\tif (getGeneratorFunctionScript) {\n\t\t\tdata.GeneratorFunction = getGeneratorFunctionScript.runInContext(_context, DEFAULT_RUN_OPTIONS);\n\t\t}\n\t\tif (getAsyncFunctionScript) {\n\t\t\tdata.AsyncFunction = getAsyncFunctionScript.runInContext(_context, DEFAULT_RUN_OPTIONS);\n\t\t}\n\t\tif (getAsyncGeneratorFunctionScript) {\n\t\t\tdata.AsyncGeneratorFunction = getAsyncGeneratorFunctionScript.runInContext(_context, DEFAULT_RUN_OPTIONS);\n\t\t}\n\n\t\t// Create the bridge between the host and the sandbox.\n\t\tconst internal = setupSandboxScript.runInContext(_context, DEFAULT_RUN_OPTIONS)(sandboxGlobal, HOST, bridge.other, data, _context);\n\n\t\tconst runScript = (script) => {\n\t\t\t// This closure is intentional to hide _context and bridge since the allow to access the sandbox directly which is unsafe.\n\t\t\tlet ret;\n\t\t\ttry {\n\t\t\t\tret = script.runInContext(_context, DEFAULT_RUN_OPTIONS);\n\t\t\t} catch (e) {\n\t\t\t\tthrow bridge.from(e);\n\t\t\t}\n\t\t\treturn bridge.from(ret);\n\t\t};\n\n\t\tconst makeReadonly = (value, mock) => {\n\t\t\ttry {\n\t\t\t\tinternal.readonly(value, mock);\n\t\t\t} catch (e) {\n\t\t\t\tthrow bridge.from(e);\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\n\t\tconst makeProtected = (value) => {\n\t\t\tconst sandboxBridge = bridge.other;\n\t\t\ttry {\n\t\t\t\tsandboxBridge.fromWithFactory(sandboxBridge.protectedFactory, value);\n\t\t\t} catch (e) {\n\t\t\t\tthrow bridge.from(e);\n\t\t\t}\n\t\t\treturn value;\n\t\t};\n\n\t\tconst addProtoMapping = (hostProto, sandboxProto) => {\n\t\t\tconst sandboxBridge = bridge.other;\n\t\t\tlet otherProto;\n\t\t\ttry {\n\t\t\t\totherProto = sandboxBridge.from(sandboxProto);\n\t\t\t\tsandboxBridge.addProtoMapping(otherProto, hostProto);\n\t\t\t} catch (e) {\n\t\t\t\tthrow bridge.from(e);\n\t\t\t}\n\t\t\tbridge.addProtoMapping(hostProto, otherProto);\n\t\t};\n\n\t\tconst addProtoMappingFactory = (hostProto, sandboxProtoFactory) => {\n\t\t\tconst sandboxBridge = bridge.other;\n\t\t\tconst factory = () => {\n\t\t\t\tconst proto = sandboxProtoFactory(this);\n\t\t\t\tbridge.addProtoMapping(hostProto, proto);\n\t\t\t\treturn proto;\n\t\t\t};\n\t\t\ttry {\n\t\t\t\tconst otherProtoFactory = sandboxBridge.from(factory);\n\t\t\t\tsandboxBridge.addProtoMappingFactory(otherProtoFactory, hostProto);\n\t\t\t} catch (e) {\n\t\t\t\tthrow bridge.from(e);\n\t\t\t}\n\t\t};\n\n\t\t// Define the properties of this object.\n\t\t// Use Object.defineProperties here to be able to\n\t\t// hide and set properties read-only.\n\t\tobjectDefineProperties(this, {\n\t\t\t__proto__: null,\n\t\t\ttimeout: {\n\t\t\t\t__proto__: null,\n\t\t\t\tvalue: timeout,\n\t\t\t\twritable: true,\n\t\t\t\tenumerable: true\n\t\t\t},\n\t\t\tcompiler: {\n\t\t\t\t__proto__: null,\n\t\t\t\tvalue: compiler,\n\t\t\t\tenumerable: true\n\t\t\t},\n\t\t\tsandbox: {\n\t\t\t\t__proto__: null,\n\t\t\t\tvalue: bridge.from(sandboxGlobal),\n\t\t\t\tenumerable: true\n\t\t\t},\n\t\t\t_runScript: {__proto__: null, value: runScript},\n\t\t\t_makeReadonly: {__proto__: null, value: makeReadonly},\n\t\t\t_makeProtected: {__proto__: null, value: makeProtected},\n\t\t\t_addProtoMapping: {__proto__: null, value: addProtoMapping},\n\t\t\t_addProtoMappingFactory: {__proto__: null, value: addProtoMappingFactory},\n\t\t\t_compiler: {__proto__: null, value: resolvedCompiler},\n\t\t\t_allowAsync: {__proto__: null, value: allowAsync}\n\t\t});\n\n\t\t// prepare global sandbox\n\t\tif (sandbox) {\n\t\t\tthis.setGlobals(sandbox);\n\t\t}\n\t}\n\n\t/**\n\t * Adds all the values to the globals.\n\t *\n\t * @public\n\t * @since v3.9.0\n\t * @param {Object} values - All values that will be added to the globals.\n\t * @return {this} This for chaining.\n\t * @throws {*} If the setter of a global throws an exception it is propagated. And the remaining globals will not be written.\n\t */\n\tsetGlobals(values) {\n\t\tfor (const name in values) {\n\t\t\tif (Object.prototype.hasOwnProperty.call(values, name)) {\n\t\t\t\tthis.sandbox[name] = values[name];\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set a global value.\n\t *\n\t * @public\n\t * @since v3.9.0\n\t * @param {string} name - The name of the global.\n\t * @param {*} value - The value of the global.\n\t * @return {this} This for chaining.\n\t * @throws {*} If the setter of the global throws an exception it is propagated.\n\t */\n\tsetGlobal(name, value) {\n\t\tthis.sandbox[name] = value;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get a global value.\n\t *\n\t * @public\n\t * @since v3.9.0\n\t * @param {string} name - The name of the global.\n\t * @return {*} The value of the global.\n\t * @throws {*} If the getter of the global throws an exception it is propagated.\n\t */\n\tgetGlobal(name) {\n\t\treturn this.sandbox[name];\n\t}\n\n\t/**\n\t * Freezes the object inside VM making it read-only. Not available for primitive values.\n\t *\n\t * @public\n\t * @param {*} value - Object to freeze.\n\t * @param {string} [globalName] - Whether to add the object to global.\n\t * @return {*} Object to freeze.\n\t * @throws {*} If the setter of the global throws an exception it is propagated.\n\t */\n\tfreeze(value, globalName) {\n\t\tthis.readonly(value);\n\t\tif (globalName) this.sandbox[globalName] = value;\n\t\treturn value;\n\t}\n\n\t/**\n\t * Freezes the object inside VM making it read-only. Not available for primitive values.\n\t *\n\t * @public\n\t * @param {*} value - Object to freeze.\n\t * @param {*} [mock] - When the object does not have a property the mock is used before prototype lookup.\n\t * @return {*} Object to freeze.\n\t */\n\treadonly(value, mock) {\n\t\treturn this._makeReadonly(value, mock);\n\t}\n\n\t/**\n\t * Protects the object inside VM making impossible to set functions as it's properties. Not available for primitive values.\n\t *\n\t * @public\n\t * @param {*} value - Object to protect.\n\t * @param {string} [globalName] - Whether to add the object to global.\n\t * @return {*} Object to protect.\n\t * @throws {*} If the setter of the global throws an exception it is propagated.\n\t */\n\tprotect(value, globalName) {\n\t\tthis._makeProtected(value);\n\t\tif (globalName) this.sandbox[globalName] = value;\n\t\treturn value;\n\t}\n\n\t/**\n\t * Run the code in VM.\n\t *\n\t * @public\n\t * @param {(string|VMScript)} code - Code to run.\n\t * @param {(string|Object)} [options] - Options map or filename.\n\t * @param {string} [options.filename=\"vm.js\"] - Filename that shows up in any stack traces produced from this script.<br>\n\t * This is only used if code is a String.\n\t * @return {*} Result of executed code.\n\t * @throws {SyntaxError} If there is a syntax error in the script.\n\t * @throws {Error} An error is thrown when the script took to long and there is a timeout.\n\t * @throws {*} If the script execution terminated with an exception it is propagated.\n\t */\n\trun(code, options) {\n\t\tlet script;\n\t\tlet filename;\n\n\t\tif (typeof options === 'object') {\n\t\t\tfilename = options.filename;\n\t\t} else {\n\t\t\tfilename = options;\n\t\t}\n\n\t\tif (code instanceof VMScript) {\n\t\t\tscript = code._compileVM();\n\t\t\tcheckAsync(this._allowAsync || !code._hasAsync);\n\t\t} else {\n\t\t\tconst useFileName = filename || 'vm.js';\n\t\t\tlet scriptCode = this._compiler(code, useFileName);\n\t\t\tconst ret = transformer(null, scriptCode, false, false, useFileName);\n\t\t\tscriptCode = ret.code;\n\t\t\tcheckAsync(this._allowAsync || !ret.hasAsync);\n\t\t\t// Compile the script here so that we don't need to create a instance of VMScript.\n\t\t\tscript = new Script(scriptCode, {\n\t\t\t\t__proto__: null,\n\t\t\t\tfilename: useFileName,\n\t\t\t\tdisplayErrors: false\n\t\t\t});\n\t\t}\n\n\t\tif (!this.timeout) {\n\t\t\treturn this._runScript(script);\n\t\t}\n\n\t\treturn doWithTimeout(() => {\n\t\t\treturn this._runScript(script);\n\t\t}, this.timeout);\n\t}\n\n\t/**\n\t * Run the code in VM.\n\t *\n\t * @public\n\t * @since v3.9.0\n\t * @param {string} filename - Filename of file to load and execute in a NodeVM.\n\t * @return {*} Result of executed code.\n\t * @throws {Error} If filename is not a valid filename.\n\t * @throws {SyntaxError} If there is a syntax error in the script.\n\t * @throws {Error} An error is thrown when the script took to long and there is a timeout.\n\t * @throws {*} If the script execution terminated with an exception it is propagated.\n\t */\n\trunFile(filename) {\n\t\tconst resolvedFilename = pa.resolve(filename);\n\n\t\tif (!fs.existsSync(resolvedFilename)) {\n\t\t\tthrow new VMError(`Script '${filename}' not found.`);\n\t\t}\n\n\t\tif (fs.statSync(resolvedFilename).isDirectory()) {\n\t\t\tthrow new VMError('Script must be file, got directory.');\n\t\t}\n\n\t\treturn this.run(fs.readFileSync(resolvedFilename, 'utf8'), resolvedFilename);\n\t}\n\n}\n\nexports.VM = VM;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Modified by the vm2 team to make this a standalone module to be loaded into the sandbox.\n\n\n\nconst host = fromhost;\n\nconst {\n\tBoolean,\n  Error,\n\tString,\n\tSymbol\n} = globalThis;\n\nconst ReflectApply = Reflect.apply;\nconst ReflectOwnKeys = Reflect.ownKeys;\n\nconst ErrorCaptureStackTrace = Error.captureStackTrace;\n\nconst NumberIsNaN = Number.isNaN;\n\nconst ObjectCreate = Object.create;\nconst ObjectDefineProperty = Object.defineProperty;\nconst ObjectDefineProperties = Object.defineProperties;\nconst ObjectGetPrototypeOf = Object.getPrototypeOf;\n\nconst SymbolFor = Symbol.for;\n\nfunction uncurryThis(func) {\n\treturn (thiz, ...args) => ReflectApply(func, thiz, args);\n}\n\nconst ArrayPrototypeIndexOf = uncurryThis(Array.prototype.indexOf);\nconst ArrayPrototypeJoin = uncurryThis(Array.prototype.join);\nconst ArrayPrototypeSlice = uncurryThis(Array.prototype.slice);\nconst ArrayPrototypeSplice = uncurryThis(Array.prototype.splice);\nconst ArrayPrototypeUnshift = uncurryThis(Array.prototype.unshift);\n\nconst kRejection = SymbolFor('nodejs.rejection');\n\nfunction inspect(obj) {\n\treturn typeof obj === 'symbol' ? obj.toString() : `${obj}`;\n}\n\nfunction spliceOne(list, index) {\n\tfor (; index + 1 < list.length; index++)\n\t\tlist[index] = list[index + 1];\n\tlist.pop();\n}\n\nfunction assert(what, message) {\n\tif (!what) throw new Error(message);\n}\n\nfunction E(key, msg, Base) {\n\treturn function NodeError(...args) {\n\t  const error = new Base();\n\t  const message = ReflectApply(msg, error, args);\n\t  ObjectDefineProperties(error, {\n\t\tmessage: {\n\t\t  value: message,\n\t\t  enumerable: false,\n\t\t  writable: true,\n\t\t  configurable: true,\n\t\t},\n\t\ttoString: {\n\t\t  value() {\n\t\t\treturn `${this.name} [${key}]: ${this.message}`;\n\t\t  },\n\t\t  enumerable: false,\n\t\t  writable: true,\n\t\t  configurable: true,\n\t\t},\n\t  });\n\t  error.code = key;\n\t  return error;\n\t};\n}\n\n\nconst ERR_INVALID_ARG_TYPE = E('ERR_INVALID_ARG_TYPE',\n  (name, expected, actual) => {\n    assert(typeof name === 'string', \"'name' must be a string\");\n    if (!ArrayIsArray(expected)) {\n      expected = [expected];\n    }\n\n    let msg = 'The ';\n    if (StringPrototypeEndsWith(name, ' argument')) {\n      // For cases like 'first argument'\n      msg += `${name} `;\n    } else {\n      const type = StringPrototypeIncludes(name, '.') ? 'property' : 'argument';\n      msg += `\"${name}\" ${type} `;\n    }\n    msg += 'must be ';\n\n    const types = [];\n    const instances = [];\n    const other = [];\n\n    for (const value of expected) {\n      assert(typeof value === 'string',\n             'All expected entries have to be of type string');\n      if (ArrayPrototypeIncludes(kTypes, value)) {\n        ArrayPrototypePush(types, StringPrototypeToLowerCase(value));\n      } else if (RegExpPrototypeTest(classRegExp, value)) {\n        ArrayPrototypePush(instances, value);\n      } else {\n        assert(value !== 'object',\n               'The value \"object\" should be written as \"Object\"');\n        ArrayPrototypePush(other, value);\n      }\n    }\n\n    // Special handle `object` in case other instances are allowed to outline\n    // the differences between each other.\n    if (instances.length > 0) {\n      const pos = ArrayPrototypeIndexOf(types, 'object');\n      if (pos !== -1) {\n        ArrayPrototypeSplice(types, pos, 1);\n        ArrayPrototypePush(instances, 'Object');\n      }\n    }\n\n    if (types.length > 0) {\n      if (types.length > 2) {\n        const last = ArrayPrototypePop(types);\n        msg += `one of type ${ArrayPrototypeJoin(types, ', ')}, or ${last}`;\n      } else if (types.length === 2) {\n        msg += `one of type ${types[0]} or ${types[1]}`;\n      } else {\n        msg += `of type ${types[0]}`;\n      }\n      if (instances.length > 0 || other.length > 0)\n        msg += ' or ';\n    }\n\n    if (instances.length > 0) {\n      if (instances.length > 2) {\n        const last = ArrayPrototypePop(instances);\n        msg +=\n          `an instance of ${ArrayPrototypeJoin(instances, ', ')}, or ${last}`;\n      } else {\n        msg += `an instance of ${instances[0]}`;\n        if (instances.length === 2) {\n          msg += ` or ${instances[1]}`;\n        }\n      }\n      if (other.length > 0)\n        msg += ' or ';\n    }\n\n    if (other.length > 0) {\n      if (other.length > 2) {\n        const last = ArrayPrototypePop(other);\n        msg += `one of ${ArrayPrototypeJoin(other, ', ')}, or ${last}`;\n      } else if (other.length === 2) {\n        msg += `one of ${other[0]} or ${other[1]}`;\n      } else {\n        if (StringPrototypeToLowerCase(other[0]) !== other[0])\n          msg += 'an ';\n        msg += `${other[0]}`;\n      }\n    }\n\n    if (actual == null) {\n      msg += `. Received ${actual}`;\n    } else if (typeof actual === 'function' && actual.name) {\n      msg += `. Received function ${actual.name}`;\n    } else if (typeof actual === 'object') {\n      if (actual.constructor && actual.constructor.name) {\n        msg += `. Received an instance of ${actual.constructor.name}`;\n      } else {\n        const inspected = inspect(actual, { depth: -1 });\n        msg += `. Received ${inspected}`;\n      }\n    } else {\n      let inspected = inspect(actual, { colors: false });\n      if (inspected.length > 25)\n        inspected = `${StringPrototypeSlice(inspected, 0, 25)}...`;\n      msg += `. Received type ${typeof actual} (${inspected})`;\n    }\n    return msg;\n  }, TypeError);\n\nconst ERR_INVALID_THIS = E('ERR_INVALID_THIS', s => `Value of \"this\" must be of type ${s}`, TypeError);\n\nconst ERR_OUT_OF_RANGE = E('ERR_OUT_OF_RANGE',\n  (str, range, input, replaceDefaultBoolean = false) => {\n    assert(range, 'Missing \"range\" argument');\n    let msg = replaceDefaultBoolean ? str :\n      `The value of \"${str}\" is out of range.`;\n    const received = inspect(input);\n    msg += ` It must be ${range}. Received ${received}`;\n    return msg;\n  }, RangeError);\n\nconst ERR_UNHANDLED_ERROR = E('ERR_UNHANDLED_ERROR',\n  err => {\n    const msg = 'Unhandled error.';\n    if (err === undefined) return msg;\n    return `${msg} (${err})`;\n  }, Error);\n\nfunction validateBoolean(value, name) {\n  if (typeof value !== 'boolean')\n    throw new ERR_INVALID_ARG_TYPE(name, 'boolean', value);\n}\n\nfunction validateFunction(value, name) {\n  if (typeof value !== 'function')\n    throw new ERR_INVALID_ARG_TYPE(name, 'Function', value);\n}\n\nfunction validateString(value, name) {\n  if (typeof value !== 'string')\n    throw new ERR_INVALID_ARG_TYPE(name, 'string', value);\n}\n\nfunction nc(cond, e) {\n\treturn cond === undefined || cond === null ? e : cond;\n}\n\nfunction oc(base, key) {\n\treturn base === undefined || base === null ? undefined : base[key];\n}\n\nconst kCapture = Symbol('kCapture');\nconst kErrorMonitor = host.kErrorMonitor || Symbol('events.errorMonitor');\nconst kMaxEventTargetListeners = Symbol('events.maxEventTargetListeners');\nconst kMaxEventTargetListenersWarned =\n  Symbol('events.maxEventTargetListenersWarned');\n\nconst kIsEventTarget = SymbolFor('nodejs.event_target');\n\nfunction isEventTarget(obj) {\n\treturn oc(oc(obj, 'constructor'), kIsEventTarget);\n}\n\n/**\n * Creates a new `EventEmitter` instance.\n * @param {{ captureRejections?: boolean; }} [opts]\n * @constructs {EventEmitter}\n */\nfunction EventEmitter(opts) {\n  EventEmitter.init.call(this, opts);\n}\nmodule.exports = EventEmitter;\nif (host.once) module.exports.once = host.once;\nif (host.on) module.exports.on = host.on;\nif (host.getEventListeners) module.exports.getEventListeners = host.getEventListeners;\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.usingDomains = false;\n\nEventEmitter.captureRejectionSymbol = kRejection;\nObjectDefineProperty(EventEmitter, 'captureRejections', {\n  get() {\n    return EventEmitter.prototype[kCapture];\n  },\n  set(value) {\n    validateBoolean(value, 'EventEmitter.captureRejections');\n\n    EventEmitter.prototype[kCapture] = value;\n  },\n  enumerable: true\n});\n\nif (host.EventEmitterReferencingAsyncResource) {\n\tconst kAsyncResource = Symbol('kAsyncResource');\n\tconst EventEmitterReferencingAsyncResource = host.EventEmitterReferencingAsyncResource;\n\n\tclass EventEmitterAsyncResource extends EventEmitter {\n\t\t/**\n\t\t * @param {{\n\t\t *   name?: string,\n\t\t *   triggerAsyncId?: number,\n\t\t *   requireManualDestroy?: boolean,\n\t\t * }} [options]\n\t\t */\n\t\tconstructor(options = undefined) {\n\t\t\tlet name;\n\t\t\tif (typeof options === 'string') {\n\t\t\t\tname = options;\n\t\t\t\toptions = undefined;\n\t\t\t} else {\n\t\t\t\tif (new.target === EventEmitterAsyncResource) {\n\t\t\t\t\tvalidateString(oc(options, 'name'), 'options.name');\n\t\t\t\t}\n\t\t\t\tname = oc(options, 'name') || new.target.name;\n\t\t\t}\n\t\t\tsuper(options);\n\n\t\t\tthis[kAsyncResource] =\n\t\t\t\tnew EventEmitterReferencingAsyncResource(this, name, options);\n\t\t}\n\n\t\t/**\n\t\t * @param {symbol,string} event\n\t\t * @param  {...any} args\n\t\t * @returns {boolean}\n\t\t */\n\t\temit(event, ...args) {\n\t\t\tif (this[kAsyncResource] === undefined)\n\t\t\t\tthrow new ERR_INVALID_THIS('EventEmitterAsyncResource');\n\t\t\tconst { asyncResource } = this;\n\t\t\tArrayPrototypeUnshift(args, super.emit, this, event);\n\t\t\treturn ReflectApply(asyncResource.runInAsyncScope, asyncResource,\n\t\t\t\t\t\t\t\t\t\t\t\t\targs);\n\t\t}\n\n\t\t/**\n\t\t * @returns {void}\n\t\t */\n\t\temitDestroy() {\n\t\t\tif (this[kAsyncResource] === undefined)\n\t\t\t\tthrow new ERR_INVALID_THIS('EventEmitterAsyncResource');\n\t\t\tthis.asyncResource.emitDestroy();\n\t\t}\n\n\t\t/**\n\t\t * @type {number}\n\t\t */\n\t\tget asyncId() {\n\t\t\tif (this[kAsyncResource] === undefined)\n\t\t\t\tthrow new ERR_INVALID_THIS('EventEmitterAsyncResource');\n\t\t\treturn this.asyncResource.asyncId();\n\t\t}\n\n\t\t/**\n\t\t * @type {number}\n\t\t */\n\t\tget triggerAsyncId() {\n\t\t\tif (this[kAsyncResource] === undefined)\n\t\t\t\tthrow new ERR_INVALID_THIS('EventEmitterAsyncResource');\n\t\t\treturn this.asyncResource.triggerAsyncId();\n\t\t}\n\n\t\t/**\n\t\t * @type {EventEmitterReferencingAsyncResource}\n\t\t */\n\t\tget asyncResource() {\n\t\t\tif (this[kAsyncResource] === undefined)\n\t\t\t\tthrow new ERR_INVALID_THIS('EventEmitterAsyncResource');\n\t\t\treturn this[kAsyncResource];\n\t\t}\n\t}\n\tEventEmitter.EventEmitterAsyncResource = EventEmitterAsyncResource;\n}\n\nEventEmitter.errorMonitor = kErrorMonitor;\n\n// The default for captureRejections is false\nObjectDefineProperty(EventEmitter.prototype, kCapture, {\n  value: false,\n  writable: true,\n  enumerable: false\n});\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nlet defaultMaxListeners = 10;\n\nfunction checkListener(listener) {\n  validateFunction(listener, 'listener');\n}\n\nObjectDefineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new ERR_OUT_OF_RANGE('defaultMaxListeners',\n                                 'a non-negative number',\n                                 arg);\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nObjectDefineProperties(EventEmitter, {\n  kMaxEventTargetListeners: {\n    value: kMaxEventTargetListeners,\n    enumerable: false,\n    configurable: false,\n    writable: false,\n  },\n  kMaxEventTargetListenersWarned: {\n    value: kMaxEventTargetListenersWarned,\n    enumerable: false,\n    configurable: false,\n    writable: false,\n  }\n});\n\n/**\n * Sets the max listeners.\n * @param {number} n\n * @param {EventTarget[] | EventEmitter[]} [eventTargets]\n * @returns {void}\n */\nEventEmitter.setMaxListeners =\n  function(n = defaultMaxListeners, ...eventTargets) {\n    if (typeof n !== 'number' || n < 0 || NumberIsNaN(n))\n      throw new ERR_OUT_OF_RANGE('n', 'a non-negative number', n);\n    if (eventTargets.length === 0) {\n      defaultMaxListeners = n;\n    } else {\n      for (let i = 0; i < eventTargets.length; i++) {\n        const target = eventTargets[i];\n        if (isEventTarget(target)) {\n          target[kMaxEventTargetListeners] = n;\n          target[kMaxEventTargetListenersWarned] = false;\n        } else if (typeof target.setMaxListeners === 'function') {\n          target.setMaxListeners(n);\n        } else {\n          throw new ERR_INVALID_ARG_TYPE(\n            'eventTargets',\n            ['EventEmitter', 'EventTarget'],\n            target);\n        }\n      }\n    }\n  };\n\n// If you're updating this function definition, please also update any\n// re-definitions, such as the one in the Domain module (lib/domain.js).\nEventEmitter.init = function(opts) {\n\n  if (this._events === undefined ||\n      this._events === ObjectGetPrototypeOf(this)._events) {\n    this._events = ObjectCreate(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n\n\n  if (oc(opts, 'captureRejections')) {\n    validateBoolean(opts.captureRejections, 'options.captureRejections');\n    this[kCapture] = Boolean(opts.captureRejections);\n  } else {\n    // Assigning the kCapture property directly saves an expensive\n    // prototype lookup in a very sensitive hot path.\n    this[kCapture] = EventEmitter.prototype[kCapture];\n  }\n};\n\nfunction addCatch(that, promise, type, args) {\n  if (!that[kCapture]) {\n    return;\n  }\n\n  // Handle Promises/A+ spec, then could be a getter\n  // that throws on second use.\n  try {\n    const then = promise.then;\n\n    if (typeof then === 'function') {\n      then.call(promise, undefined, function(err) {\n        // The callback is called with nextTick to avoid a follow-up\n        // rejection from this promise.\n        process.nextTick(emitUnhandledRejectionOrErr, that, err, type, args);\n      });\n    }\n  } catch (err) {\n    that.emit('error', err);\n  }\n}\n\nfunction emitUnhandledRejectionOrErr(ee, err, type, args) {\n  if (typeof ee[kRejection] === 'function') {\n    ee[kRejection](err, type, ...args);\n  } else {\n    // We have to disable the capture rejections mechanism, otherwise\n    // we might end up in an infinite loop.\n    const prev = ee[kCapture];\n\n    // If the error handler throws, it is not catchable and it\n    // will end up in 'uncaughtException'. We restore the previous\n    // value of kCapture in case the uncaughtException is present\n    // and the exception is handled.\n    try {\n      ee[kCapture] = false;\n      ee.emit('error', err);\n    } finally {\n      ee[kCapture] = prev;\n    }\n  }\n}\n\n/**\n * Increases the max listeners of the event emitter.\n * @param {number} n\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new ERR_OUT_OF_RANGE('n', 'a non-negative number', n);\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction _getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\n/**\n * Returns the current max listener value for the event emitter.\n * @returns {number}\n */\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return _getMaxListeners(this);\n};\n\n/**\n * Synchronously calls each of the listeners registered\n * for the event.\n * @param {string | symbol} type\n * @param {...any} [args]\n * @returns {boolean}\n */\nEventEmitter.prototype.emit = function emit(type, ...args) {\n  let doError = (type === 'error');\n\n  const events = this._events;\n  if (events !== undefined) {\n    if (doError && events[kErrorMonitor] !== undefined)\n      this.emit(kErrorMonitor, ...args);\n    doError = (doError && events.error === undefined);\n  } else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    let er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      try {\n        const capture = {};\n        ErrorCaptureStackTrace(capture, EventEmitter.prototype.emit);\n      } catch (e) {}\n\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n\n    let stringifiedEr;\n    try {\n      stringifiedEr = inspect(er);\n    } catch (e) {\n      stringifiedEr = er;\n    }\n\n    // At least give some kind of context to the user\n    const err = new ERR_UNHANDLED_ERROR(stringifiedEr);\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  const handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    const result = handler.apply(this, args);\n\n    // We check if result is undefined first because that\n    // is the most common case so we do not pay any perf\n    // penalty\n    if (result !== undefined && result !== null) {\n      addCatch(this, result, type, args);\n    }\n  } else {\n    const len = handler.length;\n    const listeners = arrayClone(handler);\n    for (let i = 0; i < len; ++i) {\n      const result = listeners[i].apply(this, args);\n\n      // We check if result is undefined first because that\n      // is the most common case so we do not pay any perf\n      // penalty.\n      // This code is duplicated because extracting it away\n      // would make it non-inlineable.\n      if (result !== undefined && result !== null) {\n        addCatch(this, result, type, args);\n      }\n    }\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  let m;\n  let events;\n  let existing;\n\n  checkListener(listener);\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = ObjectCreate(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  nc(listener.listener, listener));\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = _getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      const w = new Error('Possible EventEmitter memory leak detected. ' +\n                          `${existing.length} ${String(type)} listeners ` +\n                          `added to ${inspect(target, { depth: -1 })}. Use ` +\n                          'emitter.setMaxListeners() to increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      process.emitWarning(w);\n    }\n  }\n\n  return target;\n}\n\n/**\n * Adds a listener to the event emitter.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\n/**\n * Adds the `listener` function to the beginning of\n * the listeners array.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    if (arguments.length === 0)\n      return this.listener.call(this.target);\n    return this.listener.apply(this.target, arguments);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  const state = { fired: false, wrapFn: undefined, target, type, listener };\n  const wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\n/**\n * Adds a one-time `listener` function to the event emitter.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.once = function once(type, listener) {\n  checkListener(listener);\n\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\n/**\n * Adds a one-time `listener` function to the beginning of\n * the listeners array.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      checkListener(listener);\n\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n\n/**\n * Removes the specified `listener` from the listeners array.\n * @param {string | symbol} type\n * @param {Function} listener\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      checkListener(listener);\n\n      const events = this._events;\n      if (events === undefined)\n        return this;\n\n      const list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = ObjectCreate(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        let position = -1;\n\n        for (let i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\n/**\n * Removes all listeners from the event emitter. (Only\n * removes listeners for a specific event name if specified\n * as `type`).\n * @param {string | symbol} [type]\n * @returns {EventEmitter}\n */\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      const events = this._events;\n      if (events === undefined)\n        return this;\n\n      // Not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = ObjectCreate(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = ObjectCreate(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // Emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        for (const key of ReflectOwnKeys(events)) {\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = ObjectCreate(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      const listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (let i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  const events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  const evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener);\n}\n\n/**\n * Returns a copy of the array of listeners for the event name\n * specified as `type`.\n * @param {string | symbol} type\n * @returns {Function[]}\n */\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\n/**\n * Returns a copy of the array of listeners and wrappers for\n * the event name specified as `type`.\n * @param {string | symbol} type\n * @returns {Function[]}\n */\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\n/**\n * Returns the number of listeners listening to the event name\n * specified as `type`.\n * @deprecated since v3.2.0\n * @param {EventEmitter} emitter\n * @param {string | symbol} type\n * @returns {number}\n */\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  }\n  return emitter.listenerCount(type);\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\n\n/**\n * Returns the number of listeners listening to event name\n * specified as `type`.\n * @param {string | symbol} type\n * @returns {number}\n */\nfunction listenerCount(type) {\n  const events = this._events;\n\n  if (events !== undefined) {\n    const evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\n/**\n * Returns an array listing the events for which\n * the emitter has registered listeners.\n * @returns {any[]}\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr) {\n  // At least since V8 8.3, this implementation is faster than the previous\n  // which always used a simple for-loop\n  switch (arr.length) {\n    case 2: return [arr[0], arr[1]];\n    case 3: return [arr[0], arr[1], arr[2]];\n    case 4: return [arr[0], arr[1], arr[2], arr[3]];\n    case 5: return [arr[0], arr[1], arr[2], arr[3], arr[4]];\n    case 6: return [arr[0], arr[1], arr[2], arr[3], arr[4], arr[5]];\n  }\n  return ArrayPrototypeSlice(arr);\n}\n\nfunction unwrapListeners(arr) {\n  const ret = arrayClone(arr);\n  for (let i = 0; i < ret.length; ++i) {\n    const orig = ret[i].listener;\n    if (typeof orig === 'function')\n      ret[i] = orig;\n  }\n  return ret;\n}\n","\nconst {Parser: AcornParser, isNewLine: acornIsNewLine, getLineInfo: acornGetLineInfo} = require('acorn');\nconst {full: acornWalkFull} = require('acorn-walk');\n\nconst INTERNAL_STATE_NAME = 'VM2_INTERNAL_STATE_DO_NOT_USE_OR_PROGRAM_WILL_FAIL';\n\nfunction assertType(node, type) {\n\tif (!node) throw new Error(`None existent node expected '${type}'`);\n\tif (node.type !== type) throw new Error(`Invalid node type '${node.type}' expected '${type}'`);\n\treturn node;\n}\n\nfunction makeNiceSyntaxError(message, code, filename, location, tokenizer) {\n\tconst loc = acornGetLineInfo(code, location);\n\tlet end = location;\n\twhile (end < code.length && !acornIsNewLine(code.charCodeAt(end))) {\n\t\tend++;\n\t}\n\tlet markerEnd = tokenizer.start === location ? tokenizer.end : location + 1;\n\tif (!markerEnd || markerEnd > end) markerEnd = end;\n\tlet markerLen = markerEnd - location;\n\tif (markerLen <= 0) markerLen = 1;\n\tif (message === 'Unexpected token') {\n\t\tconst type = tokenizer.type;\n\t\tif (type.label === 'name' || type.label === 'privateId') {\n\t\t\tmessage = 'Unexpected identifier';\n\t\t} else if (type.label === 'eof') {\n\t\t\tmessage = 'Unexpected end of input';\n\t\t} else if (type.label === 'num') {\n\t\t\tmessage = 'Unexpected number';\n\t\t} else if (type.label === 'string') {\n\t\t\tmessage = 'Unexpected string';\n\t\t} else if (type.label === 'regexp') {\n\t\t\tmessage = 'Unexpected token \\'/\\'';\n\t\t\tmarkerLen = 1;\n\t\t} else {\n\t\t\tconst token = tokenizer.value || type.label;\n\t\t\tmessage = `Unexpected token '${token}'`;\n\t\t}\n\t}\n\tconst error = new SyntaxError(message);\n\tif (!filename) return error;\n\tconst line = code.slice(location - loc.column, end);\n\tconst marker = line.slice(0, loc.column).replace(/\\S/g, ' ') + '^'.repeat(markerLen);\n\terror.stack = `${filename}:${loc.line}\\n${line}\\n${marker}\\n\\n${error.stack}`;\n\treturn error;\n}\n\nfunction transformer(args, body, isAsync, isGenerator, filename) {\n\tlet code;\n\tlet argsOffset;\n\tif (args === null) {\n\t\tcode = body;\n\t\t// Note: Keywords are not allows to contain u escapes\n\t\tif (!/\\b(?:catch|import|async)\\b/.test(code)) {\n\t\t\treturn {__proto__: null, code, hasAsync: false};\n\t\t}\n\t} else {\n\t\tcode = isAsync ? '(async function' : '(function';\n\t\tif (isGenerator) code += '*';\n\t\tcode += ' anonymous(';\n\t\tcode += args;\n\t\targsOffset = code.length;\n\t\tcode += '\\n) {\\n';\n\t\tcode += body;\n\t\tcode += '\\n})';\n\t}\n\n\tconst parser = new AcornParser({\n\t\t__proto__: null,\n\t\tecmaVersion: 2022,\n\t\tallowAwaitOutsideFunction: args === null && isAsync,\n\t\tallowReturnOutsideFunction: args === null\n\t}, code);\n\tlet ast;\n\ttry {\n\t\tast = parser.parse();\n\t} catch (e) {\n\t\t// Try to generate a nicer error message.\n\t\tif (e instanceof SyntaxError && e.pos !== undefined) {\n\t\t\tlet message = e.message;\n\t\t\tconst match = message.match(/^(.*) \\(\\d+:\\d+\\)$/);\n\t\t\tif (match) message = match[1];\n\t\t\te = makeNiceSyntaxError(message, code, filename, e.pos, parser);\n\t\t}\n\t\tthrow e;\n\t}\n\n\tif (args !== null) {\n\t\tconst pBody = assertType(ast, 'Program').body;\n\t\tif (pBody.length !== 1) throw new SyntaxError('Single function literal required');\n\t\tconst expr = pBody[0];\n\t\tif (expr.type !== 'ExpressionStatement') throw new SyntaxError('Single function literal required');\n\t\tconst func = expr.expression;\n\t\tif (func.type !== 'FunctionExpression') throw new SyntaxError('Single function literal required');\n\t\tif (func.body.start !== argsOffset + 3) throw new SyntaxError('Unexpected end of arg string');\n\t}\n\n\tconst insertions = [];\n\tlet hasAsync = false;\n\n\tconst TO_LEFT = -100;\n\tconst TO_RIGHT = 100;\n\n\tlet internStateValiable = undefined;\n\n\tacornWalkFull(ast, (node, state, type) => {\n\t\tif (type === 'Function') {\n\t\t\tif (node.async) hasAsync = true;\n\t\t}\n\t\tconst nodeType = node.type;\n\t\tif (nodeType === 'CatchClause') {\n\t\t\tconst param = node.param;\n\t\t\tif (param) {\n\t\t\t\tconst name = assertType(param, 'Identifier').name;\n\t\t\t\tconst cBody = assertType(node.body, 'BlockStatement');\n\t\t\t\tif (cBody.body.length > 0) {\n\t\t\t\t\tinsertions.push({\n\t\t\t\t\t\t__proto__: null,\n\t\t\t\t\t\tpos: cBody.body[0].start,\n\t\t\t\t\t\torder: TO_LEFT,\n\t\t\t\t\t\tcode: `${name}=${INTERNAL_STATE_NAME}.handleException(${name});`\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (nodeType === 'WithStatement') {\n\t\t\tinsertions.push({\n\t\t\t\t__proto__: null,\n\t\t\t\tpos: node.object.start,\n\t\t\t\torder: TO_LEFT,\n\t\t\t\tcode: INTERNAL_STATE_NAME + '.wrapWith('\n\t\t\t});\n\t\t\tinsertions.push({\n\t\t\t\t__proto__: null,\n\t\t\t\tpos: node.object.end,\n\t\t\t\torder: TO_RIGHT,\n\t\t\t\tcode: ')'\n\t\t\t});\n\t\t} else if (nodeType === 'Identifier') {\n\t\t\tif (node.name === INTERNAL_STATE_NAME) {\n\t\t\t\tif (internStateValiable === undefined || internStateValiable.start > node.start) {\n\t\t\t\t\tinternStateValiable = node;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (nodeType === 'ImportExpression') {\n\t\t\tinsertions.push({\n\t\t\t\t__proto__: null,\n\t\t\t\tpos: node.start,\n\t\t\t\torder: TO_RIGHT,\n\t\t\t\tcode: INTERNAL_STATE_NAME + '.'\n\t\t\t});\n\t\t}\n\t});\n\n\tif (internStateValiable) {\n\t\tthrow makeNiceSyntaxError('Use of internal vm2 state variable', code, filename, internStateValiable.start, {\n\t\t\t__proto__: null,\n\t\t\tstart: internStateValiable.start,\n\t\t\tend: internStateValiable.end\n\t\t});\n\t}\n\n\tif (insertions.length === 0) return {__proto__: null, code, hasAsync};\n\n\tinsertions.sort((a, b) => (a.pos == b.pos ? a.order - b.order : a.pos - b.pos));\n\n\tlet ncode = '';\n\tlet curr = 0;\n\tfor (let i = 0; i < insertions.length; i++) {\n\t\tconst change = insertions[i];\n\t\tncode += code.substring(curr, change.pos) + change.code;\n\t\tcurr = change.pos;\n\t}\n\tncode += code.substring(curr);\n\n\treturn {__proto__: null, code: ncode, hasAsync};\n}\n\nexports.INTERNAL_STATE_NAME = INTERNAL_STATE_NAME;\nexports.transformer = transformer;\n","\n\nconst {\n\tVMError\n} = require('./bridge');\n\nlet cacheCoffeeScriptCompiler;\n\n/**\n * Returns the cached coffee script compiler or loads it\n * if it is not found in the cache.\n *\n * @private\n * @return {compileCallback} The coffee script compiler.\n * @throws {VMError} If the coffee-script module can't be found.\n */\nfunction getCoffeeScriptCompiler() {\n\tif (!cacheCoffeeScriptCompiler) {\n\t\ttry {\n\t\t\t// The warning generated by webpack can be disabled by setting:\n\t\t\t// ignoreWarnings[].message = /Can't resolve 'coffee-script'/\n\t\t\t/* eslint-disable-next-line global-require */\n\t\t\tconst coffeeScript = require('coffee-script');\n\t\t\tcacheCoffeeScriptCompiler = (code, filename) => {\n\t\t\t\treturn coffeeScript.compile(code, {header: false, bare: true});\n\t\t\t};\n\t\t} catch (e) {\n\t\t\tthrow new VMError('Coffee-Script compiler is not installed.');\n\t\t}\n\t}\n\treturn cacheCoffeeScriptCompiler;\n}\n\n/**\n * Remove the shebang from source code.\n *\n * @private\n * @param {string} code - Code from which to remove the shebang.\n * @return {string} code without the shebang.\n */\nfunction removeShebang(code) {\n\tif (!code.startsWith('#!')) return code;\n\treturn '//' + code.substring(2);\n}\n\n\n/**\n * The JavaScript compiler, just a identity function.\n *\n * @private\n * @type {compileCallback}\n * @param {string} code - The JavaScript code.\n * @param {string} filename - Filename of this script.\n * @return {string} The code.\n */\nfunction jsCompiler(code, filename) {\n\treturn removeShebang(code);\n}\n\n/**\n * Look up the compiler for a specific name.\n *\n * @private\n * @param {(string|compileCallback)} compiler - A compile callback or the name of the compiler.\n * @return {compileCallback} The resolved compiler.\n * @throws {VMError} If the compiler is unknown or the coffee script module was needed and couldn't be found.\n */\nfunction lookupCompiler(compiler) {\n\tif ('function' === typeof compiler) return compiler;\n\tswitch (compiler) {\n\t\tcase 'coffeescript':\n\t\tcase 'coffee-script':\n\t\tcase 'cs':\n\t\tcase 'text/coffeescript':\n\t\t\treturn getCoffeeScriptCompiler();\n\t\tcase 'javascript':\n\t\tcase 'java-script':\n\t\tcase 'js':\n\t\tcase 'text/javascript':\n\t\t\treturn jsCompiler;\n\t\tdefault:\n\t\t\tthrow new VMError(`Unsupported compiler '${compiler}'.`);\n\t}\n}\n\nexports.removeShebang = removeShebang;\nexports.lookupCompiler = lookupCompiler;\n","\n\n/**\n * This callback will be called to resolve a module if it couldn't be found.\n *\n * @callback resolveCallback\n * @param {string} moduleName - Name of the module used to resolve.\n * @param {string} dirname - Name of the current directory.\n * @return {(string|undefined)} The file or directory to use to load the requested module.\n */\n\n/**\n * This callback will be called to require a module instead of node's require.\n *\n * @callback customRequire\n * @param {string} moduleName - Name of the module requested.\n * @return {*} The required module object.\n */\n\nconst fs = require('fs');\nconst pa = require('path');\nconst {\n\tScript\n} = require('vm');\nconst {\n\tVMError\n} = require('./bridge');\nconst {\n\tVMScript,\n\tMODULE_PREFIX,\n\tSTRICT_MODULE_PREFIX,\n\tMODULE_SUFFIX\n} = require('./script');\nconst {\n\ttransformer\n} = require('./transformer');\nconst {\n\tVM\n} = require('./vm');\nconst {\n\tresolverFromOptions\n} = require('./resolver-compat');\n\nconst objectDefineProperty = Object.defineProperty;\nconst objectDefineProperties = Object.defineProperties;\n\n/**\n * Host objects\n *\n * @private\n */\nconst HOST = Object.freeze({\n\t__proto__: null,\n\tversion: parseInt(process.versions.node.split('.')[0]),\n\tprocess,\n\tconsole,\n\tsetTimeout,\n\tsetInterval,\n\tsetImmediate,\n\tclearTimeout,\n\tclearInterval,\n\tclearImmediate\n});\n\n/**\n * Compile a script.\n *\n * @private\n * @param {string} filename - Filename of the script.\n * @param {string} script - Script.\n * @return {vm.Script} The compiled script.\n */\nfunction compileScript(filename, script) {\n\treturn new Script(script, {\n\t\t__proto__: null,\n\t\tfilename,\n\t\tdisplayErrors: false\n\t});\n}\n\nlet cacheSandboxScript = null;\nlet cacheMakeNestingScript = null;\n\nconst NESTING_OVERRIDE = Object.freeze({\n\t__proto__: null,\n\tvm2: vm2NestingLoader\n});\n\n/**\n * Event caused by a <code>console.debug</code> call if <code>options.console=\"redirect\"</code> is specified.\n *\n * @public\n * @event NodeVM.\"console.debug\"\n * @type {...*}\n */\n\n/**\n * Event caused by a <code>console.log</code> call if <code>options.console=\"redirect\"</code> is specified.\n *\n * @public\n * @event NodeVM.\"console.log\"\n * @type {...*}\n */\n\n/**\n * Event caused by a <code>console.info</code> call if <code>options.console=\"redirect\"</code> is specified.\n *\n * @public\n * @event NodeVM.\"console.info\"\n * @type {...*}\n */\n\n/**\n * Event caused by a <code>console.warn</code> call if <code>options.console=\"redirect\"</code> is specified.\n *\n * @public\n * @event NodeVM.\"console.warn\"\n * @type {...*}\n */\n\n/**\n * Event caused by a <code>console.error</code> call if <code>options.console=\"redirect\"</code> is specified.\n *\n * @public\n * @event NodeVM.\"console.error\"\n * @type {...*}\n */\n\n/**\n * Event caused by a <code>console.dir</code> call if <code>options.console=\"redirect\"</code> is specified.\n *\n * @public\n * @event NodeVM.\"console.dir\"\n * @type {...*}\n */\n\n/**\n * Event caused by a <code>console.trace</code> call if <code>options.console=\"redirect\"</code> is specified.\n *\n * @public\n * @event NodeVM.\"console.trace\"\n * @type {...*}\n */\n\n/**\n * Class NodeVM.\n *\n * @public\n * @extends {VM}\n * @extends {EventEmitter}\n */\nclass NodeVM extends VM {\n\n\t/**\n\t * Create a new NodeVM instance.<br>\n\t *\n\t * Unlike VM, NodeVM lets you use require same way like in regular node.<br>\n\t *\n\t * However, it does not use the timeout.\n\t *\n\t * @public\n\t * @param {Object} [options] - VM options.\n\t * @param {Object} [options.sandbox] - Objects that will be copied into the global object of the sandbox.\n\t * @param {(string|compileCallback)} [options.compiler=\"javascript\"] - The compiler to use.\n\t * @param {boolean} [options.eval=true] - Allow the dynamic evaluation of code via eval(code) or Function(code)().<br>\n\t * Only available for node v10+.\n\t * @param {boolean} [options.wasm=true] - Allow to run wasm code.<br>\n\t * Only available for node v10+.\n\t * @param {(\"inherit\"|\"redirect\"|\"off\")} [options.console=\"inherit\"] - Sets the behavior of the console in the sandbox.\n\t * <code>inherit</code> to enable console, <code>redirect</code> to redirect to events, <code>off</code> to disable console.\n\t * @param {Object|boolean} [options.require=false] - Allow require inside the sandbox.\n\t * @param {(boolean|string[]|Object)} [options.require.external=false] - <b>WARNING: When allowing require the option <code>options.require.root</code>\n\t * should be set to restrict the script from requiring any module. Values can be true, an array of allowed external modules or an object.\n\t * @param {(string[])} [options.require.external.modules] - Array of allowed external modules. Also supports wildcards, so specifying ['@scope/*-ver-??],\n\t * for instance, will allow using all modules having a name of the form @scope/something-ver-aa, @scope/other-ver-11, etc.\n\t * @param {boolean} [options.require.external.transitive=false] - Boolean which indicates if transitive dependencies of external modules are allowed.\n\t * @param {string[]} [options.require.builtin=[]] - Array of allowed built-in modules, accepts [\"*\"] for all.\n\t * @param {(string|string[])} [options.require.root] - Restricted path(s) where local modules can be required. If omitted every path is allowed.\n\t * @param {Object} [options.require.mock] - Collection of mock modules (both external or built-in).\n\t * @param {(\"host\"|\"sandbox\")} [options.require.context=\"host\"] - <code>host</code> to require modules in host and proxy them to sandbox.\n\t * <code>sandbox</code> to load, compile and require modules in sandbox.\n\t * Builtin modules except <code>events</code> always required in host and proxied to sandbox.\n\t * @param {string[]} [options.require.import] - Array of modules to be loaded into NodeVM on start.\n\t * @param {resolveCallback} [options.require.resolve] - An additional lookup function in case a module wasn't\n\t * found in one of the traditional node lookup paths.\n\t * @param {customRequire} [options.require.customRequire=require] - Custom require to require host and built-in modules.\n\t * @param {boolean} [option.require.strict=true] - Load required modules in strict mode.\n\t * @param {boolean} [options.nesting=false] -\n\t * <b>WARNING: Allowing this is a security risk as scripts can create a NodeVM which can require any host module.</b>\n\t * Allow nesting of VMs.\n\t * @param {(\"commonjs\"|\"none\")} [options.wrapper=\"commonjs\"] - <code>commonjs</code> to wrap script into CommonJS wrapper,\n\t * <code>none</code> to retrieve value returned by the script.\n\t * @param {string[]} [options.sourceExtensions=[\"js\"]] - Array of file extensions to treat as source code.\n\t * @param {string[]} [options.argv=[]] - Array of arguments passed to <code>process.argv</code>.\n\t * This object will not be copied and the script can change this object.\n\t * @param {Object} [options.env={}] - Environment map passed to <code>process.env</code>.\n\t * This object will not be copied and the script can change this object.\n\t * @param {boolean} [options.strict=false] - If modules should be loaded in strict mode.\n\t * @throws {VMError} If the compiler is unknown.\n\t */\n\tconstructor(options = {}) {\n\t\tconst {\n\t\t\tcompiler,\n\t\t\teval: allowEval,\n\t\t\twasm,\n\t\t\tconsole: consoleType = 'inherit',\n\t\t\trequire: requireOpts = false,\n\t\t\tnesting = false,\n\t\t\twrapper = 'commonjs',\n\t\t\tsourceExtensions = ['js'],\n\t\t\targv,\n\t\t\tenv,\n\t\t\tstrict = false,\n\t\t\tsandbox\n\t\t} = options;\n\n\t\t// Throw this early\n\t\tif (sandbox && 'object' !== typeof sandbox) {\n\t\t\tthrow new VMError('Sandbox must be an object.');\n\t\t}\n\n\t\tsuper({__proto__: null, compiler: compiler, eval: allowEval, wasm});\n\n\t\t// This is only here for backwards compatibility.\n\t\tobjectDefineProperty(this, 'options', {__proto__: null, value: {\n\t\t\tconsole: consoleType,\n\t\t\trequire: requireOpts,\n\t\t\tnesting,\n\t\t\twrapper,\n\t\t\tsourceExtensions,\n\t\t\tstrict\n\t\t}});\n\n\t\tconst resolver = resolverFromOptions(this, requireOpts, nesting && NESTING_OVERRIDE, this._compiler);\n\n\t\tobjectDefineProperty(this, '_resolver', {__proto__: null, value: resolver});\n\n\t\tif (!cacheSandboxScript) {\n\t\t\tcacheSandboxScript = compileScript(`${__dirname}/setup-node-sandbox.js`,\n\t\t\t\t`(function (host, data) { ${fs.readFileSync(`${__dirname}/setup-node-sandbox.js`, 'utf8')}\\n})`);\n\t\t}\n\n\t\tconst closure = this._runScript(cacheSandboxScript);\n\n\t\tconst extensions = {\n\t\t\t__proto__: null\n\t\t};\n\n\t\tconst loadJS = (mod, filename) => resolver.loadJS(this, mod, filename);\n\n\t\tfor (let i = 0; i < sourceExtensions.length; i++) {\n\t\t\textensions['.' + sourceExtensions[i]] = loadJS;\n\t\t}\n\n\t\tif (!extensions['.json']) extensions['.json'] = (mod, filename) => resolver.loadJSON(this, mod, filename);\n\t\tif (!extensions['.node']) extensions['.node'] = (mod, filename) => resolver.loadNode(this, mod, filename);\n\n\n\t\tthis.readonly(HOST);\n\t\tthis.readonly(resolver);\n\t\tthis.readonly(this);\n\n\t\tconst {\n\t\t\tModule,\n\t\t\tjsonParse,\n\t\t\tcreateRequireForModule,\n\t\t\trequireImpl\n\t\t} = closure(HOST, {\n\t\t\t__proto__: null,\n\t\t\targv,\n\t\t\tenv,\n\t\t\tconsole: consoleType,\n\t\t\tvm: this,\n\t\t\tresolver,\n\t\t\textensions\n\t\t});\n\n\t\tobjectDefineProperties(this, {\n\t\t\t__proto__: null,\n\t\t\t_Module: {__proto__: null, value: Module},\n\t\t\t_jsonParse: {__proto__: null, value: jsonParse},\n\t\t\t_createRequireForModule: {__proto__: null, value: createRequireForModule},\n\t\t\t_requireImpl: {__proto__: null, value: requireImpl},\n\t\t\t_cacheRequireModule: {__proto__: null, value: null, writable: true}\n\t\t});\n\n\n\t\tresolver.init(this);\n\n\t\t// prepare global sandbox\n\t\tif (sandbox) {\n\t\t\tthis.setGlobals(sandbox);\n\t\t}\n\n\t\tif (requireOpts && requireOpts.import) {\n\t\t\tif (Array.isArray(requireOpts.import)) {\n\t\t\t\tfor (let i = 0, l = requireOpts.import.length; i < l; i++) {\n\t\t\t\t\tthis.require(requireOpts.import[i]);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.require(requireOpts.import);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @ignore\n\t * @deprecated Just call the method yourself like <code>method(args);</code>\n\t * @param {function} method - Function to invoke.\n\t * @param {...*} args - Arguments to pass to the function.\n\t * @return {*} Return value of the function.\n\t * @todo Can we remove this function? It even had a bug that would use args as this parameter.\n\t * @throws {*} Rethrows anything the method throws.\n\t * @throws {VMError} If method is not a function.\n\t * @throws {Error} If method is a class.\n\t */\n\tcall(method, ...args) {\n\t\tif ('function' === typeof method) {\n\t\t\treturn method(...args);\n\t\t} else {\n\t\t\tthrow new VMError('Unrecognized method type.');\n\t\t}\n\t}\n\n\t/**\n\t * Require a module in VM and return it's exports.\n\t *\n\t * @public\n\t * @param {string} module - Module name.\n\t * @return {*} Exported module.\n\t * @throws {*} If the module couldn't be found or loading it threw an error.\n\t */\n\trequire(module) {\n\t\tconst path = this._resolver.pathResolve('.');\n\t\tlet mod = this._cacheRequireModule;\n\t\tif (!mod || mod.path !== path) {\n\t\t\tconst filename = this._resolver.pathConcat(path, '/vm.js');\n\t\t\tmod = new (this._Module)(filename, path);\n\t\t\tthis._resolver.registerModule(mod, filename, path, null, false);\n\t\t\tthis._cacheRequireModule = mod;\n\t\t}\n\t\treturn this._requireImpl(mod, module, true);\n\t}\n\n\t/**\n\t * Run the code in NodeVM.\n\t *\n\t * First time you run this method, code is executed same way like in node's regular `require` - it's executed with\n\t * `module`, `require`, `exports`, `__dirname`, `__filename` variables and expect result in `module.exports'.\n\t *\n\t * @param {(string|VMScript)} code - Code to run.\n\t * @param {(string|Object)} [options] - Options map or filename.\n\t * @param {string} [options.filename=\"vm.js\"] - Filename that shows up in any stack traces produced from this script.<br>\n\t * This is only used if code is a String.\n\t * @param {boolean} [options.strict] - If modules should be loaded in strict mode. Defaults to NodeVM options.\n\t * @param {(\"commonjs\"|\"none\")} [options.wrapper] - <code>commonjs</code> to wrap script into CommonJS wrapper,\n\t * <code>none</code> to retrieve value returned by the script. Defaults to NodeVM options.\n\t * @return {*} Result of executed code.\n\t * @throws {SyntaxError} If there is a syntax error in the script.\n\t * @throws {*} If the script execution terminated with an exception it is propagated.\n\t * @fires NodeVM.\"console.debug\"\n\t * @fires NodeVM.\"console.log\"\n\t * @fires NodeVM.\"console.info\"\n\t * @fires NodeVM.\"console.warn\"\n\t * @fires NodeVM.\"console.error\"\n\t * @fires NodeVM.\"console.dir\"\n\t * @fires NodeVM.\"console.trace\"\n\t */\n\trun(code, options) {\n\t\tlet script;\n\t\tlet filename;\n\n\t\tif (typeof options === 'object') {\n\t\t\tfilename = options.filename;\n\t\t} else {\n\t\t\tfilename = options;\n\t\t\toptions = {__proto__: null};\n\t\t}\n\n\t\tconst {\n\t\t\tstrict = this.options.strict,\n\t\t\twrapper = this.options.wrapper,\n\t\t\tmodule: customModule,\n\t\t\trequire: customRequire,\n\t\t\tdirname: customDirname = null\n\t\t} = options;\n\n\t\tlet sandboxModule = customModule;\n\t\tlet dirname = customDirname;\n\n\t\tif (code instanceof VMScript) {\n\t\t\tscript = strict ? code._compileNodeVMStrict() : code._compileNodeVM();\n\t\t\tif (!sandboxModule) {\n\t\t\t\tconst resolvedFilename = this._resolver.pathResolve(code.filename);\n\t\t\t\tdirname = this._resolver.pathDirname(resolvedFilename);\n\t\t\t\tsandboxModule = new (this._Module)(resolvedFilename, dirname);\n\t\t\t\tthis._resolver.registerModule(sandboxModule, resolvedFilename, dirname, null, false);\n\t\t\t}\n\t\t} else {\n\t\t\tconst unresolvedFilename = filename || 'vm.js';\n\t\t\tif (!sandboxModule) {\n\t\t\t\tif (filename) {\n\t\t\t\t\tconst resolvedFilename = this._resolver.pathResolve(filename);\n\t\t\t\t\tdirname = this._resolver.pathDirname(resolvedFilename);\n\t\t\t\t\tsandboxModule = new (this._Module)(resolvedFilename, dirname);\n\t\t\t\t\tthis._resolver.registerModule(sandboxModule, resolvedFilename, dirname, null, false);\n\t\t\t\t} else {\n\t\t\t\t\tsandboxModule = new (this._Module)(null, null);\n\t\t\t\t\tsandboxModule.id = unresolvedFilename;\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst prefix = strict ? STRICT_MODULE_PREFIX : MODULE_PREFIX;\n\t\t\tlet scriptCode = this._compiler(code, unresolvedFilename);\n\t\t\tscriptCode = transformer(null, scriptCode, false, false, unresolvedFilename).code;\n\t\t\tscript = new Script(prefix + scriptCode + MODULE_SUFFIX, {\n\t\t\t\t__proto__: null,\n\t\t\t\tfilename: unresolvedFilename,\n\t\t\t\tdisplayErrors: false\n\t\t\t});\n\t\t}\n\n\t\tconst closure = this._runScript(script);\n\n\t\tconst usedRequire = customRequire || this._createRequireForModule(sandboxModule);\n\n\t\tconst ret = Reflect.apply(closure, this.sandbox, [sandboxModule.exports, usedRequire, sandboxModule, filename, dirname]);\n\t\treturn wrapper === 'commonjs' ? sandboxModule.exports : ret;\n\t}\n\n\t/**\n\t * Create NodeVM and run code inside it.\n\t *\n\t * @public\n\t * @static\n\t * @param {string} script - Code to execute.\n\t * @param {string} [filename] - File name (used in stack traces only).\n\t * @param {Object} [options] - VM options.\n\t * @param {string} [options.filename] - File name (used in stack traces only). Used if <code>filename</code> is omitted.\n\t * @return {*} Result of executed code.\n\t * @see {@link NodeVM} for the options.\n\t * @throws {SyntaxError} If there is a syntax error in the script.\n\t * @throws {*} If the script execution terminated with an exception it is propagated.\n\t */\n\tstatic code(script, filename, options) {\n\t\tlet unresolvedFilename;\n\t\tif (filename != null) {\n\t\t\tif ('object' === typeof filename) {\n\t\t\t\toptions = filename;\n\t\t\t\tunresolvedFilename = options.filename;\n\t\t\t} else if ('string' === typeof filename) {\n\t\t\t\tunresolvedFilename = filename;\n\t\t\t} else {\n\t\t\t\tthrow new VMError('Invalid arguments.');\n\t\t\t}\n\t\t} else if ('object' === typeof options) {\n\t\t\tunresolvedFilename = options.filename;\n\t\t}\n\n\t\tif (arguments.length > 3) {\n\t\t\tthrow new VMError('Invalid number of arguments.');\n\t\t}\n\n\t\tconst resolvedFilename = typeof unresolvedFilename === 'string' ? pa.resolve(unresolvedFilename) : undefined;\n\n\t\treturn new NodeVM(options).run(script, resolvedFilename);\n\t}\n\n\t/**\n\t * Create NodeVM and run script from file inside it.\n\t *\n\t * @public\n\t * @static\n\t * @param {string} filename - Filename of file to load and execute in a NodeVM.\n\t * @param {Object} [options] - NodeVM options.\n\t * @return {*} Result of executed code.\n\t * @see {@link NodeVM} for the options.\n\t * @throws {Error} If filename is not a valid filename.\n\t * @throws {SyntaxError} If there is a syntax error in the script.\n\t * @throws {*} If the script execution terminated with an exception it is propagated.\n\t */\n\tstatic file(filename, options) {\n\t\tconst resolvedFilename = pa.resolve(filename);\n\n\t\tif (!fs.existsSync(resolvedFilename)) {\n\t\t\tthrow new VMError(`Script '${filename}' not found.`);\n\t\t}\n\n\t\tif (fs.statSync(resolvedFilename).isDirectory()) {\n\t\t\tthrow new VMError('Script must be file, got directory.');\n\t\t}\n\n\t\treturn new NodeVM(options).run(fs.readFileSync(resolvedFilename, 'utf8'), resolvedFilename);\n\t}\n}\n\nfunction vm2NestingLoader(resolver, vm, id) {\n\tif (!cacheMakeNestingScript) {\n\t\tcacheMakeNestingScript = compileScript('nesting.js', '(vm, nodevm) => ({VM: vm, NodeVM: nodevm})');\n\t}\n\tconst makeNesting = vm._runScript(cacheMakeNestingScript);\n\treturn makeNesting(vm.readonly(VM), vm.readonly(NodeVM));\n}\n\nexports.NodeVM = NodeVM;\n","\n\n// Translate the old options to the new Resolver functionality.\n\nconst fs = require('fs');\nconst pa = require('path');\nconst nmod = require('module');\nconst {EventEmitter} = require('events');\nconst util = require('util');\n\nconst {\n\tResolver,\n\tDefaultResolver\n} = require('./resolver');\nconst {VMScript} = require('./script');\nconst {VM} = require('./vm');\nconst {VMError} = require('./bridge');\n\n/**\n * Require wrapper to be able to annotate require with webpackIgnore.\n *\n * @private\n * @param {string} moduleName - Name of module to load.\n * @return {*} Module exports.\n */\nfunction defaultRequire(moduleName) {\n\t// Set module.parser.javascript.commonjsMagicComments=true in your webpack config.\n\t// eslint-disable-next-line global-require\n\treturn require(/* webpackIgnore: true */ moduleName);\n}\n\n// source: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#Escaping\nfunction escapeRegExp(string) {\n\treturn string.replace(/[.*+\\-?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\nfunction makeExternalMatcherRegex(obj) {\n\treturn escapeRegExp(obj).replace(/\\\\\\\\|\\//g, '[\\\\\\\\/]')\n\t\t.replace(/\\\\\\*\\\\\\*/g, '.*').replace(/\\\\\\*/g, '[^\\\\\\\\/]*').replace(/\\\\\\?/g, '[^\\\\\\\\/]');\n}\n\nfunction makeExternalMatcher(obj) {\n\tconst regexString = makeExternalMatcherRegex(obj);\n\treturn new RegExp(`[\\\\\\\\/]node_modules[\\\\\\\\/]${regexString}(?:[\\\\\\\\/](?!(?:.*[\\\\\\\\/])?node_modules[\\\\\\\\/]).*)?$`);\n}\n\nclass LegacyResolver extends DefaultResolver {\n\n\tconstructor(builtinModules, checkPath, globalPaths, pathContext, customResolver, hostRequire, compiler, strict, externals, allowTransitive) {\n\t\tsuper(builtinModules, checkPath, globalPaths, pathContext, customResolver, hostRequire, compiler, strict);\n\t\tthis.externals = externals;\n\t\tthis.currMod = undefined;\n\t\tthis.trustedMods = new WeakMap();\n\t\tthis.allowTransitive = allowTransitive;\n\t}\n\n\tisPathAllowed(path) {\n\t\treturn this.isPathAllowedForModule(path, this.currMod);\n\t}\n\n\tisPathAllowedForModule(path, mod) {\n\t\tif (!super.isPathAllowed(path)) return false;\n\t\tif (mod) {\n\t\t\tif (mod.allowTransitive) return true;\n\t\t\tif (path.startsWith(mod.path)) {\n\t\t\t\tconst rem = path.slice(mod.path.length);\n\t\t\t\tif (!/(?:^|[\\\\\\\\/])node_modules(?:$|[\\\\\\\\/])/.test(rem)) return true;\n\t\t\t}\n\t\t}\n\t\treturn this.externals.some(regex => regex.test(path));\n\t}\n\n\tregisterModule(mod, filename, path, parent, direct) {\n\t\tconst trustedParent = this.trustedMods.get(parent);\n\t\tthis.trustedMods.set(mod, {\n\t\t\tfilename,\n\t\t\tpath,\n\t\t\tpaths: this.genLookupPaths(path),\n\t\t\tallowTransitive: this.allowTransitive &&\n\t\t\t\t((direct && trustedParent && trustedParent.allowTransitive) || this.externals.some(regex => regex.test(filename)))\n\t\t});\n\t}\n\n\tresolveFull(mod, x, options, ext, direct) {\n\t\tthis.currMod = undefined;\n\t\tif (!direct) return super.resolveFull(mod, x, options, ext, false);\n\t\tconst trustedMod = this.trustedMods.get(mod);\n\t\tif (!trustedMod || mod.path !== trustedMod.path) return super.resolveFull(mod, x, options, ext, false);\n\t\tconst paths = [...mod.paths];\n\t\tif (paths.length === trustedMod.length) {\n\t\t\tfor (let i = 0; i < paths.length; i++) {\n\t\t\t\tif (paths[i] !== trustedMod.paths[i]) {\n\t\t\t\t\treturn super.resolveFull(mod, x, options, ext, false);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tconst extCopy = Object.assign({__proto__: null}, ext);\n\t\ttry {\n\t\t\tthis.currMod = trustedMod;\n\t\t\treturn super.resolveFull(trustedMod, x, undefined, extCopy, true);\n\t\t} finally {\n\t\t\tthis.currMod = undefined;\n\t\t}\n\t}\n\n\tcheckAccess(mod, filename) {\n\t\tconst trustedMod = this.trustedMods.get(mod);\n\t\tif ((!trustedMod || trustedMod.filename !== filename) && !this.isPathAllowedForModule(filename, undefined)) {\n\t\t\tthrow new VMError(`Module '${filename}' is not allowed to be required. The path is outside the border!`, 'EDENIED');\n\t\t}\n\t}\n\n\tloadJS(vm, mod, filename) {\n\t\tfilename = this.pathResolve(filename);\n\t\tthis.checkAccess(mod, filename);\n\t\tif (this.pathContext(filename, 'js') === 'sandbox') {\n\t\t\tconst trustedMod = this.trustedMods.get(mod);\n\t\t\tconst script = this.readScript(filename);\n\t\t\tvm.run(script, {filename, strict: true, module: mod, wrapper: 'none', dirname: trustedMod ? trustedMod.path : mod.path});\n\t\t} else {\n\t\t\tconst m = this.hostRequire(filename);\n\t\t\tmod.exports = vm.readonly(m);\n\t\t}\n\t}\n\n}\n\nfunction defaultBuiltinLoader(resolver, vm, id) {\n\tconst mod = resolver.hostRequire(id);\n\treturn vm.readonly(mod);\n}\n\nconst eventsModules = new WeakMap();\n\nfunction defaultBuiltinLoaderEvents(resolver, vm, id) {\n\treturn eventsModules.get(vm);\n}\n\nlet cacheBufferScript;\n\nfunction defaultBuiltinLoaderBuffer(resolver, vm, id) {\n\tif (!cacheBufferScript) {\n\t\tcacheBufferScript = new VMScript('return buffer=>({Buffer: buffer});', {__proto__: null, filename: 'buffer.js'});\n\t}\n\tconst makeBuffer = vm.run(cacheBufferScript, {__proto__: null, strict: true, wrapper: 'none'});\n\treturn makeBuffer(Buffer);\n}\n\nlet cacheUtilScript;\n\nfunction defaultBuiltinLoaderUtil(resolver, vm, id) {\n\tif (!cacheUtilScript) {\n\t\tcacheUtilScript = new VMScript(`return function inherits(ctor, superCtor) {\n\t\t\tctor.super_ = superCtor;\n\t\t\tObject.setPrototypeOf(ctor.prototype, superCtor.prototype);\n\t\t}`, {__proto__: null, filename: 'util.js'});\n\t}\n\tconst inherits = vm.run(cacheUtilScript, {__proto__: null, strict: true, wrapper: 'none'});\n\tconst copy = Object.assign({}, util);\n\tcopy.inherits = inherits;\n\treturn vm.readonly(copy);\n}\n\nconst BUILTIN_MODULES = (nmod.builtinModules || Object.getOwnPropertyNames(process.binding('natives'))).filter(s=>!s.startsWith('internal/'));\n\nlet EventEmitterReferencingAsyncResourceClass = null;\nif (EventEmitter.EventEmitterAsyncResource) {\n\t// eslint-disable-next-line global-require\n\tconst {AsyncResource} = require('async_hooks');\n\tconst kEventEmitter = Symbol('kEventEmitter');\n\tclass EventEmitterReferencingAsyncResource extends AsyncResource {\n\t\tconstructor(ee, type, options) {\n\t\t\tsuper(type, options);\n\t\t\tthis[kEventEmitter] = ee;\n\t\t}\n\t\tget eventEmitter() {\n\t\t\treturn this[kEventEmitter];\n\t\t}\n\t}\n\tEventEmitterReferencingAsyncResourceClass = EventEmitterReferencingAsyncResource;\n}\n\nlet cacheEventsScript;\n\nconst SPECIAL_MODULES = {\n\tevents(vm) {\n\t\tif (!cacheEventsScript) {\n\t\t\tconst eventsSource = fs.readFileSync(`${__dirname}/events.js`, 'utf8');\n\t\t\tcacheEventsScript = new VMScript(`(function (fromhost) { const module = {}; module.exports={};{ ${eventsSource}\n} return module.exports;})`, {filename: 'events.js'});\n\t\t}\n\t\tconst closure = VM.prototype.run.call(vm, cacheEventsScript);\n\t\tconst eventsInstance = closure(vm.readonly({\n\t\t\tkErrorMonitor: EventEmitter.errorMonitor,\n\t\t\tonce: EventEmitter.once,\n\t\t\ton: EventEmitter.on,\n\t\t\tgetEventListeners: EventEmitter.getEventListeners,\n\t\t\tEventEmitterReferencingAsyncResource: EventEmitterReferencingAsyncResourceClass\n\t\t}));\n\t\teventsModules.set(vm, eventsInstance);\n\t\tvm._addProtoMapping(EventEmitter.prototype, eventsInstance.EventEmitter.prototype);\n\t\treturn defaultBuiltinLoaderEvents;\n\t},\n\tbuffer(vm) {\n\t\treturn defaultBuiltinLoaderBuffer;\n\t},\n\tutil(vm) {\n\t\treturn defaultBuiltinLoaderUtil;\n\t}\n};\n\nfunction addDefaultBuiltin(builtins, key, vm) {\n\tif (builtins[key]) return;\n\tconst special = SPECIAL_MODULES[key];\n\tbuiltins[key] = special ? special(vm) : defaultBuiltinLoader;\n}\n\n\nfunction genBuiltinsFromOptions(vm, builtinOpt, mockOpt, override) {\n\tconst builtins = {__proto__: null};\n\tif (mockOpt) {\n\t\tconst keys = Object.getOwnPropertyNames(mockOpt);\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tconst key = keys[i];\n\t\t\tbuiltins[key] = (resolver, tvm, id) => tvm.readonly(mockOpt[key]);\n\t\t}\n\t}\n\tif (override) {\n\t\tconst keys = Object.getOwnPropertyNames(override);\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tconst key = keys[i];\n\t\t\tbuiltins[key] = override[key];\n\t\t}\n\t}\n\tif (Array.isArray(builtinOpt)) {\n\t\tconst def = builtinOpt.indexOf('*') >= 0;\n\t\tif (def) {\n\t\t\tfor (let i = 0; i < BUILTIN_MODULES.length; i++) {\n\t\t\t\tconst name = BUILTIN_MODULES[i];\n\t\t\t\tif (builtinOpt.indexOf(`-${name}`) === -1) {\n\t\t\t\t\taddDefaultBuiltin(builtins, name, vm);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let i = 0; i < BUILTIN_MODULES.length; i++) {\n\t\t\t\tconst name = BUILTIN_MODULES[i];\n\t\t\t\tif (builtinOpt.indexOf(name) !== -1) {\n\t\t\t\t\taddDefaultBuiltin(builtins, name, vm);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else if (builtinOpt) {\n\t\tfor (let i = 0; i < BUILTIN_MODULES.length; i++) {\n\t\t\tconst name = BUILTIN_MODULES[i];\n\t\t\tif (builtinOpt[name]) {\n\t\t\t\taddDefaultBuiltin(builtins, name, vm);\n\t\t\t}\n\t\t}\n\t}\n\treturn builtins;\n}\n\nfunction defaultCustomResolver() {\n\treturn undefined;\n}\n\nconst DENY_RESOLVER = new Resolver({__proto__: null}, [], id => {\n\tthrow new VMError(`Access denied to require '${id}'`, 'EDENIED');\n});\n\nfunction resolverFromOptions(vm, options, override, compiler) {\n\tif (!options) {\n\t\tif (!override) return DENY_RESOLVER;\n\t\tconst builtins = genBuiltinsFromOptions(vm, undefined, undefined, override);\n\t\treturn new Resolver(builtins, [], defaultRequire);\n\t}\n\n\tconst {\n\t\tbuiltin: builtinOpt,\n\t\tmock: mockOpt,\n\t\texternal: externalOpt,\n\t\troot: rootPaths,\n\t\tresolve: customResolver,\n\t\tcustomRequire: hostRequire = defaultRequire,\n\t\tcontext = 'host',\n\t\tstrict = true,\n\t} = options;\n\n\tconst builtins = genBuiltinsFromOptions(vm, builtinOpt, mockOpt, override);\n\n\tif (!externalOpt) return new Resolver(builtins, [], hostRequire);\n\n\tlet checkPath;\n\tif (rootPaths) {\n\t\tconst checkedRootPaths = (Array.isArray(rootPaths) ? rootPaths : [rootPaths]).map(f => pa.resolve(f));\n\t\tcheckPath = (filename) => {\n\t\t\treturn checkedRootPaths.some(path => {\n\t\t\t\tif (!filename.startsWith(path)) return false;\n\t\t\t\tconst len = path.length;\n\t\t\t\tif (filename.length === len || (len > 0 && path[len-1] === pa.sep)) return true;\n\t\t\t\tconst sep = filename[len];\n\t\t\t\treturn sep === '/' || sep === pa.sep;\n\t\t\t});\n\t\t};\n\t} else {\n\t\tcheckPath = () => true;\n\t}\n\n\tlet newCustomResolver = defaultCustomResolver;\n\tlet externals = undefined;\n\tlet external = undefined;\n\tif (customResolver) {\n\t\tlet externalCache;\n\t\tnewCustomResolver = (resolver, x, path, extList) => {\n\t\t\tif (external && !(resolver.pathIsAbsolute(x) || resolver.pathIsRelative(x))) {\n\t\t\t\tif (!externalCache) {\n\t\t\t\t\texternalCache = external.map(ext => new RegExp(makeExternalMatcherRegex(ext)));\n\t\t\t\t}\n\t\t\t\tif (!externalCache.some(regex => regex.test(x))) return undefined;\n\t\t\t}\n\t\t\tconst resolved = customResolver(x, path);\n\t\t\tif (!resolved) return undefined;\n\t\t\tif (externals) externals.push(new RegExp('^' + escapeRegExp(resolved)));\n\t\t\treturn resolver.loadAsFileOrDirecotry(resolved, extList);\n\t\t};\n\t}\n\n\tif (typeof externalOpt !== 'object') {\n\t\treturn new DefaultResolver(builtins, checkPath, [], () => context, newCustomResolver, hostRequire, compiler, strict);\n\t}\n\n\tlet transitive = false;\n\tif (Array.isArray(externalOpt)) {\n\t\texternal = externalOpt;\n\t} else {\n\t\texternal = externalOpt.modules;\n\t\ttransitive = context === 'sandbox' && externalOpt.transitive;\n\t}\n\texternals = external.map(makeExternalMatcher);\n\treturn new LegacyResolver(builtins, checkPath, [], () => context, newCustomResolver, hostRequire, compiler, strict, externals, transitive);\n}\n\nexports.resolverFromOptions = resolverFromOptions;\n","\n\n// The Resolver is currently experimental and might be exposed to users in the future.\n\nconst pa = require('path');\nconst fs = require('fs');\n\nconst {\n\tVMError\n} = require('./bridge');\nconst { VMScript } = require('./script');\n\n// This should match. Note that '\\', '%' are invalid characters\n// 1. name/.*\n// 2. @scope/name/.*\nconst EXPORTS_PATTERN = /^((?:@[^/\\\\%]+\\/)?[^/\\\\%]+)(\\/.*)?$/;\n\n// See https://tc39.es/ecma262/#integer-index\nfunction isArrayIndex(key) {\n\tconst keyNum = +key;\n\tif (`${keyNum}` !== key) return false;\n\treturn keyNum >= 0 && keyNum < 0xFFFFFFFF;\n}\n\nclass Resolver {\n\n\tconstructor(builtinModules, globalPaths, hostRequire) {\n\t\tthis.builtinModules = builtinModules;\n\t\tthis.globalPaths = globalPaths;\n\t\tthis.hostRequire = hostRequire;\n\t}\n\n\tinit(vm) {\n\n\t}\n\n\tpathResolve(path) {\n\t\treturn pa.resolve(path);\n\t}\n\n\tpathIsRelative(path) {\n\t\tif (path === '' || path[0] !== '.') return false;\n\t\tif (path.length === 1) return true;\n\t\tconst idx = path[1] === '.' ? 2 : 1;\n\t\tif (path.length <= idx) return false;\n\t\treturn path[idx] === '/' || path[idx] === pa.sep;\n\t}\n\n\tpathIsAbsolute(path) {\n\t\treturn pa.isAbsolute(path);\n\t}\n\n\tpathConcat(...paths) {\n\t\treturn pa.join(...paths);\n\t}\n\n\tpathBasename(path) {\n\t\treturn pa.basename(path);\n\t}\n\n\tpathDirname(path) {\n\t\treturn pa.dirname(path);\n\t}\n\n\tlookupPaths(mod, id) {\n\t\tif (typeof id === 'string') throw new Error('Id is not a string');\n\t\tif (this.pathIsRelative(id)) return [mod.path || '.'];\n\t\treturn [...mod.paths, ...this.globalPaths];\n\t}\n\n\tgetBuiltinModulesList() {\n\t\treturn Object.getOwnPropertyNames(this.builtinModules);\n\t}\n\n\tloadBuiltinModule(vm, id) {\n\t\tconst handler = this.builtinModules[id];\n\t\treturn handler && handler(this, vm, id);\n\t}\n\n\tloadJS(vm, mod, filename) {\n\t\tthrow new VMError(`Access denied to require '${filename}'`, 'EDENIED');\n\t}\n\n\tloadJSON(vm, mod, filename) {\n\t\tthrow new VMError(`Access denied to require '${filename}'`, 'EDENIED');\n\t}\n\n\tloadNode(vm, mod, filename) {\n\t\tthrow new VMError(`Access denied to require '${filename}'`, 'EDENIED');\n\t}\n\n\tregisterModule(mod, filename, path, parent, direct) {\n\n\t}\n\n\tresolve(mod, x, options, ext, direct) {\n\t\tif (typeof x !== 'string') throw new Error('Id is not a string');\n\n\t\tif (x.startsWith('node:') || this.builtinModules[x]) {\n\t\t\t// a. return the core module\n\t\t\t// b. STOP\n\t\t\treturn x;\n\t\t}\n\n\t\treturn this.resolveFull(mod, x, options, ext, direct);\n\t}\n\n\tresolveFull(mod, x, options, ext, direct) {\n\t\t// 7. THROW \"not found\"\n\t\tthrow new VMError(`Cannot find module '${x}'`, 'ENOTFOUND');\n\t}\n\n\t// NODE_MODULES_PATHS(START)\n\tgenLookupPaths(path) {\n\t\t// 1. let PARTS = path split(START)\n\t\t// 2. let I = count of PARTS - 1\n\t\t// 3. let DIRS = []\n\t\tconst dirs = [];\n\t\t// 4. while I >= 0,\n\t\twhile (true) {\n\t\t\tconst name = this.pathBasename(path);\n\t\t\t// a. if PARTS[I] = \"node_modules\" CONTINUE\n\t\t\tif (name !== 'node_modules') {\n\t\t\t\t// b. DIR = path join(PARTS[0 .. I] + \"node_modules\")\n\t\t\t\t// c. DIRS = DIR + DIRS // Note: this seems wrong. Should be DIRS + DIR\n\t\t\t\tdirs.push(this.pathConcat(path, 'node_modules'));\n\t\t\t}\n\t\t\tconst dir = this.pathDirname(path);\n\t\t\tif (dir == path) break;\n\t\t\t// d. let I = I - 1\n\t\t\tpath = dir;\n\t\t}\n\n\t\treturn dirs;\n\t\t// This is done later on\n\t\t// 5. return DIRS + GLOBAL_FOLDERS\n\t}\n\n}\n\nclass DefaultResolver extends Resolver {\n\n\tconstructor(builtinModules, checkPath, globalPaths, pathContext, customResolver, hostRequire, compiler, strict) {\n\t\tsuper(builtinModules, globalPaths, hostRequire);\n\t\tthis.checkPath = checkPath;\n\t\tthis.pathContext = pathContext;\n\t\tthis.customResolver = customResolver;\n\t\tthis.compiler = compiler;\n\t\tthis.strict = strict;\n\t\tthis.packageCache = {__proto__: null};\n\t\tthis.scriptCache = {__proto__: null};\n\t}\n\n\tisPathAllowed(path) {\n\t\treturn this.checkPath(path);\n\t}\n\n\tpathTestIsDirectory(path) {\n\t\ttry {\n\t\t\tconst stat = fs.statSync(path, {__proto__: null, throwIfNoEntry: false});\n\t\t\treturn stat && stat.isDirectory();\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tpathTestIsFile(path) {\n\t\ttry {\n\t\t\tconst stat = fs.statSync(path, {__proto__: null, throwIfNoEntry: false});\n\t\t\treturn stat && stat.isFile();\n\t\t} catch (e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treadFile(path) {\n\t\treturn fs.readFileSync(path, {encoding: 'utf8'});\n\t}\n\n\treadFileWhenExists(path) {\n\t\treturn this.pathTestIsFile(path) ? this.readFile(path) : undefined;\n\t}\n\n\treadScript(filename) {\n\t\tlet script = this.scriptCache[filename];\n\t\tif (!script) {\n\t\t\tscript = new VMScript(this.readFile(filename), {filename, compiler: this.compiler});\n\t\t\tthis.scriptCache[filename] = script;\n\t\t}\n\t\treturn script;\n\t}\n\n\tcheckAccess(mod, filename) {\n\t\tif (!this.isPathAllowed(filename)) {\n\t\t\tthrow new VMError(`Module '${filename}' is not allowed to be required. The path is outside the border!`, 'EDENIED');\n\t\t}\n\t}\n\n\tloadJS(vm, mod, filename) {\n\t\tfilename = this.pathResolve(filename);\n\t\tthis.checkAccess(mod, filename);\n\t\tif (this.pathContext(filename, 'js') === 'sandbox') {\n\t\t\tconst script = this.readScript(filename);\n\t\t\tvm.run(script, {filename, strict: this.strict, module: mod, wrapper: 'none', dirname: mod.path});\n\t\t} else {\n\t\t\tconst m = this.hostRequire(filename);\n\t\t\tmod.exports = vm.readonly(m);\n\t\t}\n\t}\n\n\tloadJSON(vm, mod, filename) {\n\t\tfilename = this.pathResolve(filename);\n\t\tthis.checkAccess(mod, filename);\n\t\tconst json = this.readFile(filename);\n\t\tmod.exports = vm._jsonParse(json);\n\t}\n\n\tloadNode(vm, mod, filename) {\n\t\tfilename = this.pathResolve(filename);\n\t\tthis.checkAccess(mod, filename);\n\t\tif (this.pathContext(filename, 'node') === 'sandbox') throw new VMError('Native modules can be required only with context set to \\'host\\'.');\n\t\tconst m = this.hostRequire(filename);\n\t\tmod.exports = vm.readonly(m);\n\t}\n\n\t// require(X) from module at path Y\n\tresolveFull(mod, x, options, ext, direct) {\n\t\t// Note: core module handled by caller\n\n\t\tconst extList = Object.getOwnPropertyNames(ext);\n\t\tconst path = mod.path || '.';\n\n\t\t// 5. LOAD_PACKAGE_SELF(X, dirname(Y))\n\t\tlet f = this.loadPackageSelf(x, path, extList);\n\t\tif (f) return f;\n\n\t\t// 4. If X begins with '#'\n\t\tif (x[0] === '#') {\n\t\t\t// a. LOAD_PACKAGE_IMPORTS(X, dirname(Y))\n\t\t\tf = this.loadPackageImports(x, path, extList);\n\t\t\tif (f) return f;\n\t\t}\n\n\t\t// 2. If X begins with '/'\n\t\tif (this.pathIsAbsolute(x)) {\n\t\t\t// a. set Y to be the filesystem root\n\t\t\tf = this.loadAsFileOrDirecotry(x, extList);\n\t\t\tif (f) return f;\n\n\t\t\t// c. THROW \"not found\"\n\t\t\tthrow new VMError(`Cannot find module '${x}'`, 'ENOTFOUND');\n\n\t\t// 3. If X begins with './' or '/' or '../'\n\t\t} else if (this.pathIsRelative(x)) {\n\t\t\tif (typeof options === 'object' && options !== null) {\n\t\t\t\tconst paths = options.paths;\n\t\t\t\tif (Array.isArray(paths)) {\n\t\t\t\t\tfor (let i = 0; i < paths.length; i++) {\n\t\t\t\t\t\t// a. LOAD_AS_FILE(Y + X)\n\t\t\t\t\t\t// b. LOAD_AS_DIRECTORY(Y + X)\n\t\t\t\t\t\tf = this.loadAsFileOrDirecotry(this.pathConcat(paths[i], x), extList);\n\t\t\t\t\t\tif (f) return f;\n\t\t\t\t\t}\n\t\t\t\t} else if (paths === undefined) {\n\t\t\t\t\t// a. LOAD_AS_FILE(Y + X)\n\t\t\t\t\t// b. LOAD_AS_DIRECTORY(Y + X)\n\t\t\t\t\tf = this.loadAsFileOrDirecotry(this.pathConcat(path, x), extList);\n\t\t\t\t\tif (f) return f;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new VMError('Invalid options.paths option.');\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// a. LOAD_AS_FILE(Y + X)\n\t\t\t\t// b. LOAD_AS_DIRECTORY(Y + X)\n\t\t\t\tf = this.loadAsFileOrDirecotry(this.pathConcat(path, x), extList);\n\t\t\t\tif (f) return f;\n\t\t\t}\n\n\t\t\t// c. THROW \"not found\"\n\t\t\tthrow new VMError(`Cannot find module '${x}'`, 'ENOTFOUND');\n\t\t}\n\n\t\tlet dirs;\n\t\tif (typeof options === 'object' && options !== null) {\n\t\t\tconst paths = options.paths;\n\t\t\tif (Array.isArray(paths)) {\n\t\t\t\tdirs = [];\n\n\t\t\t\tfor (let i = 0; i < paths.length; i++) {\n\t\t\t\t\tconst lookups = this.genLookupPaths(paths[i]);\n\t\t\t\t\tfor (let j = 0; j < lookups.length; j++) {\n\t\t\t\t\t\tif (!dirs.includes(lookups[j])) dirs.push(lookups[j]);\n\t\t\t\t\t}\n\t\t\t\t\tif (i === 0) {\n\t\t\t\t\t\tconst globalPaths = this.globalPaths;\n\t\t\t\t\t\tfor (let j = 0; j < globalPaths.length; j++) {\n\t\t\t\t\t\t\tif (!dirs.includes(globalPaths[j])) dirs.push(globalPaths[j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (paths === undefined) {\n\t\t\t\tdirs = [...mod.paths, ...this.globalPaths];\n\t\t\t} else {\n\t\t\t\tthrow new VMError('Invalid options.paths option.');\n\t\t\t}\n\t\t} else {\n\t\t\tdirs = [...mod.paths, ...this.globalPaths];\n\t\t}\n\n\t\t// 6. LOAD_NODE_MODULES(X, dirname(Y))\n\t\tf = this.loadNodeModules(x, dirs, extList);\n\t\tif (f) return f;\n\n\t\tf = this.customResolver(this, x, path, extList);\n\t\tif (f) return f;\n\n\t\treturn super.resolveFull(mod, x, options, ext, direct);\n\t}\n\n\tloadAsFileOrDirecotry(x, extList) {\n\t\t// a. LOAD_AS_FILE(X)\n\t\tconst f = this.loadAsFile(x, extList);\n\t\tif (f) return f;\n\t\t// b. LOAD_AS_DIRECTORY(X)\n\t\treturn this.loadAsDirectory(x, extList);\n\t}\n\n\ttryFile(x) {\n\t\tx = this.pathResolve(x);\n\t\treturn this.isPathAllowed(x) && this.pathTestIsFile(x) ? x : undefined;\n\t}\n\n\ttryWithExtension(x, extList) {\n\t\tfor (let i = 0; i < extList.length; i++) {\n\t\t\tconst ext = extList[i];\n\t\t\tif (ext !== this.pathBasename(ext)) continue;\n\t\t\tconst f = this.tryFile(x + ext);\n\t\t\tif (f) return f;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\treadPackage(path) {\n\t\tconst packagePath = this.pathResolve(this.pathConcat(path, 'package.json'));\n\n\t\tconst cache = this.packageCache[packagePath];\n\t\tif (cache !== undefined) return cache;\n\n\t\tif (!this.isPathAllowed(packagePath)) return undefined;\n\t\tconst content = this.readFileWhenExists(packagePath);\n\t\tif (!content) {\n\t\t\tthis.packageCache[packagePath] = false;\n\t\t\treturn false;\n\t\t}\n\n\t\tlet parsed;\n\t\ttry {\n\t\t\tparsed = JSON.parse(content);\n\t\t} catch (e) {\n\t\t\te.path = packagePath;\n\t\t\te.message = 'Error parsing ' + packagePath + ': ' + e.message;\n\t\t\tthrow e;\n\t\t}\n\n\t\tconst filtered = {\n\t\t\tname: parsed.name,\n\t\t\tmain: parsed.main,\n\t\t\texports: parsed.exports,\n\t\t\timports: parsed.imports,\n\t\t\ttype: parsed.type\n\t\t};\n\t\tthis.packageCache[packagePath] = filtered;\n\t\treturn filtered;\n\t}\n\n\treadPackageScope(path) {\n\t\twhile (true) {\n\t\t\tconst dir = this.pathDirname(path);\n\t\t\tif (dir === path) break;\n\t\t\tconst basename = this.pathBasename(dir);\n\t\t\tif (basename === 'node_modules') break;\n\t\t\tconst pack = this.readPackage(dir);\n\t\t\tif (pack) return {data: pack, scope: dir};\n\t\t\tpath = dir;\n\t\t}\n\t\treturn {data: undefined, scope: undefined};\n\t}\n\n\t// LOAD_AS_FILE(X)\n\tloadAsFile(x, extList) {\n\t\t// 1. If X is a file, load X as its file extension format. STOP\n\t\tconst f = this.tryFile(x);\n\t\tif (f) return f;\n\t\t// 2. If X.js is a file, load X.js as JavaScript text. STOP\n\t\t// 3. If X.json is a file, parse X.json to a JavaScript Object. STOP\n\t\t// 4. If X.node is a file, load X.node as binary addon. STOP\n\t\treturn this.tryWithExtension(x, extList);\n\t}\n\n\t// LOAD_INDEX(X)\n\tloadIndex(x, extList) {\n\t\t// 1. If X/index.js is a file, load X/index.js as JavaScript text. STOP\n\t\t// 2. If X/index.json is a file, parse X/index.json to a JavaScript object. STOP\n\t\t// 3. If X/index.node is a file, load X/index.node as binary addon. STOP\n\t\treturn this.tryWithExtension(this.pathConcat(x, 'index'), extList);\n\t}\n\n\t// LOAD_AS_DIRECTORY(X)\n\tloadAsPackage(x, pack, extList) {\n\t\t// 1. If X/package.json is a file,\n\t\t// already done.\n\t\tif (pack) {\n\t\t\t// a. Parse X/package.json, and look for \"main\" field.\n\t\t\t// b. If \"main\" is a falsy value, GOTO 2.\n\t\t\tif (typeof pack.main === 'string') {\n\t\t\t\t// c. let M = X + (json main field)\n\t\t\t\tconst m = this.pathConcat(x, pack.main);\n\t\t\t\t// d. LOAD_AS_FILE(M)\n\t\t\t\tlet f = this.loadAsFile(m, extList);\n\t\t\t\tif (f) return f;\n\t\t\t\t// e. LOAD_INDEX(M)\n\t\t\t\tf = this.loadIndex(m, extList);\n\t\t\t\tif (f) return f;\n\t\t\t\t// f. LOAD_INDEX(X) DEPRECATED\n\t\t\t\tf = this.loadIndex(x, extList);\n\t\t\t\tif (f) return f;\n\t\t\t\t// g. THROW \"not found\"\n\t\t\t\tthrow new VMError(`Cannot find module '${x}'`, 'ENOTFOUND');\n\t\t\t}\n\t\t}\n\n\t\t// 2. LOAD_INDEX(X)\n\t\treturn this.loadIndex(x, extList);\n\t}\n\n\t// LOAD_AS_DIRECTORY(X)\n\tloadAsDirectory(x, extList) {\n\t\t// 1. If X/package.json is a file,\n\t\tconst pack = this.readPackage(x);\n\t\treturn this.loadAsPackage(x, pack, extList);\n\t}\n\n\t// LOAD_NODE_MODULES(X, START)\n\tloadNodeModules(x, dirs, extList) {\n\t\t// 1. let DIRS = NODE_MODULES_PATHS(START)\n\t\t// This step is already done.\n\n\t\t// 2. for each DIR in DIRS:\n\t\tfor (let i = 0; i < dirs.length; i++) {\n\t\t\tconst dir = dirs[i];\n\t\t\t// a. LOAD_PACKAGE_EXPORTS(X, DIR)\n\t\t\tlet f = this.loadPackageExports(x, dir, extList);\n\t\t\tif (f) return f;\n\t\t\t// b. LOAD_AS_FILE(DIR/X)\n\t\t\tf = this.loadAsFile(dir + '/' + x, extList);\n\t\t\tif (f) return f;\n\t\t\t// c. LOAD_AS_DIRECTORY(DIR/X)\n\t\t\tf = this.loadAsDirectory(dir + '/' + x, extList);\n\t\t\tif (f) return f;\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t// LOAD_PACKAGE_IMPORTS(X, DIR)\n\tloadPackageImports(x, dir, extList) {\n\t\t// 1. Find the closest package scope SCOPE to DIR.\n\t\tconst {data, scope} = this.readPackageScope(dir);\n\t\t// 2. If no scope was found, return.\n\t\tif (!data) return undefined;\n\t\t// 3. If the SCOPE/package.json \"imports\" is null or undefined, return.\n\t\tif (typeof data.imports !== 'object' || data.imports === null || Array.isArray(data.imports)) return undefined;\n\t\t// 4. let MATCH = PACKAGE_IMPORTS_RESOLVE(X, pathToFileURL(SCOPE),\n\t\t//   [\"node\", \"require\"]) defined in the ESM resolver.\n\n\t\t// PACKAGE_IMPORTS_RESOLVE(specifier, parentURL, conditions)\n\t\t// 1. Assert: specifier begins with \"#\".\n\t\t// 2. If specifier is exactly equal to \"#\" or starts with \"#/\", then\n\t\tif (x === '#' || x.startsWith('#/')) {\n\t\t\t// a. Throw an Invalid Module Specifier error.\n\t\t\tthrow new VMError(`Invalid module specifier '${x}'`, 'ERR_INVALID_MODULE_SPECIFIER');\n\t\t}\n\t\t// 3. Let packageURL be the result of LOOKUP_PACKAGE_SCOPE(parentURL).\n\t\t// Note: packageURL === parentURL === scope\n\t\t// 4. If packageURL is not null, then\n\t\t// Always true\n\t\t// a. Let pjson be the result of READ_PACKAGE_JSON(packageURL).\n\t\t// pjson === data\n\t\t// b. If pjson.imports is a non-null Object, then\n\t\t// Already tested\n\t\t// x. Let resolved be the result of PACKAGE_IMPORTS_EXPORTS_RESOLVE( specifier, pjson.imports, packageURL, true, conditions).\n\t\tconst match = this.packageImportsExportsResolve(x, data.imports, scope, true, ['node', 'require'], extList);\n\t\t// y. If resolved is not null or undefined, return resolved.\n\t\tif (!match) {\n\t\t\t// 5. Throw a Package Import Not Defined error.\n\t\t\tthrow new VMError(`Package import not defined for '${x}'`, 'ERR_PACKAGE_IMPORT_NOT_DEFINED');\n\t\t}\n\t\t// END PACKAGE_IMPORTS_RESOLVE\n\n\t\t// 5. RESOLVE_ESM_MATCH(MATCH).\n\t\treturn this.resolveEsmMatch(match, x, extList);\n\t}\n\n\t// LOAD_PACKAGE_EXPORTS(X, DIR)\n\tloadPackageExports(x, dir, extList) {\n\t\t// 1. Try to interpret X as a combination of NAME and SUBPATH where the name\n\t\t//    may have a @scope/ prefix and the subpath begins with a slash (`/`).\n\t\tconst res = x.match(EXPORTS_PATTERN);\n\t\t// 2. If X does not match this pattern or DIR/NAME/package.json is not a file,\n\t\t//    return.\n\t\tif (!res) return undefined;\n\t\tconst scope = this.pathConcat(dir, res[1]);\n\t\tconst pack = this.readPackage(scope);\n\t\tif (!pack) return undefined;\n\t\t// 3. Parse DIR/NAME/package.json, and look for \"exports\" field.\n\t\t// 4. If \"exports\" is null or undefined, return.\n\t\tif (!pack.exports) return undefined;\n\t\t// 5. let MATCH = PACKAGE_EXPORTS_RESOLVE(pathToFileURL(DIR/NAME), \".\" + SUBPATH,\n\t\t//    `package.json` \"exports\", [\"node\", \"require\"]) defined in the ESM resolver.\n\t\tconst match = this.packageExportsResolve(scope, '.' + (res[2] || ''), pack.exports, ['node', 'require'], extList);\n\t\t// 6. RESOLVE_ESM_MATCH(MATCH)\n\t\treturn this.resolveEsmMatch(match, x, extList);\n\t}\n\n\t// LOAD_PACKAGE_SELF(X, DIR)\n\tloadPackageSelf(x, dir, extList) {\n\t\t// 1. Find the closest package scope SCOPE to DIR.\n\t\tconst {data, scope} = this.readPackageScope(dir);\n\t\t// 2. If no scope was found, return.\n\t\tif (!data) return undefined;\n\t\t// 3. If the SCOPE/package.json \"exports\" is null or undefined, return.\n\t\tif (!data.exports) return undefined;\n\t\t// 4. If the SCOPE/package.json \"name\" is not the first segment of X, return.\n\t\tif (x !== data.name && !x.startsWith(data.name + '/')) return undefined;\n\t\t// 5. let MATCH = PACKAGE_EXPORTS_RESOLVE(pathToFileURL(SCOPE),\n\t\t//    \".\" + X.slice(\"name\".length), `package.json` \"exports\", [\"node\", \"require\"])\n\t\t//    defined in the ESM resolver.\n\t\tconst match = this.packageExportsResolve(scope, '.' + x.slice(data.name.length), data.exports, ['node', 'require'], extList);\n\t\t// 6. RESOLVE_ESM_MATCH(MATCH)\n\t\treturn this.resolveEsmMatch(match, x, extList);\n\t}\n\n\t// RESOLVE_ESM_MATCH(MATCH)\n\tresolveEsmMatch(match, x, extList) {\n\t\t// 1. let { RESOLVED, EXACT } = MATCH\n\t\tconst resolved = match;\n\t\tconst exact = true;\n\t\t// 2. let RESOLVED_PATH = fileURLToPath(RESOLVED)\n\t\tconst resolvedPath = resolved;\n\t\tlet f;\n\t\t// 3. If EXACT is true,\n\t\tif (exact) {\n\t\t\t// a. If the file at RESOLVED_PATH exists, load RESOLVED_PATH as its extension\n\t\t\t// format. STOP\n\t\t\tf = this.tryFile(resolvedPath);\n\t\t// 4. Otherwise, if EXACT is false,\n\t\t} else {\n\t\t\t// a. LOAD_AS_FILE(RESOLVED_PATH)\n\t\t\t// b. LOAD_AS_DIRECTORY(RESOLVED_PATH)\n\t\t\tf = this.loadAsFileOrDirecotry(resolvedPath, extList);\n\t\t}\n\t\tif (f) return f;\n\t\t// 5. THROW \"not found\"\n\t\tthrow new VMError(`Cannot find module '${x}'`, 'ENOTFOUND');\n\t}\n\n\t// PACKAGE_EXPORTS_RESOLVE(packageURL, subpath, exports, conditions)\n\tpackageExportsResolve(packageURL, subpath, rexports, conditions, extList) {\n\t\t// 1. If exports is an Object with both a key starting with \".\" and a key not starting with \".\", throw an Invalid Package Configuration error.\n\t\tlet hasDots = false;\n\t\tif (typeof rexports === 'object' && !Array.isArray(rexports)) {\n\t\t\tconst keys = Object.getOwnPropertyNames(rexports);\n\t\t\tif (keys.length > 0) {\n\t\t\t\thasDots = keys[0][0] === '.';\n\t\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\t\tif (hasDots !== (keys[i][0] === '.')) {\n\t\t\t\t\t\tthrow new VMError('Invalid package configuration', 'ERR_INVALID_PACKAGE_CONFIGURATION');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// 2. If subpath is equal to \".\", then\n\t\tif (subpath === '.') {\n\t\t\t// a. Let mainExport be undefined.\n\t\t\tlet mainExport = undefined;\n\t\t\t// b. If exports is a String or Array, or an Object containing no keys starting with \".\", then\n\t\t\tif (typeof rexports === 'string' || Array.isArray(rexports) || !hasDots) {\n\t\t\t\t// x. Set mainExport to exports.\n\t\t\t\tmainExport = rexports;\n\t\t\t// c. Otherwise if exports is an Object containing a \".\" property, then\n\t\t\t} else if (hasDots) {\n\t\t\t\t// x. Set mainExport to exports[\".\"].\n\t\t\t\tmainExport = rexports['.'];\n\t\t\t}\n\t\t\t// d. If mainExport is not undefined, then\n\t\t\tif (mainExport) {\n\t\t\t\t// x. Let resolved be the result of PACKAGE_TARGET_RESOLVE( packageURL, mainExport, \"\", false, false, conditions).\n\t\t\t\tconst resolved = this.packageTargetResolve(packageURL, mainExport, '', false, false, conditions, extList);\n\t\t\t\t// y. If resolved is not null or undefined, return resolved.\n\t\t\t\tif (resolved) return resolved;\n\t\t\t}\n\t\t// 3. Otherwise, if exports is an Object and all keys of exports start with \".\", then\n\t\t} else if (hasDots) {\n\t\t\t// a. Let matchKey be the string \"./\" concatenated with subpath.\n\t\t\t// Note: Here subpath starts already with './'\n\t\t\t// b. Let resolved be the result of PACKAGE_IMPORTS_EXPORTS_RESOLVE( matchKey, exports, packageURL, false, conditions).\n\t\t\tconst resolved = this.packageImportsExportsResolve(subpath, rexports, packageURL, false, conditions, extList);\n\t\t\t// c. If resolved is not null or undefined, return resolved.\n\t\t\tif (resolved) return resolved;\n\t\t}\n\t\t// 4. Throw a Package Path Not Exported error.\n\t\tthrow new VMError(`Package path '${subpath}' is not exported`, 'ERR_PACKAGE_PATH_NOT_EXPORTED');\n\t}\n\n\t// PACKAGE_IMPORTS_EXPORTS_RESOLVE(matchKey, matchObj, packageURL, isImports, conditions)\n\tpackageImportsExportsResolve(matchKey, matchObj, packageURL, isImports, conditions, extList) {\n\t\t// 1. If matchKey is a key of matchObj and does not contain \"*\", then\n\t\tlet target = matchObj[matchKey];\n\t\tif (target && matchKey.indexOf('*') === -1) {\n\t\t\t// a. Let target be the value of matchObj[matchKey].\n\t\t\t// b. Return the result of PACKAGE_TARGET_RESOLVE(packageURL, target, \"\", false, isImports, conditions).\n\t\t\treturn this.packageTargetResolve(packageURL, target, '', false, isImports, conditions, extList);\n\t\t}\n\t\t// 2. Let expansionKeys be the list of keys of matchObj containing only a single \"*\",\n\t\t//    sorted by the sorting function PATTERN_KEY_COMPARE which orders in descending order of specificity.\n\t\tconst expansionKeys = Object.getOwnPropertyNames(matchObj);\n\t\tlet bestKey = '';\n\t\tlet bestSubpath;\n\t\t// 3. For each key expansionKey in expansionKeys, do\n\t\tfor (let i = 0; i < expansionKeys.length; i++) {\n\t\t\tconst expansionKey = expansionKeys[i];\n\t\t\tif (matchKey.length < expansionKey.length) continue;\n\t\t\t// a. Let patternBase be the substring of expansionKey up to but excluding the first \"*\" character.\n\t\t\tconst star = expansionKey.indexOf('*');\n\t\t\tif (star === -1) continue; // Note: expansionKeys was not filtered\n\t\t\tconst patternBase = expansionKey.slice(0, star);\n\t\t\t// b. If matchKey starts with but is not equal to patternBase, then\n\t\t\tif (matchKey.startsWith(patternBase) && expansionKey.indexOf('*', star + 1) === -1) { // Note: expansionKeys was not filtered\n\t\t\t\t// 1. Let patternTrailer be the substring of expansionKey from the index after the first \"*\" character.\n\t\t\t\tconst patternTrailer = expansionKey.slice(star + 1);\n\t\t\t\t// 2. If patternTrailer has zero length, or if matchKey ends with patternTrailer and the length of matchKey is greater than or\n\t\t\t\t//    equal to the length of expansionKey, then\n\t\t\t\tif (matchKey.endsWith(patternTrailer) && this.patternKeyCompare(bestKey, expansionKey) === 1) { // Note: expansionKeys was not sorted\n\t\t\t\t\t// a. Let target be the value of matchObj[expansionKey].\n\t\t\t\t\ttarget = matchObj[expansionKey];\n\t\t\t\t\t// b. Let subpath be the substring of matchKey starting at the index of the length of patternBase up to the length of\n\t\t\t\t\t//    matchKey minus the length of patternTrailer.\n\t\t\t\t\tbestKey = expansionKey;\n\t\t\t\t\tbestSubpath = matchKey.slice(patternBase.length, matchKey.length - patternTrailer.length);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (bestSubpath) { // Note: expansionKeys was not sorted\n\t\t\t// c. Return the result of PACKAGE_TARGET_RESOLVE(packageURL, target, subpath, true, isImports, conditions).\n\t\t\treturn this.packageTargetResolve(packageURL, target, bestSubpath, true, isImports, conditions, extList);\n\t\t}\n\t\t// 4. Return null.\n\t\treturn null;\n\t}\n\n\t// PATTERN_KEY_COMPARE(keyA, keyB)\n\tpatternKeyCompare(keyA, keyB) {\n\t\t// 1. Assert: keyA ends with \"/\" or contains only a single \"*\".\n\t\t// 2. Assert: keyB ends with \"/\" or contains only a single \"*\".\n\t\t// 3. Let baseLengthA be the index of \"*\" in keyA plus one, if keyA contains \"*\", or the length of keyA otherwise.\n\t\tconst baseAStar = keyA.indexOf('*');\n\t\tconst baseLengthA = baseAStar === -1 ? keyA.length : baseAStar + 1;\n\t\t// 4. Let baseLengthB be the index of \"*\" in keyB plus one, if keyB contains \"*\", or the length of keyB otherwise.\n\t\tconst baseBStar = keyB.indexOf('*');\n\t\tconst baseLengthB = baseBStar === -1 ? keyB.length : baseBStar + 1;\n\t\t// 5. If baseLengthA is greater than baseLengthB, return -1.\n\t\tif (baseLengthA > baseLengthB) return -1;\n\t\t// 6. If baseLengthB is greater than baseLengthA, return 1.\n\t\tif (baseLengthB > baseLengthA) return 1;\n\t\t// 7. If keyA does not contain \"*\", return 1.\n\t\tif (baseAStar === -1) return 1;\n\t\t// 8. If keyB does not contain \"*\", return -1.\n\t\tif (baseBStar === -1) return -1;\n\t\t// 9. If the length of keyA is greater than the length of keyB, return -1.\n\t\tif (keyA.length > keyB.length) return -1;\n\t\t// 10. If the length of keyB is greater than the length of keyA, return 1.\n\t\tif (keyB.length > keyA.length) return 1;\n\t\t// 11. Return 0.\n\t\treturn 0;\n\t}\n\n\t// PACKAGE_TARGET_RESOLVE(packageURL, target, subpath, pattern, internal, conditions)\n\tpackageTargetResolve(packageURL, target, subpath, pattern, internal, conditions, extList) {\n\t\t// 1. If target is a String, then\n\t\tif (typeof target === 'string') {\n\t\t\t// a. If pattern is false, subpath has non-zero length and target does not end with \"/\", throw an Invalid Module Specifier error.\n\t\t\tif (!pattern && subpath.length > 0 && !target.endsWith('/')) {\n\t\t\t\tthrow new VMError(`Invalid package specifier '${subpath}'`, 'ERR_INVALID_MODULE_SPECIFIER');\n\t\t\t}\n\t\t\t// b. If target does not start with \"./\", then\n\t\t\tif (!target.startsWith('./')) {\n\t\t\t\t// 1. If internal is true and target does not start with \"../\" or \"/\" and is not a valid URL, then\n\t\t\t\tif (internal && !target.startsWith('../') && !target.startsWith('/')) {\n\t\t\t\t\tlet isURL = false;\n\t\t\t\t\ttry {\n\t\t\t\t\t\t// eslint-disable-next-line no-new\n\t\t\t\t\t\tnew URL(target);\n\t\t\t\t\t\tisURL = true;\n\t\t\t\t\t} catch (e) {}\n\t\t\t\t\tif (!isURL) {\n\t\t\t\t\t\t// a. If pattern is true, then\n\t\t\t\t\t\tif (pattern) {\n\t\t\t\t\t\t\t// 1. Return PACKAGE_RESOLVE(target with every instance of \"*\" replaced by subpath, packageURL + \"/\").\n\t\t\t\t\t\t\treturn this.packageResolve(target.replace(/\\*/g, subpath), packageURL, conditions, extList);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// b. Return PACKAGE_RESOLVE(target + subpath, packageURL + \"/\").\n\t\t\t\t\t\treturn this.packageResolve(this.pathConcat(target, subpath), packageURL, conditions, extList);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Otherwise, throw an Invalid Package Target error.\n\t\t\t\tthrow new VMError(`Invalid package target for '${subpath}'`, 'ERR_INVALID_PACKAGE_TARGET');\n\t\t\t}\n\t\t\ttarget = decodeURI(target);\n\t\t\t// c. If target split on \"/\" or \"\\\" contains any \".\", \"..\" or \"node_modules\" segments after the first segment, case insensitive\n\t\t\t//    and including percent encoded variants, throw an Invalid Package Target error.\n\t\t\tif (target.split(/[/\\\\]/).slice(1).findIndex(x => x === '.' || x === '..' || x.toLowerCase() === 'node_modules') !== -1) {\n\t\t\t\tthrow new VMError(`Invalid package target for '${subpath}'`, 'ERR_INVALID_PACKAGE_TARGET');\n\t\t\t}\n\t\t\t// d. Let resolvedTarget be the URL resolution of the concatenation of packageURL and target.\n\t\t\tconst resolvedTarget = this.pathConcat(packageURL, target);\n\t\t\t// e. Assert: resolvedTarget is contained in packageURL.\n\t\t\tsubpath = decodeURI(subpath);\n\t\t\t// f. If subpath split on \"/\" or \"\\\" contains any \".\", \"..\" or \"node_modules\" segments, case insensitive and including percent\n\t\t\t//    encoded variants, throw an Invalid Module Specifier error.\n\t\t\tif (subpath.split(/[/\\\\]/).findIndex(x => x === '.' || x === '..' || x.toLowerCase() === 'node_modules') !== -1) {\n\t\t\t\tthrow new VMError(`Invalid package specifier '${subpath}'`, 'ERR_INVALID_MODULE_SPECIFIER');\n\t\t\t}\n\t\t\t// g. If pattern is true, then\n\t\t\tif (pattern) {\n\t\t\t\t// 1. Return the URL resolution of resolvedTarget with every instance of \"*\" replaced with subpath.\n\t\t\t\treturn resolvedTarget.replace(/\\*/g, subpath);\n\t\t\t}\n\t\t\t// h. Otherwise,\n\t\t\t// 1. Return the URL resolution of the concatenation of subpath and resolvedTarget.\n\t\t\treturn this.pathConcat(resolvedTarget, subpath);\n\t\t// 3. Otherwise, if target is an Array, then\n\t\t} else if (Array.isArray(target)) {\n\t\t\t// a. If target.length is zero, return null.\n\t\t\tif (target.length === 0) return null;\n\t\t\tlet lastException = undefined;\n\t\t\t// b. For each item targetValue in target, do\n\t\t\tfor (let i = 0; i < target.length; i++) {\n\t\t\t\tconst targetValue = target[i];\n\t\t\t\t// 1. Let resolved be the result of PACKAGE_TARGET_RESOLVE( packageURL, targetValue, subpath, pattern, internal, conditions),\n\t\t\t\t//    continuing the loop on any Invalid Package Target error.\n\t\t\t\tlet resolved;\n\t\t\t\ttry {\n\t\t\t\t\tresolved = this.packageTargetResolve(packageURL, targetValue, subpath, pattern, internal, conditions, extList);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tif (e.code !== 'ERR_INVALID_PACKAGE_TARGET') throw e;\n\t\t\t\t\tlastException = e;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// 2. If resolved is undefined, continue the loop.\n\t\t\t\t// 3. Return resolved.\n\t\t\t\tif (resolved !== undefined) return resolved;\n\t\t\t\tif (resolved === null) {\n\t\t\t\t\tlastException = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// c. Return or throw the last fallback resolution null return or error.\n\t\t\tif (lastException === undefined || lastException === null) return lastException;\n\t\t\tthrow lastException;\n\t\t// 2. Otherwise, if target is a non-null Object, then\n\t\t} else if (typeof target === 'object' && target !== null) {\n\t\t\tconst keys = Object.getOwnPropertyNames(target);\n\t\t\t// a. If exports contains any index property keys, as defined in ECMA-262 6.1.7 Array Index, throw an Invalid Package Configuration error.\n\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\tconst p = keys[i];\n\t\t\t\tif (isArrayIndex(p)) throw new VMError(`Invalid package configuration for '${subpath}'`, 'ERR_INVALID_PACKAGE_CONFIGURATION');\n\t\t\t}\n\t\t\t// b. For each property p of target, in object insertion order as,\n\t\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\t\tconst p = keys[i];\n\t\t\t\t// 1. If p equals \"default\" or conditions contains an entry for p, then\n\t\t\t\tif (p === 'default' || conditions.includes(p)) {\n\t\t\t\t\t// a. Let targetValue be the value of the p property in target.\n\t\t\t\t\tconst targetValue = target[p];\n\t\t\t\t\t// b. Let resolved be the result of PACKAGE_TARGET_RESOLVE( packageURL, targetValue, subpath, pattern, internal, conditions).\n\t\t\t\t\tconst resolved = this.packageTargetResolve(packageURL, targetValue, subpath, pattern, internal, conditions, extList);\n\t\t\t\t\t// c. If resolved is equal to undefined, continue the loop.\n\t\t\t\t\t// d. Return resolved.\n\t\t\t\t\tif (resolved !== undefined) return resolved;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// c. Return undefined.\n\t\t\treturn undefined;\n\t\t// 4. Otherwise, if target is null, return null.\n\t\t} else if (target == null) {\n\t\t\treturn null;\n\t\t}\n\t\t// Otherwise throw an Invalid Package Target error.\n\t\tthrow new VMError(`Invalid package target for '${subpath}'`, 'ERR_INVALID_PACKAGE_TARGET');\n\t}\n\n\t// PACKAGE_RESOLVE(packageSpecifier, parentURL)\n\tpackageResolve(packageSpecifier, parentURL, conditions, extList) {\n\t\t// 1. Let packageName be undefined.\n\t\tlet packageName = undefined;\n\t\t// 2. If packageSpecifier is an empty string, then\n\t\tif (packageSpecifier === '') {\n\t\t\t// a. Throw an Invalid Module Specifier error.\n\t\t\tthrow new VMError(`Invalid package specifier '${packageSpecifier}'`, 'ERR_INVALID_MODULE_SPECIFIER');\n\t\t}\n\t\t// 3. If packageSpecifier is a Node.js builtin module name, then\n\t\tif (this.builtinModules[packageSpecifier]) {\n\t\t\t// a. Return the string \"node:\" concatenated with packageSpecifier.\n\t\t\treturn 'node:' + packageSpecifier;\n\t\t}\n\t\tlet idx = packageSpecifier.indexOf('/');\n\t\t// 5. Otherwise,\n\t\tif (packageSpecifier[0] === '@') {\n\t\t\t// a. If packageSpecifier does not contain a \"/\" separator, then\n\t\t\tif (idx === -1) {\n\t\t\t\t// x. Throw an Invalid Module Specifier error.\n\t\t\t\tthrow new VMError(`Invalid package specifier '${packageSpecifier}'`, 'ERR_INVALID_MODULE_SPECIFIER');\n\t\t\t}\n\t\t\t// b. Set packageName to the substring of packageSpecifier until the second \"/\" separator or the end of the string.\n\t\t\tidx = packageSpecifier.indexOf('/', idx + 1);\n\t\t}\n\t\t// else\n\t\t// 4. If packageSpecifier does not start with \"@\", then\n\t\t// a. Set packageName to the substring of packageSpecifier until the first \"/\" separator or the end of the string.\n\t\tpackageName = idx === -1 ? packageSpecifier : packageSpecifier.slice(0, idx);\n\t\t// 6. If packageName starts with \".\" or contains \"\\\" or \"%\", then\n\t\tif (idx !== 0 && (packageName[0] === '.' || packageName.indexOf('\\\\') >= 0 || packageName.indexOf('%') >= 0)) {\n\t\t\t// a. Throw an Invalid Module Specifier error.\n\t\t\tthrow new VMError(`Invalid package specifier '${packageSpecifier}'`, 'ERR_INVALID_MODULE_SPECIFIER');\n\t\t}\n\t\t// 7. Let packageSubpath be \".\" concatenated with the substring of packageSpecifier from the position at the length of packageName.\n\t\tconst packageSubpath = '.' + packageSpecifier.slice(packageName.length);\n\t\t// 8. If packageSubpath ends in \"/\", then\n\t\tif (packageSubpath[packageSubpath.length - 1] === '/') {\n\t\t\t// a. Throw an Invalid Module Specifier error.\n\t\t\tthrow new VMError(`Invalid package specifier '${packageSpecifier}'`, 'ERR_INVALID_MODULE_SPECIFIER');\n\t\t}\n\t\t// 9. Let selfUrl be the result of PACKAGE_SELF_RESOLVE(packageName, packageSubpath, parentURL).\n\t\tconst selfUrl = this.packageSelfResolve(packageName, packageSubpath, parentURL);\n\t\t// 10. If selfUrl is not undefined, return selfUrl.\n\t\tif (selfUrl) return selfUrl;\n\t\t// 11. While parentURL is not the file system root,\n\t\tlet packageURL;\n\t\twhile (true) {\n\t\t\t// a. Let packageURL be the URL resolution of \"node_modules/\" concatenated with packageSpecifier, relative to parentURL.\n\t\t\tpackageURL = this.pathResolve(this.pathConcat(parentURL, 'node_modules', packageSpecifier));\n\t\t\t// b. Set parentURL to the parent folder URL of parentURL.\n\t\t\tconst parentParentURL = this.pathDirname(parentURL);\n\t\t\t// c. If the folder at packageURL does not exist, then\n\t\t\tif (this.isPathAllowed(packageURL) && this.pathTestIsDirectory(packageURL)) break;\n\t\t\t// 1. Continue the next loop iteration.\n\t\t\tif (parentParentURL === parentURL) {\n\t\t\t\t// 12. Throw a Module Not Found error.\n\t\t\t\tthrow new VMError(`Cannot find module '${packageSpecifier}'`, 'ENOTFOUND');\n\t\t\t}\n\t\t\tparentURL = parentParentURL;\n\t\t}\n\t\t// d. Let pjson be the result of READ_PACKAGE_JSON(packageURL).\n\t\tconst pack = this.readPackage(packageURL);\n\t\t// e. If pjson is not null and pjson.exports is not null or undefined, then\n\t\tif (pack && pack.exports) {\n\t\t\t// 1. Return the result of PACKAGE_EXPORTS_RESOLVE(packageURL, packageSubpath, pjson.exports, defaultConditions).\n\t\t\treturn this.packageExportsResolve(packageURL, packageSubpath, pack.exports, conditions, extList);\n\t\t}\n\t\t// f. Otherwise, if packageSubpath is equal to \".\", then\n\t\tif (packageSubpath === '.') {\n\t\t\t// 1. If pjson.main is a string, then\n\t\t\t// a. Return the URL resolution of main in packageURL.\n\t\t\treturn this.loadAsPackage(packageSubpath, pack, extList);\n\t\t}\n\t\t// g. Otherwise,\n\t\t// 1. Return the URL resolution of packageSubpath in packageURL.\n\t\treturn this.pathConcat(packageURL, packageSubpath);\n\t}\n\n}\n\nexports.Resolver = Resolver;\nexports.DefaultResolver = DefaultResolver;\n"]}